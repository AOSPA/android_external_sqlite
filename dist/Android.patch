diff -r -u -d orig/shell.c ./shell.c
--- orig/shell.c	2018-04-02 13:20:53.000000000 +0200
+++ ./shell.c	2018-04-05 23:08:25.705443182 +0200
@@ -87,6 +87,12 @@
 #endif
 #include <ctype.h>
 #include <stdarg.h>
+// Begin Android Add
+#ifndef NO_ANDROID_FUNCS
+#include "IcuUtils.h"
+#include <sqlite3_android.h>
+#endif
+// End Android Add
 
 #if !defined(_WIN32) && !defined(WIN32)
 # include <signal.h>
@@ -150,9 +156,6 @@
 # ifndef access
 #  define access(f,m) _access((f),(m))
 # endif
-# ifndef unlink
-#  define unlink _unlink
-# endif
 # undef popen
 # define popen _popen
 # undef pclose
@@ -1000,10 +1003,7 @@
 ** We need several data types from the Windows SDK header.
 */
 
-#ifndef WIN32_LEAN_AND_MEAN
 #define WIN32_LEAN_AND_MEAN
-#endif
-
 #include "windows.h"
 
 /*
@@ -2145,9 +2145,6 @@
 #  include <direct.h>
 /* #  include "test_windirent.h" */
 #  define dirent DIRENT
-#  ifndef chmod
-#    define chmod _chmod
-#  endif
 #  ifndef stat
 #    define stat _stat
 #  endif
@@ -2214,97 +2211,6 @@
   va_end(ap);
 }
 
-#if defined(_WIN32)
-/*
-** This function is designed to convert a Win32 FILETIME structure into the
-** number of seconds since the Unix Epoch (1970-01-01 00:00:00 UTC).
-*/
-static sqlite3_uint64 fileTimeToUnixTime(
-  LPFILETIME pFileTime
-){
-  SYSTEMTIME epochSystemTime;
-  ULARGE_INTEGER epochIntervals;
-  FILETIME epochFileTime;
-  ULARGE_INTEGER fileIntervals;
-
-  memset(&epochSystemTime, 0, sizeof(SYSTEMTIME));
-  epochSystemTime.wYear = 1970;
-  epochSystemTime.wMonth = 1;
-  epochSystemTime.wDay = 1;
-  SystemTimeToFileTime(&epochSystemTime, &epochFileTime);
-  epochIntervals.LowPart = epochFileTime.dwLowDateTime;
-  epochIntervals.HighPart = epochFileTime.dwHighDateTime;
-
-  fileIntervals.LowPart = pFileTime->dwLowDateTime;
-  fileIntervals.HighPart = pFileTime->dwHighDateTime;
-
-  return (fileIntervals.QuadPart - epochIntervals.QuadPart) / 10000000;
-}
-
-/*
-** This function attempts to normalize the time values found in the stat()
-** buffer to UTC.  This is necessary on Win32, where the runtime library
-** appears to return these values as local times.
-*/
-static void statTimesToUtc(
-  const char *zPath,
-  struct stat *pStatBuf
-){
-  HANDLE hFindFile;
-  WIN32_FIND_DATAW fd;
-  LPWSTR zUnicodeName;
-  extern LPWSTR sqlite3_win32_utf8_to_unicode(const char*);
-  zUnicodeName = sqlite3_win32_utf8_to_unicode(zPath);
-  if( zUnicodeName ){
-    memset(&fd, 0, sizeof(WIN32_FIND_DATA));
-    hFindFile = FindFirstFileW(zUnicodeName, &fd);
-    if( hFindFile!=NULL ){
-      pStatBuf->st_ctime = (time_t)fileTimeToUnixTime(&fd.ftCreationTime);
-      pStatBuf->st_atime = (time_t)fileTimeToUnixTime(&fd.ftLastAccessTime);
-      pStatBuf->st_mtime = (time_t)fileTimeToUnixTime(&fd.ftLastWriteTime);
-      FindClose(hFindFile);
-    }
-    sqlite3_free(zUnicodeName);
-  }
-}
-#endif
-
-/*
-** This function is used in place of stat().  On Windows, special handling
-** is required in order for the included time to be returned as UTC.  On all
-** other systems, this function simply calls stat().
-*/
-static int fileStat(
-  const char *zPath,
-  struct stat *pStatBuf
-){
-#if defined(_WIN32)
-  int rc = stat(zPath, pStatBuf);
-  if( rc==0 ) statTimesToUtc(zPath, pStatBuf);
-  return rc;
-#else
-  return stat(zPath, pStatBuf);
-#endif
-}
-
-/*
-** This function is used in place of lstat().  On Windows, special handling
-** is required in order for the included time to be returned as UTC.  On all
-** other systems, this function simply calls lstat().
-*/
-static int fileLinkStat(
-  const char *zPath,
-  struct stat *pStatBuf
-){
-#if defined(_WIN32)
-  int rc = lstat(zPath, pStatBuf);
-  if( rc==0 ) statTimesToUtc(zPath, pStatBuf);
-  return rc;
-#else
-  return lstat(zPath, pStatBuf);
-#endif
-}
-
 /*
 ** Argument zFile is the name of a file that will be created and/or written
 ** by SQL function writefile(). This function ensures that the directory
@@ -2336,7 +2242,7 @@
       if( i==nCopy ) break;
       zCopy[i] = '\0';
 
-      rc2 = fileStat(zCopy, &sStat);
+      rc2 = stat(zCopy, &sStat);
       if( rc2!=0 ){
         if( mkdir(zCopy, mode & 0777) ) rc = SQLITE_ERROR;
       }else{
@@ -2378,7 +2284,7 @@
         ** to do so using chmod(), it is not an error.  */
         struct stat sStat;
         if( errno!=EEXIST
-         || 0!=fileStat(zFile, &sStat)
+         || 0!=stat(zFile, &sStat)
          || !S_ISDIR(sStat.st_mode)
          || ((sStat.st_mode&0777)!=(mode&0777) && 0!=chmod(zFile, mode&0777))
         ){
@@ -2416,23 +2322,15 @@
     SYSTEMTIME currentTime;
     LONGLONG intervals;
     HANDLE hFile;
-    LPWSTR zUnicodeName;
-    extern LPWSTR sqlite3_win32_utf8_to_unicode(const char*);
-
     GetSystemTime(&currentTime);
     SystemTimeToFileTime(&currentTime, &lastAccess);
     intervals = Int32x32To64(mtime, 10000000) + 116444736000000000;
     lastWrite.dwLowDateTime = (DWORD)intervals;
     lastWrite.dwHighDateTime = intervals >> 32;
-    zUnicodeName = sqlite3_win32_utf8_to_unicode(zFile);
-    if( zUnicodeName==0 ){
-      return 1;
-    }
-    hFile = CreateFileW(
-      zUnicodeName, FILE_WRITE_ATTRIBUTES, 0, NULL, OPEN_EXISTING,
+    hFile = CreateFile(
+      zFile, FILE_WRITE_ATTRIBUTES, 0, NULL, OPEN_EXISTING,
       FILE_FLAG_BACKUP_SEMANTICS, NULL
     );
-    sqlite3_free(zUnicodeName);
     if( hFile!=INVALID_HANDLE_VALUE ){
       BOOL bResult = SetFileTime(hFile, NULL, &lastAccess, &lastWrite);
       CloseHandle(hFile);
@@ -2440,7 +2338,7 @@
     }else{
       return 1;
     }
-#elif defined(AT_FDCWD) && 0 /* utimensat() is not universally available */
+#elif defined(AT_FDCWD) && 0 /* utimensat() is not univerally available */
     /* Recent unix */
     struct timespec times[2];
     times[0].tv_nsec = times[1].tv_nsec = 0;
@@ -2640,12 +2538,10 @@
     sqlite3_free(pLvl->zDir);
   }
   sqlite3_free(pCur->zPath);
-  sqlite3_free(pCur->aLvl);
   pCur->aLvl = 0;
   pCur->zPath = 0;
   pCur->zBase = 0;
   pCur->nBase = 0;
-  pCur->nLvl = 0;
   pCur->iLvl = -1;
   pCur->iRowid = 1;
 }
@@ -2657,6 +2553,7 @@
   fsdir_cursor *pCur = (fsdir_cursor*)cur;
 
   fsdirResetCursor(pCur);
+  sqlite3_free(pCur->aLvl);
   sqlite3_free(pCur);
   return SQLITE_OK;
 }
@@ -2717,7 +2614,7 @@
       sqlite3_free(pCur->zPath);
       pCur->zPath = sqlite3_mprintf("%s/%s", pLvl->zDir, pEntry->d_name);
       if( pCur->zPath==0 ) return SQLITE_NOMEM;
-      if( fileLinkStat(pCur->zPath, &pCur->sStat) ){
+      if( lstat(pCur->zPath, &pCur->sStat) ){
         fsdirSetErrmsg(pCur, "cannot stat file: %s", pCur->zPath);
         return SQLITE_ERROR;
       }
@@ -2851,7 +2748,7 @@
   if( pCur->zPath==0 ){
     return SQLITE_NOMEM;
   }
-  if( fileLinkStat(pCur->zPath, &pCur->sStat) ){
+  if( lstat(pCur->zPath, &pCur->sStat) ){
     fsdirSetErrmsg(pCur, "cannot stat file: %s", pCur->zPath);
     return SQLITE_ERROR;
   }
@@ -3058,7 +2955,7 @@
 #define COMPLETION_INDEXES       5
 #define COMPLETION_TRIGGERS      6
 #define COMPLETION_DATABASES     7
-#define COMPLETION_TABLES        8    /* Also VIEWs and TRIGGERs */
+#define COMPLETION_TABLES        8
 #define COMPLETION_COLUMNS       9
 #define COMPLETION_MODULES       10
 #define COMPLETION_EOF           11
@@ -3230,7 +3127,8 @@
             const char *zDb = (const char*)sqlite3_column_text(pS2, 1);
             zSql = sqlite3_mprintf(
                "%z%s"
-               "SELECT name FROM \"%w\".sqlite_master",
+               "SELECT name FROM \"%w\".sqlite_master"
+               " WHERE type='table'",
                zSql, zSep, zDb
             );
             if( zSql==0 ) return SQLITE_NOMEM;
@@ -4102,48 +4000,29 @@
 #include <string.h>
 #include <assert.h>
 
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#if !defined(_WIN32) && !defined(WIN32)
+#  include <unistd.h>
+#  include <dirent.h>
+#  include <utime.h>
+#else
+#  include <io.h>
+#endif
+#include <time.h>
+#include <errno.h>
+
 #include <zlib.h>
 
 #ifndef SQLITE_OMIT_VIRTUALTABLE
 
 #ifndef SQLITE_AMALGAMATION
-
 /* typedef sqlite3_int64 i64; */
 /* typedef unsigned char u8; */
 typedef unsigned short u16;
 typedef unsigned long u32;
 #define MIN(a,b) ((a)<(b) ? (a) : (b))
-
-#if defined(SQLITE_COVERAGE_TEST) || defined(SQLITE_MUTATION_TEST)
-# define ALWAYS(X)      (1)
-# define NEVER(X)       (0)
-#elif !defined(NDEBUG)
-# define ALWAYS(X)      ((X)?1:(assert(0),0))
-# define NEVER(X)       ((X)?(assert(0),1):0)
-#else
-# define ALWAYS(X)      (X)
-# define NEVER(X)       (X)
-#endif
-
-#endif   /* SQLITE_AMALGAMATION */
-
-/*
-** Definitions for mode bitmasks S_IFDIR, S_IFREG and S_IFLNK.
-**
-** In some ways it would be better to obtain these values from system 
-** header files. But, the dependency is undesirable and (a) these
-** have been stable for decades, (b) the values are part of POSIX and
-** are also made explicit in [man stat], and (c) are part of the 
-** file format for zip archives.
-*/
-#ifndef S_IFDIR
-# define S_IFDIR 0040000
-#endif
-#ifndef S_IFREG
-# define S_IFREG 0100000
-#endif
-#ifndef S_IFLNK
-# define S_IFLNK 0120000
 #endif
 
 static const char ZIPFILE_SCHEMA[] = 
@@ -4184,9 +4063,6 @@
 **
 ** ZIPFILE_SIGNATURE_LFH:
 **   First 4 bytes of a valid LFH record.
-**
-** ZIPFILE_SIGNATURE_EOCD
-**   First 4 bytes of a valid EOCD record.
 */
 #define ZIPFILE_EXTRA_TIMESTAMP   0x5455
 #define ZIPFILE_NEWENTRY_MADEBY   ((3<<8) + 30)
@@ -4195,14 +4071,22 @@
 #define ZIPFILE_SIGNATURE_CDS     0x02014b50
 #define ZIPFILE_SIGNATURE_LFH     0x04034b50
 #define ZIPFILE_SIGNATURE_EOCD    0x06054b50
+#define ZIPFILE_LFH_FIXED_SZ      30
 
 /*
-** The sizes of the fixed-size part of each of the three main data 
-** structures in a zip archive.
+** Set the error message contained in context ctx to the results of
+** vprintf(zFmt, ...).
 */
-#define ZIPFILE_LFH_FIXED_SZ      30
-#define ZIPFILE_EOCD_FIXED_SZ     22
-#define ZIPFILE_CDS_FIXED_SZ      46
+static void zipfileCtxErrorMsg(sqlite3_context *ctx, const char *zFmt, ...){
+  char *zMsg = 0;
+  va_list ap;
+  va_start(ap, zFmt);
+  zMsg = sqlite3_vmprintf(zFmt, ap);
+  sqlite3_result_error(ctx, zMsg, -1);
+  sqlite3_free(zMsg);
+  va_end(ap);
+}
+
 
 /*
 *** 4.3.16  End of central directory record:
@@ -4308,39 +4192,47 @@
 
 typedef struct ZipfileEntry ZipfileEntry;
 struct ZipfileEntry {
-  ZipfileCDS cds;            /* Parsed CDS record */
-  u32 mUnixTime;             /* Modification time, in UNIX format */
-  u8 *aExtra;                /* cds.nExtra+cds.nComment bytes of extra data */
-  i64 iDataOff;              /* Offset to data in file (if aData==0) */
-  u8 *aData;                 /* cds.szCompressed bytes of compressed data */
+  char *zPath;               /* Path of zipfile entry */
+  u8 *aCdsEntry;             /* Buffer containing entire CDS entry */
+  int nCdsEntry;             /* Size of buffer aCdsEntry[] in bytes */
+  int bDeleted;              /* True if entry has been deleted */
   ZipfileEntry *pNext;       /* Next element in in-memory CDS */
 };
 
 /* 
-** Cursor type for zipfile tables.
+** Cursor type for recursively iterating through a directory structure.
 */
 typedef struct ZipfileCsr ZipfileCsr;
 struct ZipfileCsr {
   sqlite3_vtab_cursor base;  /* Base class - must be first */
   i64 iId;                   /* Cursor ID */
-  u8 bEof;                   /* True when at EOF */
-  u8 bNoop;                  /* If next xNext() call is no-op */
+  int bEof;                  /* True when at EOF */
 
   /* Used outside of write transactions */
   FILE *pFile;               /* Zip file */
   i64 iNextOff;              /* Offset of next record in central directory */
   ZipfileEOCD eocd;          /* Parse of central directory record */
 
-  ZipfileEntry *pFreeEntry;  /* Free this list when cursor is closed or reset */
-  ZipfileEntry *pCurrent;    /* Current entry */
+  /* Used inside write transactions */
+  ZipfileEntry *pCurrent;
+
+  ZipfileCDS cds;            /* Central Directory Structure */
+  ZipfileLFH lfh;            /* Local File Header for current entry */
+  i64 iDataOff;              /* Offset in zipfile to data */
+  u32 mTime;                 /* Extended mtime value */
+  int flags;                 /* Flags byte (see below for bits) */
   ZipfileCsr *pCsrNext;      /* Next cursor on same virtual table */
 };
 
+/*
+** Values for ZipfileCsr.flags.
+*/
+#define ZIPFILE_MTIME_VALID 0x0001
+
 typedef struct ZipfileTab ZipfileTab;
 struct ZipfileTab {
   sqlite3_vtab base;         /* Base class - must be first */
   char *zFile;               /* Zip file this table accesses (may be NULL) */
-  sqlite3 *db;               /* Host database connection */
   u8 *aBuffer;               /* Temporary buffer used for various tasks */
 
   ZipfileCsr *pCsrList;      /* List of cursors */
@@ -4354,33 +4246,17 @@
   i64 szOrig;                /* Size of archive at start of transaction */
 };
 
-/*
-** Set the error message contained in context ctx to the results of
-** vprintf(zFmt, ...).
-*/
-static void zipfileCtxErrorMsg(sqlite3_context *ctx, const char *zFmt, ...){
-  char *zMsg = 0;
-  va_list ap;
-  va_start(ap, zFmt);
-  zMsg = sqlite3_vmprintf(zFmt, ap);
-  sqlite3_result_error(ctx, zMsg, -1);
-  sqlite3_free(zMsg);
-  va_end(ap);
-}
-
-/*
-** If string zIn is quoted, dequote it in place. Otherwise, if the string
-** is not quoted, do nothing.
-*/
 static void zipfileDequote(char *zIn){
   char q = zIn[0];
   if( q=='"' || q=='\'' || q=='`' || q=='[' ){
+    char c;
     int iIn = 1;
     int iOut = 0;
     if( q=='[' ) q = ']';
-    while( ALWAYS(zIn[iIn]) ){
-      char c = zIn[iIn++];
-      if( c==q && zIn[iIn++]!=q ) break;
+    while( (c = zIn[iIn++]) ){
+      if( c==q ){
+        if( zIn[iIn++]!=q ) break;
+      }
       zIn[iOut++] = c;
     }
     zIn[iOut] = '\0';
@@ -4408,21 +4284,6 @@
   ZipfileTab *pNew = 0;
   int rc;
 
-  /* If the table name is not "zipfile", require that the argument be
-  ** specified. This stops zipfile tables from being created as:
-  **
-  **   CREATE VIRTUAL TABLE zzz USING zipfile();
-  **
-  ** It does not prevent:
-  **
-  **   CREATE VIRTUAL TABLE zipfile USING zipfile();
-  */
-  assert( 0==sqlite3_stricmp(argv[0], "zipfile") );
-  if( (0!=sqlite3_stricmp(argv[2], "zipfile") && argc<4) || argc>4 ){
-    *pzErr = sqlite3_mprintf("zipfile constructor requires one argument");
-    return SQLITE_ERROR;
-  }
-
   if( argc>3 ){
     zFile = argv[3];
     nFile = (int)strlen(zFile)+1;
@@ -4433,7 +4294,6 @@
     pNew = (ZipfileTab*)sqlite3_malloc(nByte+nFile);
     if( pNew==0 ) return SQLITE_NOMEM;
     memset(pNew, 0, nByte+nFile);
-    pNew->db = db;
     pNew->aBuffer = (u8*)&pNew[1];
     if( zFile ){
       pNew->zFile = (char*)&pNew->aBuffer[ZIPFILE_BUFFER_SIZE];
@@ -4446,42 +4306,9 @@
 }
 
 /*
-** Free the ZipfileEntry structure indicated by the only argument.
-*/
-static void zipfileEntryFree(ZipfileEntry *p){
-  if( p ){
-    sqlite3_free(p->cds.zFile);
-    sqlite3_free(p);
-  }
-}
-
-/*
-** Release resources that should be freed at the end of a write 
-** transaction.
-*/
-static void zipfileCleanupTransaction(ZipfileTab *pTab){
-  ZipfileEntry *pEntry;
-  ZipfileEntry *pNext;
-
-  if( pTab->pWriteFd ){
-    fclose(pTab->pWriteFd);
-    pTab->pWriteFd = 0;
-  }
-  for(pEntry=pTab->pFirstEntry; pEntry; pEntry=pNext){
-    pNext = pEntry->pNext;
-    zipfileEntryFree(pEntry);
-  }
-  pTab->pFirstEntry = 0;
-  pTab->pLastEntry = 0;
-  pTab->szCurrent = 0;
-  pTab->szOrig = 0;
-}
-
-/*
 ** This method is the destructor for zipfile vtab objects.
 */
 static int zipfileDisconnect(sqlite3_vtab *pVtab){
-  zipfileCleanupTransaction((ZipfileTab*)pVtab);
   sqlite3_free(pVtab);
   return SQLITE_OK;
 }
@@ -4509,20 +4336,12 @@
 ** by zipfileOpen().
 */
 static void zipfileResetCursor(ZipfileCsr *pCsr){
-  ZipfileEntry *p;
-  ZipfileEntry *pNext;
-
+  sqlite3_free(pCsr->cds.zFile);
+  pCsr->cds.zFile = 0;
   pCsr->bEof = 0;
   if( pCsr->pFile ){
     fclose(pCsr->pFile);
     pCsr->pFile = 0;
-    zipfileEntryFree(pCsr->pCurrent);
-    pCsr->pCurrent = 0;
-  }
-
-  for(p=pCsr->pFreeEntry; p; p=pNext){
-    pNext = p->pNext;
-    zipfileEntryFree(p);
   }
 }
 
@@ -4536,8 +4355,12 @@
   zipfileResetCursor(pCsr);
 
   /* Remove this cursor from the ZipfileTab.pCsrList list. */
-  for(pp=&pTab->pCsrList; *pp!=pCsr; pp=&((*pp)->pCsrNext));
-  *pp = pCsr->pCsrNext;
+  for(pp=&pTab->pCsrList; *pp; pp=&((*pp)->pCsrNext)){
+    if( *pp==pCsr ){ 
+      *pp = pCsr->pCsrNext;
+      break;
+    }
+  }
 
   sqlite3_free(pCsr);
   return SQLITE_OK;
@@ -4547,31 +4370,13 @@
 ** Set the error message for the virtual table associated with cursor
 ** pCsr to the results of vprintf(zFmt, ...).
 */
-static void zipfileTableErr(ZipfileTab *pTab, const char *zFmt, ...){
-  va_list ap;
-  va_start(ap, zFmt);
-  sqlite3_free(pTab->base.zErrMsg);
-  pTab->base.zErrMsg = sqlite3_vmprintf(zFmt, ap);
-  va_end(ap);
-}
-static void zipfileCursorErr(ZipfileCsr *pCsr, const char *zFmt, ...){
+static void zipfileSetErrmsg(ZipfileCsr *pCsr, const char *zFmt, ...){
   va_list ap;
   va_start(ap, zFmt);
-  sqlite3_free(pCsr->base.pVtab->zErrMsg);
   pCsr->base.pVtab->zErrMsg = sqlite3_vmprintf(zFmt, ap);
   va_end(ap);
 }
 
-/*
-** Read nRead bytes of data from offset iOff of file pFile into buffer
-** aRead[]. Return SQLITE_OK if successful, or an SQLite error code
-** otherwise. 
-**
-** If an error does occur, output variable (*pzErrmsg) may be set to point
-** to an English language error message. It is the responsibility of the
-** caller to eventually free this buffer using
-** sqlite3_free().
-*/
 static int zipfileReadData(
   FILE *pFile,                    /* Read from this file */
   u8 *aRead,                      /* Read into this buffer */
@@ -4605,16 +4410,9 @@
   return SQLITE_OK;
 }
 
-/*
-** Read and return a 16-bit little-endian unsigned integer from buffer aBuf.
-*/
 static u16 zipfileGetU16(const u8 *aBuf){
   return (aBuf[1] << 8) + aBuf[0];
 }
-
-/*
-** Read and return a 32-bit little-endian unsigned integer from buffer aBuf.
-*/
 static u32 zipfileGetU32(const u8 *aBuf){
   return ((u32)(aBuf[3]) << 24)
        + ((u32)(aBuf[2]) << 16)
@@ -4622,17 +4420,10 @@
        + ((u32)(aBuf[0]) <<  0);
 }
 
-/*
-** Write a 16-bit little endiate integer into buffer aBuf.
-*/
 static void zipfilePutU16(u8 *aBuf, u16 val){
   aBuf[0] = val & 0xFF;
   aBuf[1] = (val>>8) & 0xFF;
 }
-
-/*
-** Write a 32-bit little endiate integer into buffer aBuf.
-*/
 static void zipfilePutU32(u8 *aBuf, u32 val){
   aBuf[0] = val & 0xFF;
   aBuf[1] = (val>>8) & 0xFF;
@@ -4646,11 +4437,15 @@
 #define zipfileWrite32(aBuf,val) { zipfilePutU32(aBuf,val); aBuf+=4; }
 #define zipfileWrite16(aBuf,val) { zipfilePutU16(aBuf,val); aBuf+=2; }
 
+static u8* zipfileCsrBuffer(ZipfileCsr *pCsr){
+  return ((ZipfileTab*)(pCsr->base.pVtab))->aBuffer;
+}
+
 /*
 ** Magic numbers used to read CDS records.
 */
+#define ZIPFILE_CDS_FIXED_SZ         46
 #define ZIPFILE_CDS_NFILE_OFF        28
-#define ZIPFILE_CDS_SZCOMPRESSED_OFF 20
 
 /*
 ** Decode the CDS record in buffer aBuf into (*pCDS). Return SQLITE_ERROR
@@ -4687,321 +4482,216 @@
 }
 
 /*
-** Decode the LFH record in buffer aBuf into (*pLFH). Return SQLITE_ERROR
-** if the record is not well-formed, or SQLITE_OK otherwise.
+** Read the CDS record for the current entry from disk into pCsr->cds.
 */
-static int zipfileReadLFH(
-  u8 *aBuffer,
-  ZipfileLFH *pLFH
-){
-  u8 *aRead = aBuffer;
+static int zipfileCsrReadCDS(ZipfileCsr *pCsr){
+  char **pzErr = &pCsr->base.pVtab->zErrMsg;
+  u8 *aRead;
   int rc = SQLITE_OK;
 
-  u32 sig = zipfileRead32(aRead);
-  if( sig!=ZIPFILE_SIGNATURE_LFH ){
-    rc = SQLITE_ERROR;
+  sqlite3_free(pCsr->cds.zFile);
+  pCsr->cds.zFile = 0;
+
+  if( pCsr->pCurrent==0 ){
+    aRead = zipfileCsrBuffer(pCsr);
+    rc = zipfileReadData(
+        pCsr->pFile, aRead, ZIPFILE_CDS_FIXED_SZ, pCsr->iNextOff, pzErr
+    );
   }else{
-    pLFH->iVersionExtract = zipfileRead16(aRead);
-    pLFH->flags = zipfileRead16(aRead);
-    pLFH->iCompression = zipfileRead16(aRead);
-    pLFH->mTime = zipfileRead16(aRead);
-    pLFH->mDate = zipfileRead16(aRead);
-    pLFH->crc32 = zipfileRead32(aRead);
-    pLFH->szCompressed = zipfileRead32(aRead);
-    pLFH->szUncompressed = zipfileRead32(aRead);
-    pLFH->nFile = zipfileRead16(aRead);
-    pLFH->nExtra = zipfileRead16(aRead);
+    aRead = pCsr->pCurrent->aCdsEntry;
   }
-  return rc;
-}
 
-
-/*
-** Buffer aExtra (size nExtra bytes) contains zip archive "extra" fields.
-** Scan through this buffer to find an "extra-timestamp" field. If one
-** exists, extract the 32-bit modification-timestamp from it and store
-** the value in output parameter *pmTime.
-**
-** Zero is returned if no extra-timestamp record could be found (and so
-** *pmTime is left unchanged), or non-zero otherwise.
-**
-** The general format of an extra field is:
-**
-**   Header ID    2 bytes
-**   Data Size    2 bytes
-**   Data         N bytes
-*/
-static int zipfileScanExtra(u8 *aExtra, int nExtra, u32 *pmTime){
-  int ret = 0;
-  u8 *p = aExtra;
-  u8 *pEnd = &aExtra[nExtra];
-
-  while( p<pEnd ){
-    u16 id = zipfileRead16(p);
-    u16 nByte = zipfileRead16(p);
-
-    switch( id ){
-      case ZIPFILE_EXTRA_TIMESTAMP: {
-        u8 b = p[0];
-        if( b & 0x01 ){     /* 0x01 -> modtime is present */
-          *pmTime = zipfileGetU32(&p[1]);
-          ret = 1;
-        }
-        break;
+  if( rc==SQLITE_OK ){
+    rc = zipfileReadCDS(aRead, &pCsr->cds);
+    if( rc!=SQLITE_OK ){
+      assert( pCsr->pCurrent==0 );
+      zipfileSetErrmsg(pCsr,"failed to read CDS at offset %lld",pCsr->iNextOff);
+    }else{
+      int nRead;
+      if( pCsr->pCurrent==0 ){
+        nRead = pCsr->cds.nFile + pCsr->cds.nExtra;
+        aRead = zipfileCsrBuffer(pCsr);
+        pCsr->iNextOff += ZIPFILE_CDS_FIXED_SZ;
+        rc = zipfileReadData(pCsr->pFile, aRead, nRead, pCsr->iNextOff, pzErr);
+      }else{
+        aRead = &aRead[ZIPFILE_CDS_FIXED_SZ];
       }
-    }
 
-    p += nByte;
-  }
-  return ret;
-}
+      if( rc==SQLITE_OK ){
+        pCsr->cds.zFile = sqlite3_mprintf("%.*s", (int)pCsr->cds.nFile, aRead);
+        pCsr->iNextOff += pCsr->cds.nFile;
+        pCsr->iNextOff += pCsr->cds.nExtra;
+        pCsr->iNextOff += pCsr->cds.nComment;
+      }
 
-/*
-** Convert the standard MS-DOS timestamp stored in the mTime and mDate
-** fields of the CDS structure passed as the only argument to a 32-bit
-** UNIX seconds-since-the-epoch timestamp. Return the result.
-**
-** "Standard" MS-DOS time format:
-**
-**   File modification time:
-**     Bits 00-04: seconds divided by 2
-**     Bits 05-10: minute
-**     Bits 11-15: hour
-**   File modification date:
-**     Bits 00-04: day
-**     Bits 05-08: month (1-12)
-**     Bits 09-15: years from 1980 
-**
-** https://msdn.microsoft.com/en-us/library/9kkf9tah.aspx
-*/
-static u32 zipfileMtime(ZipfileCDS *pCDS){
-  int Y = (1980 + ((pCDS->mDate >> 9) & 0x7F));
-  int M = ((pCDS->mDate >> 5) & 0x0F);
-  int D = (pCDS->mDate & 0x1F);
-  int B = -13;
+      /* Scan the cds.nExtra bytes of "extra" fields for any that can
+      ** be interpreted. The general format of an extra field is:
+      **
+      **   Header ID    2 bytes
+      **   Data Size    2 bytes
+      **   Data         N bytes
+      **
+      */
+      if( rc==SQLITE_OK ){
+        u8 *p = &aRead[pCsr->cds.nFile];
+        u8 *pEnd = &p[pCsr->cds.nExtra];
 
-  int sec = (pCDS->mTime & 0x1F)*2;
-  int min = (pCDS->mTime >> 5) & 0x3F;
-  int hr = (pCDS->mTime >> 11) & 0x1F;
-  i64 JD;
+        while( p<pEnd ){
+          u16 id = zipfileRead16(p);
+          u16 nByte = zipfileRead16(p);
 
-  /* JD = INT(365.25 * (Y+4716)) + INT(30.6001 * (M+1)) + D + B - 1524.5 */
+          switch( id ){
+            case ZIPFILE_EXTRA_TIMESTAMP: {
+              u8 b = p[0];
+              if( b & 0x01 ){     /* 0x01 -> modtime is present */
+                pCsr->mTime = zipfileGetU32(&p[1]);
+                pCsr->flags |= ZIPFILE_MTIME_VALID;
+              }
+              break;
+            }
+          }
 
-  /* Calculate the JD in seconds for noon on the day in question */
-  if( M<3 ){
-    Y = Y-1;
-    M = M+12;
+          p += nByte;
+        }
+      }
+    }
   }
-  JD = (i64)(24*60*60) * (
-      (int)(365.25 * (Y + 4716))
-    + (int)(30.6001 * (M + 1))
-    + D + B - 1524
-  );
 
-  /* Correct the JD for the time within the day */
-  JD += (hr-12) * 3600 + min * 60 + sec;
-
-  /* Convert JD to unix timestamp (the JD epoch is 2440587.5) */
-  return (u32)(JD - (i64)(24405875) * 24*60*6);
+  return rc;
 }
 
-/*
-** The opposite of zipfileMtime(). This function populates the mTime and
-** mDate fields of the CDS structure passed as the first argument according
-** to the UNIX timestamp value passed as the second.
-*/
-static void zipfileMtimeToDos(ZipfileCDS *pCds, u32 mUnixTime){
-  /* Convert unix timestamp to JD (2440588 is noon on 1/1/1970) */
-  i64 JD = (i64)2440588 + mUnixTime / (24*60*60);
-
-  int A, B, C, D, E;
-  int yr, mon, day;
-  int hr, min, sec;
-
-  A = (int)((JD - 1867216.25)/36524.25);
-  A = (int)(JD + 1 + A - (A/4));
-  B = A + 1524;
-  C = (int)((B - 122.1)/365.25);
-  D = (36525*(C&32767))/100;
-  E = (int)((B-D)/30.6001);
-
-  day = B - D - (int)(30.6001*E);
-  mon = (E<14 ? E-1 : E-13);
-  yr = mon>2 ? C-4716 : C-4715;
-
-  hr = (mUnixTime % (24*60*60)) / (60*60);
-  min = (mUnixTime % (60*60)) / 60;
-  sec = (mUnixTime % 60);
-
-  if( yr>=1980 ){
-    pCds->mDate = (u16)(day + (mon << 5) + ((yr-1980) << 9));
-    pCds->mTime = (u16)(sec/2 + (min<<5) + (hr<<11));
-  }else{
-    pCds->mDate = pCds->mTime = 0;
-  }
-
-  assert( mUnixTime<315507600 
-       || mUnixTime==zipfileMtime(pCds) 
-       || ((mUnixTime % 2) && mUnixTime-1==zipfileMtime(pCds)) 
-       /* || (mUnixTime % 2) */
-  );
+static FILE *zipfileGetFd(ZipfileCsr *pCsr){
+  if( pCsr->pFile ) return pCsr->pFile;
+  return ((ZipfileTab*)(pCsr->base.pVtab))->pWriteFd;
 }
 
-/*
-** If aBlob is not NULL, then it is a pointer to a buffer (nBlob bytes in
-** size) containing an entire zip archive image. Or, if aBlob is NULL,
-** then pFile is a file-handle open on a zip file. In either case, this
-** function creates a ZipfileEntry object based on the zip archive entry
-** for which the CDS record is at offset iOff.
-**
-** If successful, SQLITE_OK is returned and (*ppEntry) set to point to
-** the new object. Otherwise, an SQLite error code is returned and the
-** final value of (*ppEntry) undefined.
-*/
-static int zipfileGetEntry(
-  ZipfileTab *pTab,               /* Store any error message here */
-  const u8 *aBlob,                /* Pointer to in-memory file image */
-  int nBlob,                      /* Size of aBlob[] in bytes */
-  FILE *pFile,                    /* If aBlob==0, read from this file */
-  i64 iOff,                       /* Offset of CDS record */
-  ZipfileEntry **ppEntry          /* OUT: Pointer to new object */
+static int zipfileReadLFH(
+  FILE *pFd, 
+  i64 iOffset,
+  u8 *aTmp, 
+  ZipfileLFH *pLFH, 
+  char **pzErr
 ){
-  u8 *aRead;
-  char **pzErr = &pTab->base.zErrMsg;
-  int rc = SQLITE_OK;
-
-  if( aBlob==0 ){
-    aRead = pTab->aBuffer;
-    rc = zipfileReadData(pFile, aRead, ZIPFILE_CDS_FIXED_SZ, iOff, pzErr);
-  }else{
-    aRead = (u8*)&aBlob[iOff];
-  }
+  u8 *aRead = aTmp;
+  static const int szFix = ZIPFILE_LFH_FIXED_SZ;
+  int rc;
 
+  rc = zipfileReadData(pFd, aRead, szFix, iOffset, pzErr);
   if( rc==SQLITE_OK ){
-    int nAlloc;
-    ZipfileEntry *pNew;
-
-    int nFile = zipfileGetU16(&aRead[ZIPFILE_CDS_NFILE_OFF]);
-    int nExtra = zipfileGetU16(&aRead[ZIPFILE_CDS_NFILE_OFF+2]);
-    nExtra += zipfileGetU16(&aRead[ZIPFILE_CDS_NFILE_OFF+4]);
-
-    nAlloc = sizeof(ZipfileEntry) + nExtra;
-    if( aBlob ){
-      nAlloc += zipfileGetU32(&aRead[ZIPFILE_CDS_SZCOMPRESSED_OFF]);
-    }
-
-    pNew = (ZipfileEntry*)sqlite3_malloc(nAlloc);
-    if( pNew==0 ){
-      rc = SQLITE_NOMEM;
-    }else{
-      memset(pNew, 0, sizeof(ZipfileEntry));
-      rc = zipfileReadCDS(aRead, &pNew->cds);
-      if( rc!=SQLITE_OK ){
-        *pzErr = sqlite3_mprintf("failed to read CDS at offset %lld", iOff);
-      }else if( aBlob==0 ){
-        rc = zipfileReadData(
-            pFile, aRead, nExtra+nFile, iOff+ZIPFILE_CDS_FIXED_SZ, pzErr
-        );
-      }else{
-        aRead = (u8*)&aBlob[iOff + ZIPFILE_CDS_FIXED_SZ];
-      }
-    }
-
-    if( rc==SQLITE_OK ){
-      u32 *pt = &pNew->mUnixTime;
-      pNew->cds.zFile = sqlite3_mprintf("%.*s", nFile, aRead); 
-      pNew->aExtra = (u8*)&pNew[1];
-      memcpy(pNew->aExtra, &aRead[nFile], nExtra);
-      if( pNew->cds.zFile==0 ){
-        rc = SQLITE_NOMEM;
-      }else if( 0==zipfileScanExtra(&aRead[nFile], pNew->cds.nExtra, pt) ){
-        pNew->mUnixTime = zipfileMtime(&pNew->cds);
-      }
-    }
-
-    if( rc==SQLITE_OK ){
-      static const int szFix = ZIPFILE_LFH_FIXED_SZ;
-      ZipfileLFH lfh;
-      if( pFile ){
-        rc = zipfileReadData(pFile, aRead, szFix, pNew->cds.iOffset, pzErr);
-      }else{
-        aRead = (u8*)&aBlob[pNew->cds.iOffset];
-      }
-
-      rc = zipfileReadLFH(aRead, &lfh);
-      if( rc==SQLITE_OK ){
-        pNew->iDataOff =  pNew->cds.iOffset + ZIPFILE_LFH_FIXED_SZ;
-        pNew->iDataOff += lfh.nFile + lfh.nExtra;
-        if( aBlob && pNew->cds.szCompressed ){
-          pNew->aData = &pNew->aExtra[nExtra];
-          memcpy(pNew->aData, &aBlob[pNew->iDataOff], pNew->cds.szCompressed);
-        }
-      }else{
-        *pzErr = sqlite3_mprintf("failed to read LFH at offset %d", 
-            (int)pNew->cds.iOffset
-        );
-      }
-    }
-
-    if( rc!=SQLITE_OK ){
-      zipfileEntryFree(pNew);
+    u32 sig = zipfileRead32(aRead);
+    if( sig!=ZIPFILE_SIGNATURE_LFH ){
+      *pzErr = sqlite3_mprintf("failed to read LFH at offset %d", (int)iOffset);
+      rc = SQLITE_ERROR;
     }else{
-      *ppEntry = pNew;
+      pLFH->iVersionExtract = zipfileRead16(aRead);
+      pLFH->flags = zipfileRead16(aRead);
+      pLFH->iCompression = zipfileRead16(aRead);
+      pLFH->mTime = zipfileRead16(aRead);
+      pLFH->mDate = zipfileRead16(aRead);
+      pLFH->crc32 = zipfileRead32(aRead);
+      pLFH->szCompressed = zipfileRead32(aRead);
+      pLFH->szUncompressed = zipfileRead32(aRead);
+      pLFH->nFile = zipfileRead16(aRead);
+      pLFH->nExtra = zipfileRead16(aRead);
+      assert( aRead==&aTmp[szFix] );
     }
   }
+  return rc;
+}
 
+static int zipfileCsrReadLFH(ZipfileCsr *pCsr){
+  FILE *pFile = zipfileGetFd(pCsr);
+  char **pzErr = &pCsr->base.pVtab->zErrMsg;
+  u8 *aRead = zipfileCsrBuffer(pCsr);
+  int rc = zipfileReadLFH(pFile, pCsr->cds.iOffset, aRead, &pCsr->lfh, pzErr);
+  pCsr->iDataOff =  pCsr->cds.iOffset + ZIPFILE_LFH_FIXED_SZ;
+  pCsr->iDataOff += pCsr->lfh.nFile+pCsr->lfh.nExtra;
   return rc;
 }
 
+
 /*
 ** Advance an ZipfileCsr to its next row of output.
 */
 static int zipfileNext(sqlite3_vtab_cursor *cur){
   ZipfileCsr *pCsr = (ZipfileCsr*)cur;
   int rc = SQLITE_OK;
+  pCsr->flags = 0;
 
-  if( pCsr->pFile ){
+  if( pCsr->pCurrent==0 ){
     i64 iEof = pCsr->eocd.iOffset + pCsr->eocd.nSize;
-    zipfileEntryFree(pCsr->pCurrent);
-    pCsr->pCurrent = 0;
     if( pCsr->iNextOff>=iEof ){
       pCsr->bEof = 1;
-    }else{
-      ZipfileEntry *p = 0;
-      ZipfileTab *pTab = (ZipfileTab*)(cur->pVtab);
-      rc = zipfileGetEntry(pTab, 0, 0, pCsr->pFile, pCsr->iNextOff, &p);
-      if( rc==SQLITE_OK ){
-        pCsr->iNextOff += ZIPFILE_CDS_FIXED_SZ;
-        pCsr->iNextOff += (int)p->cds.nExtra + p->cds.nFile + p->cds.nComment;
-      }
-      pCsr->pCurrent = p;
     }
   }else{
-    if( !pCsr->bNoop ){
+    assert( pCsr->pFile==0 );
+    do {
       pCsr->pCurrent = pCsr->pCurrent->pNext;
-    }
+    }while( pCsr->pCurrent && pCsr->pCurrent->bDeleted );
     if( pCsr->pCurrent==0 ){
       pCsr->bEof = 1;
     }
   }
 
-  pCsr->bNoop = 0;
-  return rc;
-}
+  if( pCsr->bEof==0 ){
+    rc = zipfileCsrReadCDS(pCsr);
+    if( rc==SQLITE_OK ){
+      rc = zipfileCsrReadLFH(pCsr);
+    }
+  }
 
-static void zipfileFree(void *p) { 
-  sqlite3_free(p); 
+  return rc;
 }
 
 /*
-** Buffer aIn (size nIn bytes) contains compressed data. Uncompressed, the
-** size is nOut bytes. This function uncompresses the data and sets the
-** return value in context pCtx to the result (a blob).
+** "Standard" MS-DOS time format:
 **
-** If an error occurs, an error code is left in pCtx instead.
+**   File modification time:
+**     Bits 00-04: seconds divided by 2
+**     Bits 05-10: minute
+**     Bits 11-15: hour
+**   File modification date:
+**     Bits 00-04: day
+**     Bits 05-08: month (1-12)
+**     Bits 09-15: years from 1980 
 */
+static time_t zipfileMtime(ZipfileCsr *pCsr){
+  struct tm t;
+  memset(&t, 0, sizeof(t));
+  t.tm_sec = (pCsr->cds.mTime & 0x1F)*2;
+  t.tm_min = (pCsr->cds.mTime >> 5) & 0x2F;
+  t.tm_hour = (pCsr->cds.mTime >> 11) & 0x1F;
+
+  t.tm_mday = (pCsr->cds.mDate & 0x1F);
+  t.tm_mon = ((pCsr->cds.mDate >> 5) & 0x0F) - 1;
+  t.tm_year = 80 + ((pCsr->cds.mDate >> 9) & 0x7F);
+
+  return mktime(&t);
+}
+
+static void zipfileMtimeToDos(ZipfileCDS *pCds, u32 mTime){
+  time_t t = (time_t)mTime;
+  struct tm res;
+
+#if !defined(_WIN32) && !defined(WIN32)
+  localtime_r(&t, &res);
+#else
+  memcpy(&res, localtime(&t), sizeof(struct tm));
+#endif
+
+  pCds->mTime = (u16)(
+    (res.tm_sec / 2) + 
+    (res.tm_min << 5) +
+    (res.tm_hour << 11));
+
+  pCds->mDate = (u16)(
+    (res.tm_mday-1) +
+    ((res.tm_mon+1) << 5) +
+    ((res.tm_year-80) << 9));
+}
+
 static void zipfileInflate(
-  sqlite3_context *pCtx,          /* Store result here */
+  sqlite3_context *pCtx,          /* Store error here, if any */
   const u8 *aIn,                  /* Compressed data */
   int nIn,                        /* Size of buffer aIn[] in bytes */
   int nOut                        /* Expected output size */
@@ -5027,8 +4717,7 @@
       if( err!=Z_STREAM_END ){
         zipfileCtxErrorMsg(pCtx, "inflate() failed (%d)", err);
       }else{
-        sqlite3_result_blob(pCtx, aRes, nOut, zipfileFree);
-        aRes = 0;
+        sqlite3_result_blob(pCtx, aRes, nOut, SQLITE_TRANSIENT);
       }
     }
     sqlite3_free(aRes);
@@ -5036,22 +4725,10 @@
   }
 }
 
-/*
-** Buffer aIn (size nIn bytes) contains uncompressed data. This function
-** compresses it and sets (*ppOut) to point to a buffer containing the
-** compressed data. The caller is responsible for eventually calling
-** sqlite3_free() to release buffer (*ppOut). Before returning, (*pnOut) 
-** is set to the size of buffer (*ppOut) in bytes.
-**
-** If no error occurs, SQLITE_OK is returned. Otherwise, an SQLite error
-** code is returned and an error message left in virtual-table handle
-** pTab. The values of (*ppOut) and (*pnOut) are left unchanged in this
-** case.
-*/
 static int zipfileDeflate(
+  ZipfileTab *pTab,               /* Set error message here */
   const u8 *aIn, int nIn,         /* Input */
-  u8 **ppOut, int *pnOut,         /* Output */
-  char **pzErr                    /* OUT: Error message */
+  u8 **ppOut, int *pnOut          /* Output */
 ){
   int nAlloc = (int)compressBound(nIn);
   u8 *aOut;
@@ -5077,7 +4754,7 @@
       *pnOut = (int)str.total_out;
     }else{
       sqlite3_free(aOut);
-      *pzErr = sqlite3_mprintf("zipfile: deflate() error");
+      pTab->base.zErrMsg = sqlite3_mprintf("zipfile: deflate() error");
       rc = SQLITE_ERROR;
     }
     deflateEnd(&str);
@@ -5097,66 +4774,60 @@
   int i                       /* Which column to return */
 ){
   ZipfileCsr *pCsr = (ZipfileCsr*)cur;
-  ZipfileCDS *pCDS = &pCsr->pCurrent->cds;
   int rc = SQLITE_OK;
   switch( i ){
     case 0:   /* name */
-      sqlite3_result_text(ctx, pCDS->zFile, -1, SQLITE_TRANSIENT);
+      sqlite3_result_text(ctx, pCsr->cds.zFile, -1, SQLITE_TRANSIENT);
       break;
     case 1:   /* mode */
       /* TODO: Whether or not the following is correct surely depends on
       ** the platform on which the archive was created.  */
-      sqlite3_result_int(ctx, pCDS->iExternalAttr >> 16);
+      sqlite3_result_int(ctx, pCsr->cds.iExternalAttr >> 16);
       break;
     case 2: { /* mtime */
-      sqlite3_result_int64(ctx, pCsr->pCurrent->mUnixTime);
+      if( pCsr->flags & ZIPFILE_MTIME_VALID ){
+        sqlite3_result_int64(ctx, pCsr->mTime);
+      }else{
+        sqlite3_result_int64(ctx, zipfileMtime(pCsr));
+      }
       break;
     }
     case 3: { /* sz */
       if( sqlite3_vtab_nochange(ctx)==0 ){
-        sqlite3_result_int64(ctx, pCDS->szUncompressed);
+        sqlite3_result_int64(ctx, pCsr->cds.szUncompressed);
       }
       break;
     }
     case 4:   /* rawdata */
       if( sqlite3_vtab_nochange(ctx) ) break;
     case 5: { /* data */
-      if( i==4 || pCDS->iCompression==0 || pCDS->iCompression==8 ){
-        int sz = pCDS->szCompressed;
-        int szFinal = pCDS->szUncompressed;
+      if( i==4 || pCsr->cds.iCompression==0 || pCsr->cds.iCompression==8 ){
+        int sz = pCsr->cds.szCompressed;
+        int szFinal = pCsr->cds.szUncompressed;
         if( szFinal>0 ){
-          u8 *aBuf;
-          u8 *aFree = 0;
-          if( pCsr->pCurrent->aData ){
-            aBuf = pCsr->pCurrent->aData;
+          u8 *aBuf = sqlite3_malloc(sz);
+          if( aBuf==0 ){
+            rc = SQLITE_NOMEM;
           }else{
-            aBuf = aFree = sqlite3_malloc(sz);
-            if( aBuf==0 ){
-              rc = SQLITE_NOMEM;
-            }else{
-              FILE *pFile = pCsr->pFile;
-              if( pFile==0 ){
-                pFile = ((ZipfileTab*)(pCsr->base.pVtab))->pWriteFd;
-              }
-              rc = zipfileReadData(pFile, aBuf, sz, pCsr->pCurrent->iDataOff,
-                  &pCsr->base.pVtab->zErrMsg
-              );
-            }
+            FILE *pFile = zipfileGetFd(pCsr);
+            rc = zipfileReadData(pFile, aBuf, sz, pCsr->iDataOff,
+                &pCsr->base.pVtab->zErrMsg
+            );
           }
           if( rc==SQLITE_OK ){
-            if( i==5 && pCDS->iCompression ){
+            if( i==5 && pCsr->cds.iCompression ){
               zipfileInflate(ctx, aBuf, sz, szFinal);
             }else{
               sqlite3_result_blob(ctx, aBuf, sz, SQLITE_TRANSIENT);
             }
+            sqlite3_free(aBuf);
           }
-          sqlite3_free(aFree);
         }else{
           /* Figure out if this is a directory or a zero-sized file. Consider
           ** it to be a directory either if the mode suggests so, or if
           ** the final character in the name is '/'.  */
-          u32 mode = pCDS->iExternalAttr >> 16;
-          if( !(mode & S_IFDIR) && pCDS->zFile[pCDS->nFile-1]!='/' ){
+          u32 mode = pCsr->cds.iExternalAttr >> 16;
+          if( !(mode & S_IFDIR) && pCsr->cds.zFile[pCsr->cds.nFile-1]!='/' ){
             sqlite3_result_blob(ctx, "", 0, SQLITE_STATIC);
           }
         }
@@ -5164,10 +4835,9 @@
       break;
     }
     case 6:   /* method */
-      sqlite3_result_int(ctx, pCDS->iCompression);
+      sqlite3_result_int(ctx, pCsr->cds.iCompression);
       break;
-    default:  /* z */
-      assert( i==7 );
+    case 7:   /* z */
       sqlite3_result_int64(ctx, pCsr->iId);
       break;
   }
@@ -5176,7 +4846,16 @@
 }
 
 /*
-** Return TRUE if the cursor is at EOF.
+** Return the rowid for the current row.
+*/
+static int zipfileRowid(sqlite3_vtab_cursor *cur, sqlite_int64 *pRowid){
+  assert( 0 );
+  return SQLITE_OK;
+}
+
+/*
+** Return TRUE if the cursor has been moved off of the last
+** row of output.
 */
 static int zipfileEof(sqlite3_vtab_cursor *cur){
   ZipfileCsr *pCsr = (ZipfileCsr*)cur;
@@ -5184,43 +4863,28 @@
 }
 
 /*
-** If aBlob is not NULL, then it points to a buffer nBlob bytes in size
-** containing an entire zip archive image. Or, if aBlob is NULL, then pFile
-** is guaranteed to be a file-handle open on a zip file.
-**
-** This function attempts to locate the EOCD record within the zip archive
-** and populate *pEOCD with the results of decoding it. SQLITE_OK is
-** returned if successful. Otherwise, an SQLite error code is returned and
-** an English language error message may be left in virtual-table pTab.
 */
 static int zipfileReadEOCD(
   ZipfileTab *pTab,               /* Return errors here */
-  const u8 *aBlob,                /* Pointer to in-memory file image */
-  int nBlob,                      /* Size of aBlob[] in bytes */
-  FILE *pFile,                    /* Read from this file if aBlob==0 */
+  FILE *pFile,                    /* Read from this file */
   ZipfileEOCD *pEOCD              /* Object to populate */
 ){
   u8 *aRead = pTab->aBuffer;      /* Temporary buffer */
+  i64 szFile;                     /* Total size of file in bytes */
   int nRead;                      /* Bytes to read from file */
-  int rc = SQLITE_OK;
+  i64 iOff;                       /* Offset to read from */
+  int rc;
 
-  if( aBlob==0 ){
-    i64 iOff;                     /* Offset to read from */
-    i64 szFile;                   /* Total size of file in bytes */
-    fseek(pFile, 0, SEEK_END);
-    szFile = (i64)ftell(pFile);
-    if( szFile==0 ){
-      memset(pEOCD, 0, sizeof(ZipfileEOCD));
-      return SQLITE_OK;
-    }
-    nRead = (int)(MIN(szFile, ZIPFILE_BUFFER_SIZE));
-    iOff = szFile - nRead;
-    rc = zipfileReadData(pFile, aRead, nRead, iOff, &pTab->base.zErrMsg);
-  }else{
-    nRead = (int)(MIN(nBlob, ZIPFILE_BUFFER_SIZE));
-    aRead = (u8*)&aBlob[nBlob-nRead];
+  fseek(pFile, 0, SEEK_END);
+  szFile = (i64)ftell(pFile);
+  if( szFile==0 ){
+    memset(pEOCD, 0, sizeof(ZipfileEOCD));
+    return SQLITE_OK;
   }
+  nRead = (int)(MIN(szFile, ZIPFILE_BUFFER_SIZE));
+  iOff = szFile - nRead;
 
+  rc = zipfileReadData(pFile, aRead, nRead, iOff, &pTab->base.zErrMsg);
   if( rc==SQLITE_OK ){
     int i;
 
@@ -5246,59 +4910,17 @@
     pEOCD->nEntryTotal = zipfileRead16(aRead);
     pEOCD->nSize = zipfileRead32(aRead);
     pEOCD->iOffset = zipfileRead32(aRead);
-  }
 
-  return rc;
-}
-
-/*
-** Add object pNew to the linked list that begins at ZipfileTab.pFirstEntry 
-** and ends with pLastEntry. If argument pBefore is NULL, then pNew is added
-** to the end of the list. Otherwise, it is added to the list immediately
-** before pBefore (which is guaranteed to be a part of said list).
-*/
-static void zipfileAddEntry(
-  ZipfileTab *pTab, 
-  ZipfileEntry *pBefore, 
-  ZipfileEntry *pNew
-){
-  assert( (pTab->pFirstEntry==0)==(pTab->pLastEntry==0) );
-  assert( pNew->pNext==0 );
-  if( pBefore==0 ){
-    if( pTab->pFirstEntry==0 ){
-      pTab->pFirstEntry = pTab->pLastEntry = pNew;
-    }else{
-      assert( pTab->pLastEntry->pNext==0 );
-      pTab->pLastEntry->pNext = pNew;
-      pTab->pLastEntry = pNew;
-    }
-  }else{
-    ZipfileEntry **pp;
-    for(pp=&pTab->pFirstEntry; *pp!=pBefore; pp=&((*pp)->pNext));
-    pNew->pNext = pBefore;
-    *pp = pNew;
+#if 0
+    printf("iDisk=%d  iFirstDisk=%d  nEntry=%d  "
+           "nEntryTotal=%d  nSize=%d  iOffset=%d", 
+           (int)pEOCD->iDisk, (int)pEOCD->iFirstDisk, (int)pEOCD->nEntry,
+           (int)pEOCD->nEntryTotal, (int)pEOCD->nSize, (int)pEOCD->iOffset
+    );
+#endif
   }
-}
-
-static int zipfileLoadDirectory(ZipfileTab *pTab, const u8 *aBlob, int nBlob){
-  ZipfileEOCD eocd;
-  int rc;
-  int i;
-  i64 iOff;
 
-  rc = zipfileReadEOCD(pTab, aBlob, nBlob, pTab->pWriteFd, &eocd);
-  iOff = eocd.iOffset;
-  for(i=0; rc==SQLITE_OK && i<eocd.nEntry; i++){
-    ZipfileEntry *pNew = 0;
-    rc = zipfileGetEntry(pTab, aBlob, nBlob, pTab->pWriteFd, iOff, &pNew);
-
-    if( rc==SQLITE_OK ){
-      zipfileAddEntry(pTab, 0, pNew);
-      iOff += ZIPFILE_CDS_FIXED_SZ;
-      iOff += (int)pNew->cds.nExtra + pNew->cds.nFile + pNew->cds.nComment;
-    }
-  }
-  return rc;
+  return SQLITE_OK;
 }
 
 /*
@@ -5311,37 +4933,29 @@
 ){
   ZipfileTab *pTab = (ZipfileTab*)cur->pVtab;
   ZipfileCsr *pCsr = (ZipfileCsr*)cur;
-  const char *zFile = 0;          /* Zip file to scan */
+  const char *zFile;              /* Zip file to scan */
   int rc = SQLITE_OK;             /* Return Code */
-  int bInMemory = 0;              /* True for an in-memory zipfile */
 
   zipfileResetCursor(pCsr);
 
   if( pTab->zFile ){
     zFile = pTab->zFile;
   }else if( idxNum==0 ){
-    zipfileCursorErr(pCsr, "zipfile() function requires an argument");
+    /* Error. This is an eponymous virtual table and the user has not 
+    ** supplied a file name. */
+    zipfileSetErrmsg(pCsr, "table function zipfile() requires an argument");
     return SQLITE_ERROR;
-  }else if( sqlite3_value_type(argv[0])==SQLITE_BLOB ){
-    const u8 *aBlob = (const u8*)sqlite3_value_blob(argv[0]);
-    int nBlob = sqlite3_value_bytes(argv[0]);
-    assert( pTab->pFirstEntry==0 );
-    rc = zipfileLoadDirectory(pTab, aBlob, nBlob);
-    pCsr->pFreeEntry = pTab->pFirstEntry;
-    pTab->pFirstEntry = pTab->pLastEntry = 0;
-    if( rc!=SQLITE_OK ) return rc;
-    bInMemory = 1;
   }else{
     zFile = (const char*)sqlite3_value_text(argv[0]);
   }
 
-  if( 0==pTab->pWriteFd && 0==bInMemory ){
+  if( pTab->pWriteFd==0 ){
     pCsr->pFile = fopen(zFile, "rb");
     if( pCsr->pFile==0 ){
-      zipfileCursorErr(pCsr, "cannot open file: %s", zFile);
+      zipfileSetErrmsg(pCsr, "cannot open file: %s", zFile);
       rc = SQLITE_ERROR;
     }else{
-      rc = zipfileReadEOCD(pTab, 0, 0, pCsr->pFile, &pCsr->eocd);
+      rc = zipfileReadEOCD(pTab, pCsr->pFile, &pCsr->eocd);
       if( rc==SQLITE_OK ){
         if( pCsr->eocd.nEntry==0 ){
           pCsr->bEof = 1;
@@ -5352,9 +4966,12 @@
       }
     }
   }else{
-    pCsr->bNoop = 1;
-    pCsr->pCurrent = pCsr->pFreeEntry ? pCsr->pFreeEntry : pTab->pFirstEntry;
+    ZipfileEntry e;
+    memset(&e, 0, sizeof(e));
+    e.pNext = pTab->pFirstEntry;
+    pCsr->pCurrent = &e;
     rc = zipfileNext(cur);
+    assert( pCsr->pCurrent!=&e );
   }
 
   return rc;
@@ -5390,67 +5007,182 @@
   return SQLITE_OK;
 }
 
-static ZipfileEntry *zipfileNewEntry(const char *zPath){
-  ZipfileEntry *pNew;
-  pNew = sqlite3_malloc(sizeof(ZipfileEntry));
-  if( pNew ){
-    memset(pNew, 0, sizeof(ZipfileEntry));
-    pNew->cds.zFile = sqlite3_mprintf("%s", zPath);
-    if( pNew->cds.zFile==0 ){
-      sqlite3_free(pNew);
-      pNew = 0;
+/*
+** Add object pNew to the end of the linked list that begins at
+** ZipfileTab.pFirstEntry and ends with pLastEntry.
+*/
+static void zipfileAddEntry(
+  ZipfileTab *pTab, 
+  ZipfileEntry *pBefore, 
+  ZipfileEntry *pNew
+){
+  assert( (pTab->pFirstEntry==0)==(pTab->pLastEntry==0) );
+  assert( pNew->pNext==0 );
+  if( pBefore==0 ){
+    if( pTab->pFirstEntry==0 ){
+      pTab->pFirstEntry = pTab->pLastEntry = pNew;
+    }else{
+      assert( pTab->pLastEntry->pNext==0 );
+      pTab->pLastEntry->pNext = pNew;
+      pTab->pLastEntry = pNew;
     }
+  }else{
+    ZipfileEntry **pp;
+    for(pp=&pTab->pFirstEntry; *pp!=pBefore; pp=&((*pp)->pNext));
+    pNew->pNext = pBefore;
+    *pp = pNew;
   }
-  return pNew;
 }
 
-static int zipfileSerializeLFH(ZipfileEntry *pEntry, u8 *aBuf){
-  ZipfileCDS *pCds = &pEntry->cds;
-  u8 *a = aBuf;
+static int zipfileLoadDirectory(ZipfileTab *pTab){
+  ZipfileEOCD eocd;
+  int rc;
 
-  pCds->nExtra = 9;
+  rc = zipfileReadEOCD(pTab, pTab->pWriteFd, &eocd);
+  if( rc==SQLITE_OK && eocd.nEntry>0 ){
+    int i;
+    int iOff = 0;
+    u8 *aBuf = sqlite3_malloc(eocd.nSize);
+    if( aBuf==0 ){
+      rc = SQLITE_NOMEM;
+    }else{
+      rc = zipfileReadData(
+          pTab->pWriteFd, aBuf, eocd.nSize, eocd.iOffset, &pTab->base.zErrMsg
+      );
+    }
 
-  /* Write the LFH itself */
-  zipfileWrite32(a, ZIPFILE_SIGNATURE_LFH);
-  zipfileWrite16(a, pCds->iVersionExtract);
-  zipfileWrite16(a, pCds->flags);
-  zipfileWrite16(a, pCds->iCompression);
-  zipfileWrite16(a, pCds->mTime);
-  zipfileWrite16(a, pCds->mDate);
-  zipfileWrite32(a, pCds->crc32);
-  zipfileWrite32(a, pCds->szCompressed);
-  zipfileWrite32(a, pCds->szUncompressed);
-  zipfileWrite16(a, (u16)pCds->nFile);
-  zipfileWrite16(a, pCds->nExtra);
-  assert( a==&aBuf[ZIPFILE_LFH_FIXED_SZ] );
+    for(i=0; rc==SQLITE_OK && i<eocd.nEntry; i++){
+      u16 nFile;
+      u16 nExtra;
+      u16 nComment;
+      ZipfileEntry *pNew;
+      u8 *aRec = &aBuf[iOff];
 
-  /* Add the file name */
-  memcpy(a, pCds->zFile, (int)pCds->nFile);
-  a += (int)pCds->nFile;
+      nFile = zipfileGetU16(&aRec[ZIPFILE_CDS_NFILE_OFF]);
+      nExtra = zipfileGetU16(&aRec[ZIPFILE_CDS_NFILE_OFF+2]);
+      nComment = zipfileGetU16(&aRec[ZIPFILE_CDS_NFILE_OFF+4]);
 
-  /* The "extra" data */
-  zipfileWrite16(a, ZIPFILE_EXTRA_TIMESTAMP);
-  zipfileWrite16(a, 5);
-  *a++ = 0x01;
-  zipfileWrite32(a, pEntry->mUnixTime);
+      pNew = sqlite3_malloc(
+          sizeof(ZipfileEntry) 
+        + nFile+1 
+        + ZIPFILE_CDS_FIXED_SZ+nFile+nExtra+nComment
+      );
+      if( pNew==0 ){
+        rc = SQLITE_NOMEM;
+      }else{
+        memset(pNew, 0, sizeof(ZipfileEntry));
+        pNew->zPath = (char*)&pNew[1];
+        memcpy(pNew->zPath, &aRec[ZIPFILE_CDS_FIXED_SZ], nFile);
+        pNew->zPath[nFile] = '\0';
+        pNew->aCdsEntry = (u8*)&pNew->zPath[nFile+1];
+        pNew->nCdsEntry = ZIPFILE_CDS_FIXED_SZ+nFile+nExtra+nComment;
+        memcpy(pNew->aCdsEntry, aRec, pNew->nCdsEntry);
+        zipfileAddEntry(pTab, 0, pNew);
+      }
 
-  return a-aBuf;
+      iOff += ZIPFILE_CDS_FIXED_SZ+nFile+nExtra+nComment;
+    }
+
+    sqlite3_free(aBuf);
+  }
+
+  return rc;
+}
+
+static ZipfileEntry *zipfileNewEntry(
+  ZipfileCDS *pCds,               /* Values for fixed size part of CDS */
+  const char *zPath,              /* Path for new entry */
+  int nPath,                      /* strlen(zPath) */
+  u32 mTime                       /* Modification time (or 0) */
+){
+  u8 *aWrite;
+  ZipfileEntry *pNew;
+  pCds->nFile = (u16)nPath;
+  pCds->nExtra = mTime ? 9 : 0;
+  pNew = (ZipfileEntry*)sqlite3_malloc(
+    sizeof(ZipfileEntry) + 
+    nPath+1 + 
+    ZIPFILE_CDS_FIXED_SZ + nPath + pCds->nExtra
+  );
+
+  if( pNew ){
+    memset(pNew, 0, sizeof(ZipfileEntry));
+    pNew->zPath = (char*)&pNew[1];
+    pNew->aCdsEntry = (u8*)&pNew->zPath[nPath+1];
+    pNew->nCdsEntry = ZIPFILE_CDS_FIXED_SZ + nPath + pCds->nExtra;
+    memcpy(pNew->zPath, zPath, nPath+1);
+
+    aWrite = pNew->aCdsEntry;
+    zipfileWrite32(aWrite, ZIPFILE_SIGNATURE_CDS);
+    zipfileWrite16(aWrite, pCds->iVersionMadeBy);
+    zipfileWrite16(aWrite, pCds->iVersionExtract);
+    zipfileWrite16(aWrite, pCds->flags);
+    zipfileWrite16(aWrite, pCds->iCompression);
+    zipfileWrite16(aWrite, pCds->mTime);
+    zipfileWrite16(aWrite, pCds->mDate);
+    zipfileWrite32(aWrite, pCds->crc32);
+    zipfileWrite32(aWrite, pCds->szCompressed);
+    zipfileWrite32(aWrite, pCds->szUncompressed);
+    zipfileWrite16(aWrite, pCds->nFile);
+    zipfileWrite16(aWrite, pCds->nExtra);
+    zipfileWrite16(aWrite, pCds->nComment);      assert( pCds->nComment==0 );
+    zipfileWrite16(aWrite, pCds->iDiskStart);
+    zipfileWrite16(aWrite, pCds->iInternalAttr);
+    zipfileWrite32(aWrite, pCds->iExternalAttr);
+    zipfileWrite32(aWrite, pCds->iOffset);
+    assert( aWrite==&pNew->aCdsEntry[ZIPFILE_CDS_FIXED_SZ] );
+    memcpy(aWrite, zPath, nPath);
+    if( pCds->nExtra ){
+      aWrite += nPath;
+      zipfileWrite16(aWrite, ZIPFILE_EXTRA_TIMESTAMP);
+      zipfileWrite16(aWrite, 5);
+      *aWrite++ = 0x01;
+      zipfileWrite32(aWrite, mTime);
+    }
+  }
+
+  return pNew;
 }
 
 static int zipfileAppendEntry(
   ZipfileTab *pTab,
-  ZipfileEntry *pEntry,
+  ZipfileCDS *pCds,
+  const char *zPath,              /* Path for new entry */
+  int nPath,                      /* strlen(zPath) */
   const u8 *pData,
-  int nData
+  int nData,
+  u32 mTime
 ){
   u8 *aBuf = pTab->aBuffer;
-  int nBuf;
   int rc;
 
-  nBuf = zipfileSerializeLFH(pEntry, aBuf);
-  rc = zipfileAppendData(pTab, aBuf, nBuf);
+  zipfileWrite32(aBuf, ZIPFILE_SIGNATURE_LFH);
+  zipfileWrite16(aBuf, pCds->iVersionExtract);
+  zipfileWrite16(aBuf, pCds->flags);
+  zipfileWrite16(aBuf, pCds->iCompression);
+  zipfileWrite16(aBuf, pCds->mTime);
+  zipfileWrite16(aBuf, pCds->mDate);
+  zipfileWrite32(aBuf, pCds->crc32);
+  zipfileWrite32(aBuf, pCds->szCompressed);
+  zipfileWrite32(aBuf, pCds->szUncompressed);
+  zipfileWrite16(aBuf, (u16)nPath);
+  zipfileWrite16(aBuf, pCds->nExtra);
+  assert( aBuf==&pTab->aBuffer[ZIPFILE_LFH_FIXED_SZ] );
+  rc = zipfileAppendData(pTab, pTab->aBuffer, (int)(aBuf - pTab->aBuffer));
+  if( rc==SQLITE_OK ){
+    rc = zipfileAppendData(pTab, (const u8*)zPath, nPath);
+  }
+
+  if( rc==SQLITE_OK && pCds->nExtra ){
+    aBuf = pTab->aBuffer;
+    zipfileWrite16(aBuf, ZIPFILE_EXTRA_TIMESTAMP);
+    zipfileWrite16(aBuf, 5);
+    *aBuf++ = 0x01;
+    zipfileWrite32(aBuf, mTime);
+    rc = zipfileAppendData(pTab, pTab->aBuffer, 9);
+  }
+
   if( rc==SQLITE_OK ){
-    pEntry->iDataOff = pTab->szCurrent;
     rc = zipfileAppendData(pTab, pData, nData);
   }
 
@@ -5458,15 +5190,15 @@
 }
 
 static int zipfileGetMode(
+  ZipfileTab *pTab, 
   sqlite3_value *pVal, 
-  int bIsDir,                     /* If true, default to directory */
-  u32 *pMode,                     /* OUT: Mode value */
-  char **pzErr                    /* OUT: Error message */
+  u32 defaultMode,                /* Value to use if pVal IS NULL */
+  u32 *pMode
 ){
   const char *z = (const char*)sqlite3_value_text(pVal);
   u32 mode = 0;
   if( z==0 ){
-    mode = (bIsDir ? (S_IFDIR + 0755) : (S_IFREG + 0644));
+    mode = defaultMode;
   }else if( z[0]>='0' && z[0]<='9' ){
     mode = (unsigned int)sqlite3_value_int(pVal);
   }else{
@@ -5476,7 +5208,9 @@
     switch( z[0] ){
       case '-': mode |= S_IFREG; break;
       case 'd': mode |= S_IFDIR; break;
+#if !defined(_WIN32) && !defined(WIN32)
       case 'l': mode |= S_IFLNK; break;
+#endif
       default: goto parse_error;
     }
     for(i=1; i<10; i++){
@@ -5484,17 +5218,11 @@
       else if( z[i]!='-' ) goto parse_error;
     }
   }
-  if( ((mode & S_IFDIR)==0)==bIsDir ){
-    /* The "mode" attribute is a directory, but data has been specified.
-    ** Or vice-versa - no data but "mode" is a file or symlink.  */
-    *pzErr = sqlite3_mprintf("zipfile: mode does not match data");
-    return SQLITE_CONSTRAINT;
-  }
   *pMode = mode;
   return SQLITE_OK;
 
  parse_error:
-  *pzErr = sqlite3_mprintf("zipfile: parse error in mode: %s", z);
+  pTab->base.zErrMsg = sqlite3_mprintf("zipfile: parse error in mode: %s", z);
   return SQLITE_ERROR;
 }
 
@@ -5510,81 +5238,6 @@
   return 1;
 }
 
-static int zipfileBegin(sqlite3_vtab *pVtab){
-  ZipfileTab *pTab = (ZipfileTab*)pVtab;
-  int rc = SQLITE_OK;
-
-  assert( pTab->pWriteFd==0 );
-
-  /* Open a write fd on the file. Also load the entire central directory
-  ** structure into memory. During the transaction any new file data is 
-  ** appended to the archive file, but the central directory is accumulated
-  ** in main-memory until the transaction is committed.  */
-  pTab->pWriteFd = fopen(pTab->zFile, "ab+");
-  if( pTab->pWriteFd==0 ){
-    pTab->base.zErrMsg = sqlite3_mprintf(
-        "zipfile: failed to open file %s for writing", pTab->zFile
-        );
-    rc = SQLITE_ERROR;
-  }else{
-    fseek(pTab->pWriteFd, 0, SEEK_END);
-    pTab->szCurrent = pTab->szOrig = (i64)ftell(pTab->pWriteFd);
-    rc = zipfileLoadDirectory(pTab, 0, 0);
-  }
-
-  if( rc!=SQLITE_OK ){
-    zipfileCleanupTransaction(pTab);
-  }
-
-  return rc;
-}
-
-/*
-** Return the current time as a 32-bit timestamp in UNIX epoch format (like
-** time(2)).
-*/
-static u32 zipfileTime(void){
-  sqlite3_vfs *pVfs = sqlite3_vfs_find(0);
-  u32 ret;
-  if( pVfs->iVersion>=2 && pVfs->xCurrentTimeInt64 ){
-    i64 ms;
-    pVfs->xCurrentTimeInt64(pVfs, &ms);
-    ret = (u32)((ms/1000) - ((i64)24405875 * 8640));
-  }else{
-    double day;
-    pVfs->xCurrentTime(pVfs, &day);
-    ret = (u32)((day - 2440587.5) * 86400);
-  }
-  return ret;
-}
-
-/*
-** Return a 32-bit timestamp in UNIX epoch format.
-**
-** If the value passed as the only argument is either NULL or an SQL NULL,
-** return the current time. Otherwise, return the value stored in (*pVal)
-** cast to a 32-bit unsigned integer.
-*/
-static u32 zipfileGetTime(sqlite3_value *pVal){
-  if( pVal==0 || sqlite3_value_type(pVal)==SQLITE_NULL ){
-    return zipfileTime();
-  }
-  return (u32)sqlite3_value_int64(pVal);
-}
-
-/*
-** Unless it is NULL, entry pOld is currently part of the pTab->pFirstEntry
-** linked list.  Remove it from the list and free the object.
-*/
-static void zipfileRemoveEntryFromList(ZipfileTab *pTab, ZipfileEntry *pOld){
-  if( pOld ){
-    ZipfileEntry **pp;
-    for(pp=&pTab->pFirstEntry; (*pp)!=pOld; pp=&((*pp)->pNext));
-    *pp = (*pp)->pNext;
-    zipfileEntryFree(pOld);
-  }
-}
-
 /*
 ** xUpdate method.
 */
@@ -5599,7 +5252,7 @@
   ZipfileEntry *pNew = 0;         /* New in-memory CDS entry */
 
   u32 mode = 0;                   /* Mode for new entry */
-  u32 mTime = 0;                  /* Modification time for new entry */
+  i64 mTime = 0;                  /* Modification time for new entry */
   i64 sz = 0;                     /* Uncompressed size */
   const char *zPath = 0;          /* Path for new entry */
   int nPath = 0;                  /* strlen(zPath) */
@@ -5608,239 +5261,217 @@
   int iMethod = 0;                /* Compression method for new entry */
   u8 *pFree = 0;                  /* Free this */
   char *zFree = 0;                /* Also free this */
+  ZipfileCDS cds;                 /* New Central Directory Structure entry */
   ZipfileEntry *pOld = 0;
-  ZipfileEntry *pOld2 = 0;
-  int bUpdate = 0;                /* True for an update that modifies "name" */
   int bIsDir = 0;
   u32 iCrc32 = 0;
 
-  if( pTab->pWriteFd==0 ){
-    rc = zipfileBegin(pVtab);
-    if( rc!=SQLITE_OK ) return rc;
-  }
+  assert( pTab->zFile );
+  assert( pTab->pWriteFd );
 
-  /* If this is a DELETE or UPDATE, find the archive entry to delete. */
   if( sqlite3_value_type(apVal[0])!=SQLITE_NULL ){
     const char *zDelete = (const char*)sqlite3_value_text(apVal[0]);
     int nDelete = (int)strlen(zDelete);
-    if( nVal>1 ){
-      const char *zUpdate = (const char*)sqlite3_value_text(apVal[1]);
-      if( zUpdate && zipfileComparePath(zUpdate, zDelete, nDelete)!=0 ){
-        bUpdate = 1;
-      }
-    }
     for(pOld=pTab->pFirstEntry; 1; pOld=pOld->pNext){
-      if( zipfileComparePath(pOld->cds.zFile, zDelete, nDelete)==0 ){
+      if( pOld->bDeleted ) continue;
+      if( zipfileComparePath(pOld->zPath, zDelete, nDelete)==0 ){
+        pOld->bDeleted = 1;
         break;
       }
       assert( pOld->pNext );
     }
+    if( nVal==1 ) return SQLITE_OK;
   }
 
-  if( nVal>1 ){
-    /* Check that "sz" and "rawdata" are both NULL: */
-    if( sqlite3_value_type(apVal[5])!=SQLITE_NULL ){
-      zipfileTableErr(pTab, "sz must be NULL");
-      rc = SQLITE_CONSTRAINT;
-    }
-    if( sqlite3_value_type(apVal[6])!=SQLITE_NULL ){
-      zipfileTableErr(pTab, "rawdata must be NULL"); 
-      rc = SQLITE_CONSTRAINT;
-    }
+  /* Check that "sz" and "rawdata" are both NULL: */
+  if( sqlite3_value_type(apVal[5])!=SQLITE_NULL
+   || sqlite3_value_type(apVal[6])!=SQLITE_NULL
+  ){
+    rc = SQLITE_CONSTRAINT;
+  }
 
-    if( rc==SQLITE_OK ){
-      if( sqlite3_value_type(apVal[7])==SQLITE_NULL ){
-        /* data=NULL. A directory */
-        bIsDir = 1;
-      }else{
-        /* Value specified for "data", and possibly "method". This must be
-        ** a regular file or a symlink. */
-        const u8 *aIn = sqlite3_value_blob(apVal[7]);
-        int nIn = sqlite3_value_bytes(apVal[7]);
-        int bAuto = sqlite3_value_type(apVal[8])==SQLITE_NULL;
+  if( rc==SQLITE_OK ){
+    if( sqlite3_value_type(apVal[7])==SQLITE_NULL ){
+      /* data=NULL. A directory */
+      bIsDir = 1;
+    }else{
+      /* Value specified for "data", and possibly "method". This must be
+      ** a regular file or a symlink. */
+      const u8 *aIn = sqlite3_value_blob(apVal[7]);
+      int nIn = sqlite3_value_bytes(apVal[7]);
+      int bAuto = sqlite3_value_type(apVal[8])==SQLITE_NULL;
 
-        iMethod = sqlite3_value_int(apVal[8]);
-        sz = nIn;
-        pData = aIn;
-        nData = nIn;
-        if( iMethod!=0 && iMethod!=8 ){
-          zipfileTableErr(pTab, "unknown compression method: %d", iMethod);
-          rc = SQLITE_CONSTRAINT;
-        }else{
-          if( bAuto || iMethod ){
-            int nCmp;
-            rc = zipfileDeflate(aIn, nIn, &pFree, &nCmp, &pTab->base.zErrMsg);
-            if( rc==SQLITE_OK ){
-              if( iMethod || nCmp<nIn ){
-                iMethod = 8;
-                pData = pFree;
-                nData = nCmp;
-              }
+      iMethod = sqlite3_value_int(apVal[8]);
+      sz = nIn;
+      pData = aIn;
+      nData = nIn;
+      if( iMethod!=0 && iMethod!=8 ){
+        rc = SQLITE_CONSTRAINT;
+      }else{
+        if( bAuto || iMethod ){
+          int nCmp;
+          rc = zipfileDeflate(pTab, aIn, nIn, &pFree, &nCmp);
+          if( rc==SQLITE_OK ){
+            if( iMethod || nCmp<nIn ){
+              iMethod = 8;
+              pData = pFree;
+              nData = nCmp;
             }
           }
-          iCrc32 = crc32(0, aIn, nIn);
         }
+        iCrc32 = crc32(0, aIn, nIn);
       }
     }
+  }
 
-    if( rc==SQLITE_OK ){
-      rc = zipfileGetMode(apVal[3], bIsDir, &mode, &pTab->base.zErrMsg);
-    }
-
-    if( rc==SQLITE_OK ){
-      zPath = (const char*)sqlite3_value_text(apVal[2]);
-      nPath = (int)strlen(zPath);
-      mTime = zipfileGetTime(apVal[4]);
+  if( rc==SQLITE_OK ){
+    rc = zipfileGetMode(pTab, apVal[3], 
+        (bIsDir ? (S_IFDIR + 0755) : (S_IFREG + 0644)), &mode
+    );
+    if( rc==SQLITE_OK && (bIsDir == ((mode & S_IFDIR)==0)) ){
+      /* The "mode" attribute is a directory, but data has been specified.
+      ** Or vice-versa - no data but "mode" is a file or symlink.  */
+      rc = SQLITE_CONSTRAINT;
     }
+  }
 
-    if( rc==SQLITE_OK && bIsDir ){
-      /* For a directory, check that the last character in the path is a
-      ** '/'. This appears to be required for compatibility with info-zip
-      ** (the unzip command on unix). It does not create directories
-      ** otherwise.  */
-      if( zPath[nPath-1]!='/' ){
-        zFree = sqlite3_mprintf("%s/", zPath);
-        if( zFree==0 ){ rc = SQLITE_NOMEM; }
-        zPath = (const char*)zFree;
-        nPath++;
-      }
+  if( rc==SQLITE_OK ){
+    zPath = (const char*)sqlite3_value_text(apVal[2]);
+    nPath = (int)strlen(zPath);
+    if( sqlite3_value_type(apVal[4])==SQLITE_NULL ){
+      mTime = (sqlite3_int64)time(0);
+    }else{
+      mTime = sqlite3_value_int64(apVal[4]);
     }
+  }
 
-    /* Check that we're not inserting a duplicate entry -OR- updating an
-    ** entry with a path, thereby making it into a duplicate. */
-    if( (pOld==0 || bUpdate) && rc==SQLITE_OK ){
-      ZipfileEntry *p;
-      for(p=pTab->pFirstEntry; p; p=p->pNext){
-        if( zipfileComparePath(p->cds.zFile, zPath, nPath)==0 ){
-          switch( sqlite3_vtab_on_conflict(pTab->db) ){
-            case SQLITE_IGNORE: {
-              goto zipfile_update_done;
-            }
-            case SQLITE_REPLACE: {
-              pOld2 = p;
-              break;
-            }
-            default: {
-              zipfileTableErr(pTab, "duplicate name: \"%s\"", zPath);
-              rc = SQLITE_CONSTRAINT;
-              break;
-            }
-          }
-          break;
-        }
-      }
+  if( rc==SQLITE_OK && bIsDir ){
+    /* For a directory, check that the last character in the path is a
+    ** '/'. This appears to be required for compatibility with info-zip
+    ** (the unzip command on unix). It does not create directories
+    ** otherwise.  */
+    if( zPath[nPath-1]!='/' ){
+      zFree = sqlite3_mprintf("%s/", zPath);
+      if( zFree==0 ){ rc = SQLITE_NOMEM; }
+      zPath = (const char*)zFree;
+      nPath++;
     }
+  }
 
-    if( rc==SQLITE_OK ){
-      /* Create the new CDS record. */
-      pNew = zipfileNewEntry(zPath);
-      if( pNew==0 ){
-        rc = SQLITE_NOMEM;
-      }else{
-        pNew->cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;
-        pNew->cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;
-        pNew->cds.flags = ZIPFILE_NEWENTRY_FLAGS;
-        pNew->cds.iCompression = (u16)iMethod;
-        zipfileMtimeToDos(&pNew->cds, mTime);
-        pNew->cds.crc32 = iCrc32;
-        pNew->cds.szCompressed = nData;
-        pNew->cds.szUncompressed = (u32)sz;
-        pNew->cds.iExternalAttr = (mode<<16);
-        pNew->cds.iOffset = (u32)pTab->szCurrent;
-        pNew->cds.nFile = (u16)nPath;
-        pNew->mUnixTime = (u32)mTime;
-        rc = zipfileAppendEntry(pTab, pNew, pData, nData);
-        zipfileAddEntry(pTab, pOld, pNew);
+  /* Check that we're not inserting a duplicate entry */
+  if( rc==SQLITE_OK ){
+    ZipfileEntry *p;
+    for(p=pTab->pFirstEntry; p; p=p->pNext){
+      if( p->bDeleted ) continue;
+      if( zipfileComparePath(p->zPath, zPath, nPath)==0 ){
+        rc = SQLITE_CONSTRAINT;
+        break;
       }
     }
   }
 
-  if( rc==SQLITE_OK && (pOld || pOld2) ){
-    ZipfileCsr *pCsr;
-    for(pCsr=pTab->pCsrList; pCsr; pCsr=pCsr->pCsrNext){
-      if( pCsr->pCurrent && (pCsr->pCurrent==pOld || pCsr->pCurrent==pOld2) ){
-        pCsr->pCurrent = pCsr->pCurrent->pNext;
-        pCsr->bNoop = 1;
-      }
+  if( rc==SQLITE_OK ){
+    /* Create the new CDS record. */
+    memset(&cds, 0, sizeof(cds));
+    cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;
+    cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;
+    cds.flags = ZIPFILE_NEWENTRY_FLAGS;
+    cds.iCompression = (u16)iMethod;
+    zipfileMtimeToDos(&cds, (u32)mTime);
+    cds.crc32 = iCrc32;
+    cds.szCompressed = nData;
+    cds.szUncompressed = (u32)sz;
+    cds.iExternalAttr = (mode<<16);
+    cds.iOffset = (u32)pTab->szCurrent;
+    pNew = zipfileNewEntry(&cds, zPath, nPath, (u32)mTime);
+    if( pNew==0 ){
+      rc = SQLITE_NOMEM;
+    }else{
+      zipfileAddEntry(pTab, pOld, pNew);
     }
+  }
 
-    zipfileRemoveEntryFromList(pTab, pOld);
-    zipfileRemoveEntryFromList(pTab, pOld2);
+  /* Append the new header+file to the archive */
+  if( rc==SQLITE_OK ){
+    rc = zipfileAppendEntry(pTab, &cds, zPath, nPath, pData, nData, (u32)mTime);
   }
 
-zipfile_update_done:
+  if( rc!=SQLITE_OK && pOld ){
+    pOld->bDeleted = 0;
+  }
   sqlite3_free(pFree);
   sqlite3_free(zFree);
   return rc;
 }
 
-static int zipfileSerializeEOCD(ZipfileEOCD *p, u8 *aBuf){
-  u8 *a = aBuf;
-  zipfileWrite32(a, ZIPFILE_SIGNATURE_EOCD);
-  zipfileWrite16(a, p->iDisk);
-  zipfileWrite16(a, p->iFirstDisk);
-  zipfileWrite16(a, p->nEntry);
-  zipfileWrite16(a, p->nEntryTotal);
-  zipfileWrite32(a, p->nSize);
-  zipfileWrite32(a, p->iOffset);
-  zipfileWrite16(a, 0);        /* Size of trailing comment in bytes*/
+static int zipfileAppendEOCD(ZipfileTab *pTab, ZipfileEOCD *p){
+  u8 *aBuf = pTab->aBuffer;
 
-  return a-aBuf;
-}
+  zipfileWrite32(aBuf, ZIPFILE_SIGNATURE_EOCD);
+  zipfileWrite16(aBuf, p->iDisk);
+  zipfileWrite16(aBuf, p->iFirstDisk);
+  zipfileWrite16(aBuf, p->nEntry);
+  zipfileWrite16(aBuf, p->nEntryTotal);
+  zipfileWrite32(aBuf, p->nSize);
+  zipfileWrite32(aBuf, p->iOffset);
+  zipfileWrite16(aBuf, 0);        /* Size of trailing comment in bytes*/
 
-static int zipfileAppendEOCD(ZipfileTab *pTab, ZipfileEOCD *p){
-  int nBuf = zipfileSerializeEOCD(p, pTab->aBuffer);
-  assert( nBuf==ZIPFILE_EOCD_FIXED_SZ );
-  return zipfileAppendData(pTab, pTab->aBuffer, nBuf);
+  assert( (aBuf-pTab->aBuffer)==22 );
+  return zipfileAppendData(pTab, pTab->aBuffer, (int)(aBuf - pTab->aBuffer));
 }
 
-/*
-** Serialize the CDS structure into buffer aBuf[]. Return the number
-** of bytes written.
-*/
-static int zipfileSerializeCDS(ZipfileEntry *pEntry, u8 *aBuf){
-  u8 *a = aBuf;
-  ZipfileCDS *pCDS = &pEntry->cds;
+static void zipfileCleanupTransaction(ZipfileTab *pTab){
+  ZipfileEntry *pEntry;
+  ZipfileEntry *pNext;
 
-  if( pEntry->aExtra==0 ){
-    pCDS->nExtra = 9;
+  for(pEntry=pTab->pFirstEntry; pEntry; pEntry=pNext){
+    pNext = pEntry->pNext;
+    sqlite3_free(pEntry);
   }
+  pTab->pFirstEntry = 0;
+  pTab->pLastEntry = 0;
+  fclose(pTab->pWriteFd);
+  pTab->pWriteFd = 0;
+  pTab->szCurrent = 0;
+  pTab->szOrig = 0;
+}
 
-  zipfileWrite32(a, ZIPFILE_SIGNATURE_CDS);
-  zipfileWrite16(a, pCDS->iVersionMadeBy);
-  zipfileWrite16(a, pCDS->iVersionExtract);
-  zipfileWrite16(a, pCDS->flags);
-  zipfileWrite16(a, pCDS->iCompression);
-  zipfileWrite16(a, pCDS->mTime);
-  zipfileWrite16(a, pCDS->mDate);
-  zipfileWrite32(a, pCDS->crc32);
-  zipfileWrite32(a, pCDS->szCompressed);
-  zipfileWrite32(a, pCDS->szUncompressed);
-  assert( a==&aBuf[ZIPFILE_CDS_NFILE_OFF] );
-  zipfileWrite16(a, pCDS->nFile);
-  zipfileWrite16(a, pCDS->nExtra);
-  zipfileWrite16(a, pCDS->nComment);
-  zipfileWrite16(a, pCDS->iDiskStart);
-  zipfileWrite16(a, pCDS->iInternalAttr);
-  zipfileWrite32(a, pCDS->iExternalAttr);
-  zipfileWrite32(a, pCDS->iOffset);
+static int zipfileBegin(sqlite3_vtab *pVtab){
+  ZipfileTab *pTab = (ZipfileTab*)pVtab;
+  int rc = SQLITE_OK;
 
-  memcpy(a, pCDS->zFile, pCDS->nFile);
-  a += pCDS->nFile;
+  assert( pTab->pWriteFd==0 );
 
-  if( pEntry->aExtra ){
-    int n = (int)pCDS->nExtra + (int)pCDS->nComment;
-    memcpy(a, pEntry->aExtra, n);
-    a += n;
+  /* This table is only writable if a default archive path was specified 
+  ** as part of the CREATE VIRTUAL TABLE statement. */
+  if( pTab->zFile==0 ){
+    pTab->base.zErrMsg = sqlite3_mprintf(
+        "zipfile: writing requires a default archive"
+    );
+    return SQLITE_ERROR;
+  }
+
+  /* Open a write fd on the file. Also load the entire central directory
+  ** structure into memory. During the transaction any new file data is 
+  ** appended to the archive file, but the central directory is accumulated
+  ** in main-memory until the transaction is committed.  */
+  pTab->pWriteFd = fopen(pTab->zFile, "ab+");
+  if( pTab->pWriteFd==0 ){
+    pTab->base.zErrMsg = sqlite3_mprintf(
+        "zipfile: failed to open file %s for writing", pTab->zFile
+    );
+    rc = SQLITE_ERROR;
   }else{
-    assert( pCDS->nExtra==9 );
-    zipfileWrite16(a, ZIPFILE_EXTRA_TIMESTAMP);
-    zipfileWrite16(a, 5);
-    *a++ = 0x01;
-    zipfileWrite32(a, pEntry->mUnixTime);
+    fseek(pTab->pWriteFd, 0, SEEK_END);
+    pTab->szCurrent = pTab->szOrig = (i64)ftell(pTab->pWriteFd);
+    rc = zipfileLoadDirectory(pTab);
   }
 
-  return a-aBuf;
+  if( rc!=SQLITE_OK ){
+    zipfileCleanupTransaction(pTab);
+  }
+
+  return rc;
 }
 
 static int zipfileCommit(sqlite3_vtab *pVtab){
@@ -5852,10 +5483,10 @@
     ZipfileEOCD eocd;
     int nEntry = 0;
 
-    /* Write out all entries */
+    /* Write out all undeleted entries */
     for(p=pTab->pFirstEntry; rc==SQLITE_OK && p; p=p->pNext){
-      int n = zipfileSerializeCDS(p, pTab->aBuffer);
-      rc = zipfileAppendData(pTab, pTab->aBuffer, n);
+      if( p->bDeleted ) continue;
+      rc = zipfileAppendData(pTab, p->aCdsEntry, p->nCdsEntry);
       nEntry++;
     }
 
@@ -5896,7 +5527,7 @@
 
   pCsr = zipfileFindCursor(pTab, sqlite3_value_int64(argv[0]));
   if( pCsr ){
-    ZipfileCDS *p = &pCsr->pCurrent->cds;
+    ZipfileCDS *p = &pCsr->cds;
     char *zRes = sqlite3_mprintf("{"
         "\"version-made-by\" : %u, "
         "\"version-to-extract\" : %u, "
@@ -5933,6 +5564,7 @@
   }
 }
 
+
 /*
 ** xFindFunction method.
 */
@@ -5943,258 +5575,17 @@
   void (**pxFunc)(sqlite3_context*,int,sqlite3_value**), /* OUT: Result */
   void **ppArg                    /* OUT: User data for *pxFunc */
 ){
-  if( sqlite3_stricmp("zipfile_cds", zName)==0 ){
-    *pxFunc = zipfileFunctionCds;
-    *ppArg = (void*)pVtab;
-    return 1;
-  }
-  return 0;
-}
-
-typedef struct ZipfileBuffer ZipfileBuffer;
-struct ZipfileBuffer {
-  u8 *a;                          /* Pointer to buffer */
-  int n;                          /* Size of buffer in bytes */
-  int nAlloc;                     /* Byte allocated at a[] */
-};
-
-typedef struct ZipfileCtx ZipfileCtx;
-struct ZipfileCtx {
-  int nEntry;
-  ZipfileBuffer body;
-  ZipfileBuffer cds;
-};
-
-static int zipfileBufferGrow(ZipfileBuffer *pBuf, int nByte){
-  if( pBuf->n+nByte>pBuf->nAlloc ){
-    u8 *aNew;
-    int nNew = pBuf->n ? pBuf->n*2 : 512;
-    int nReq = pBuf->n + nByte;
-
-    while( nNew<nReq ) nNew = nNew*2;
-    aNew = sqlite3_realloc(pBuf->a, nNew);
-    if( aNew==0 ) return SQLITE_NOMEM;
-    pBuf->a = aNew;
-    pBuf->nAlloc = nNew;
-  }
-  return SQLITE_OK;
-}
-
-/*
-** xStep() callback for the zipfile() aggregate. This can be called in
-** any of the following ways:
-**
-**   SELECT zipfile(name,data) ...
-**   SELECT zipfile(name,mode,mtime,data) ...
-**   SELECT zipfile(name,mode,mtime,data,method) ...
-*/
-void zipfileStep(sqlite3_context *pCtx, int nVal, sqlite3_value **apVal){
-  ZipfileCtx *p;                  /* Aggregate function context */
-  ZipfileEntry e;                 /* New entry to add to zip archive */
-
-  sqlite3_value *pName = 0;
-  sqlite3_value *pMode = 0;
-  sqlite3_value *pMtime = 0;
-  sqlite3_value *pData = 0;
-  sqlite3_value *pMethod = 0;
-
-  int bIsDir = 0;
-  u32 mode;
-  int rc = SQLITE_OK;
-  char *zErr = 0;
-
-  int iMethod = -1;               /* Compression method to use (0 or 8) */
-
-  const u8 *aData = 0;            /* Possibly compressed data for new entry */
-  int nData = 0;                  /* Size of aData[] in bytes */
-  int szUncompressed = 0;         /* Size of data before compression */
-  u8 *aFree = 0;                  /* Free this before returning */
-  u32 iCrc32 = 0;                 /* crc32 of uncompressed data */
-
-  char *zName = 0;                /* Path (name) of new entry */
-  int nName = 0;                  /* Size of zName in bytes */
-  char *zFree = 0;                /* Free this before returning */
-  int nByte;
-
-  memset(&e, 0, sizeof(e));
-  p = (ZipfileCtx*)sqlite3_aggregate_context(pCtx, sizeof(ZipfileCtx));
-  if( p==0 ) return;
-
-  /* Martial the arguments into stack variables */
-  if( nVal!=2 && nVal!=4 && nVal!=5 ){
-    zErr = sqlite3_mprintf("wrong number of arguments to function zipfile()");
-    rc = SQLITE_ERROR;
-    goto zipfile_step_out;
-  }
-  pName = apVal[0];
-  if( nVal==2 ){
-    pData = apVal[1];
-  }else{
-    pMode = apVal[1];
-    pMtime = apVal[2];
-    pData = apVal[3];
-    if( nVal==5 ){
-      pMethod = apVal[4];
-    }
-  }
-
-  /* Check that the 'name' parameter looks ok. */
-  zName = (char*)sqlite3_value_text(pName);
-  nName = sqlite3_value_bytes(pName);
-  if( zName==0 ){
-    zErr = sqlite3_mprintf("first argument to zipfile() must be non-NULL");
-    rc = SQLITE_ERROR;
-    goto zipfile_step_out;
-  }
-
-  /* Inspect the 'method' parameter. This must be either 0 (store), 8 (use
-  ** deflate compression) or NULL (choose automatically).  */
-  if( pMethod && SQLITE_NULL!=sqlite3_value_type(pMethod) ){
-    iMethod = (int)sqlite3_value_int64(pMethod);
-    if( iMethod!=0 && iMethod!=8 ){
-      zErr = sqlite3_mprintf("illegal method value: %d", iMethod);
-      rc = SQLITE_ERROR;
-      goto zipfile_step_out;
-    }
-  }
-
-  /* Now inspect the data. If this is NULL, then the new entry must be a
-  ** directory.  Otherwise, figure out whether or not the data should
-  ** be deflated or simply stored in the zip archive. */
-  if( sqlite3_value_type(pData)==SQLITE_NULL ){
-    bIsDir = 1;
-    iMethod = 0;
-  }else{
-    aData = sqlite3_value_blob(pData);
-    szUncompressed = nData = sqlite3_value_bytes(pData);
-    iCrc32 = crc32(0, aData, nData);
-    if( iMethod<0 || iMethod==8 ){
-      int nOut = 0;
-      rc = zipfileDeflate(aData, nData, &aFree, &nOut, &zErr);
-      if( rc!=SQLITE_OK ){
-        goto zipfile_step_out;
-      }
-      if( iMethod==8 || nOut<nData ){
-        aData = aFree;
-        nData = nOut;
-        iMethod = 8;
-      }else{
-        iMethod = 0;
-      }
-    }
-  }
-
-  /* Decode the "mode" argument. */
-  rc = zipfileGetMode(pMode, bIsDir, &mode, &zErr);
-  if( rc ) goto zipfile_step_out;
-
-  /* Decode the "mtime" argument. */
-  e.mUnixTime = zipfileGetTime(pMtime);
-
-  /* If this is a directory entry, ensure that there is exactly one '/'
-  ** at the end of the path. Or, if this is not a directory and the path
-  ** ends in '/' it is an error. */
-  if( bIsDir==0 ){
-    if( zName[nName-1]=='/' ){
-      zErr = sqlite3_mprintf("non-directory name must not end with /");
-      rc = SQLITE_ERROR;
-      goto zipfile_step_out;
-    }
-  }else{
-    if( zName[nName-1]!='/' ){
-      zName = zFree = sqlite3_mprintf("%s/", zName);
-      nName++;
-      if( zName==0 ){
-        rc = SQLITE_NOMEM;
-        goto zipfile_step_out;
-      }
-    }else{
-      while( nName>1 && zName[nName-2]=='/' ) nName--;
-    }
-  }
-
-  /* Assemble the ZipfileEntry object for the new zip archive entry */
-  e.cds.iVersionMadeBy = ZIPFILE_NEWENTRY_MADEBY;
-  e.cds.iVersionExtract = ZIPFILE_NEWENTRY_REQUIRED;
-  e.cds.flags = ZIPFILE_NEWENTRY_FLAGS;
-  e.cds.iCompression = (u16)iMethod;
-  zipfileMtimeToDos(&e.cds, (u32)e.mUnixTime);
-  e.cds.crc32 = iCrc32;
-  e.cds.szCompressed = nData;
-  e.cds.szUncompressed = szUncompressed;
-  e.cds.iExternalAttr = (mode<<16);
-  e.cds.iOffset = p->body.n;
-  e.cds.nFile = (u16)nName;
-  e.cds.zFile = zName;
-
-  /* Append the LFH to the body of the new archive */
-  nByte = ZIPFILE_LFH_FIXED_SZ + e.cds.nFile + 9;
-  if( (rc = zipfileBufferGrow(&p->body, nByte)) ) goto zipfile_step_out;
-  p->body.n += zipfileSerializeLFH(&e, &p->body.a[p->body.n]);
-
-  /* Append the data to the body of the new archive */
-  if( nData>0 ){
-    if( (rc = zipfileBufferGrow(&p->body, nData)) ) goto zipfile_step_out;
-    memcpy(&p->body.a[p->body.n], aData, nData);
-    p->body.n += nData;
-  }
-
-  /* Append the CDS record to the directory of the new archive */
-  nByte = ZIPFILE_CDS_FIXED_SZ + e.cds.nFile + 9;
-  if( (rc = zipfileBufferGrow(&p->cds, nByte)) ) goto zipfile_step_out;
-  p->cds.n += zipfileSerializeCDS(&e, &p->cds.a[p->cds.n]);
-
-  /* Increment the count of entries in the archive */
-  p->nEntry++;
-
- zipfile_step_out:
-  sqlite3_free(aFree);
-  sqlite3_free(zFree);
-  if( rc ){
-    if( zErr ){
-      sqlite3_result_error(pCtx, zErr, -1);
-    }else{
-      sqlite3_result_error_code(pCtx, rc);
-    }
-  }
-  sqlite3_free(zErr);
-}
-
-/*
-** xFinalize() callback for zipfile aggregate function.
-*/
-void zipfileFinal(sqlite3_context *pCtx){
-  ZipfileCtx *p;
-  ZipfileEOCD eocd;
-  int nZip;
-  u8 *aZip;
-
-  p = (ZipfileCtx*)sqlite3_aggregate_context(pCtx, sizeof(ZipfileCtx));
-  if( p==0 ) return;
-  if( p->nEntry>0 ){
-    memset(&eocd, 0, sizeof(eocd));
-    eocd.nEntry = (u16)p->nEntry;
-    eocd.nEntryTotal = (u16)p->nEntry;
-    eocd.nSize = p->cds.n;
-    eocd.iOffset = p->body.n;
-
-    nZip = p->body.n + p->cds.n + ZIPFILE_EOCD_FIXED_SZ;
-    aZip = (u8*)sqlite3_malloc(nZip);
-    if( aZip==0 ){
-      sqlite3_result_error_nomem(pCtx);
-    }else{
-      memcpy(aZip, p->body.a, p->body.n);
-      memcpy(&aZip[p->body.n], p->cds.a, p->cds.n);
-      zipfileSerializeEOCD(&eocd, &aZip[p->body.n + p->cds.n]);
-      sqlite3_result_blob(pCtx, aZip, nZip, zipfileFree);
+  if( nArg>0 ){
+    if( sqlite3_stricmp("zipfile_cds", zName)==0 ){
+      *pxFunc = zipfileFunctionCds;
+      *ppArg = (void*)pVtab;
+      return 1;
     }
   }
 
-  sqlite3_free(p->body.a);
-  sqlite3_free(p->cds.a);
+  return 0;
 }
 
-
 /*
 ** Register the "zipfile" virtual table.
 */
@@ -6212,7 +5603,7 @@
     zipfileNext,               /* xNext - advance a cursor */
     zipfileEof,                /* xEof - check for end of scan */
     zipfileColumn,             /* xColumn - read data */
-    0,                         /* xRowid - read data */
+    zipfileRowid,              /* xRowid - read data */
     zipfileUpdate,             /* xUpdate */
     zipfileBegin,              /* xBegin */
     0,                         /* xSync */
@@ -6223,11 +5614,8 @@
   };
 
   int rc = sqlite3_create_module(db, "zipfile"  , &zipfileModule, 0);
-  if( rc==SQLITE_OK ) rc = sqlite3_overload_function(db, "zipfile_cds", -1);
   if( rc==SQLITE_OK ){
-    rc = sqlite3_create_function(db, "zipfile", -1, SQLITE_UTF8, 0, 0, 
-        zipfileStep, zipfileFinal
-    );
+    rc = sqlite3_overload_function(db, "zipfile_cds", -1);
   }
   return rc;
 }
@@ -8596,7 +7984,6 @@
 #define SHELL_OPEN_NORMAL     1      /* Normal database file */
 #define SHELL_OPEN_APPENDVFS  2      /* Use appendvfs */
 #define SHELL_OPEN_ZIPFILE    3      /* Use the zipfile virtual table */
-#define SHELL_OPEN_READONLY   4      /* Open a normal database read-only */
 
 /*
 ** These are the allowed shellFlgs values
@@ -8703,7 +8090,6 @@
 **
 ** Also throw an error if the EDITOR program returns a non-zero exit code.
 */
-#ifndef SQLITE_NOHAVE_SYSTEM
 static void editFunc(
   sqlite3_context *context,
   int argc,
@@ -8801,10 +8187,9 @@
     goto edit_func_end;
   }
   if( bBin ){
-    sqlite3_result_blob64(context, p, sz, sqlite3_free);
+    sqlite3_result_blob(context, p, sz, sqlite3_free);
   }else{
-    sqlite3_result_text64(context, (const char*)p, sz,
-                          sqlite3_free, SQLITE_UTF8);
+    sqlite3_result_text(context, (const char*)p, sz, sqlite3_free);
   }
   p = 0;
 
@@ -8814,7 +8199,6 @@
   sqlite3_free(zTempFile);
   sqlite3_free(p);
 }
-#endif /* SQLITE_NOHAVE_SYSTEM */
 
 /*
 ** Save or restore the current output mode
@@ -9800,54 +9184,29 @@
 ){
   int iCur;
   int iHiwtr;
-  FILE *out;
-  if( pArg==0 || pArg->out==0 ) return 0;
-  out = pArg->out;
 
-  if( pArg->pStmt && (pArg->statsOn & 2) ){
-    int nCol, i, x;
-    sqlite3_stmt *pStmt = pArg->pStmt;
-    char z[100];
-    nCol = sqlite3_column_count(pStmt);
-    raw_printf(out, "%-36s %d\n", "Number of output columns:", nCol);
-    for(i=0; i<nCol; i++){
-      sqlite3_snprintf(sizeof(z),z,"Column %d %nname:", i, &x);
-      utf8_printf(out, "%-36s %s\n", z, sqlite3_column_name(pStmt,i));
-#ifndef SQLITE_OMIT_DECLTYPE
-      sqlite3_snprintf(30, z+x, "declared type:");
-      utf8_printf(out, "%-36s %s\n", z, sqlite3_column_decltype(pStmt, i));
-#endif
-#ifdef SQLITE_ENABLE_COLUMN_METADATA
-      sqlite3_snprintf(30, z+x, "database name:");
-      utf8_printf(out, "%-36s %s\n", z, sqlite3_column_database_name(pStmt,i));
-      sqlite3_snprintf(30, z+x, "table name:");
-      utf8_printf(out, "%-36s %s\n", z, sqlite3_column_table_name(pStmt,i));
-      sqlite3_snprintf(30, z+x, "origin name:");
-      utf8_printf(out, "%-36s %s\n", z, sqlite3_column_origin_name(pStmt,i));
-#endif
+  if( pArg && pArg->out ){
+    displayStatLine(pArg, "Memory Used:",
+       "%lld (max %lld) bytes", SQLITE_STATUS_MEMORY_USED, bReset);
+    displayStatLine(pArg, "Number of Outstanding Allocations:",
+       "%lld (max %lld)", SQLITE_STATUS_MALLOC_COUNT, bReset);
+    if( pArg->shellFlgs & SHFLG_Pagecache ){
+      displayStatLine(pArg, "Number of Pcache Pages Used:",
+         "%lld (max %lld) pages", SQLITE_STATUS_PAGECACHE_USED, bReset);
     }
-  }
-
-  displayStatLine(pArg, "Memory Used:",
-     "%lld (max %lld) bytes", SQLITE_STATUS_MEMORY_USED, bReset);
-  displayStatLine(pArg, "Number of Outstanding Allocations:",
-     "%lld (max %lld)", SQLITE_STATUS_MALLOC_COUNT, bReset);
-  if( pArg->shellFlgs & SHFLG_Pagecache ){
-    displayStatLine(pArg, "Number of Pcache Pages Used:",
-       "%lld (max %lld) pages", SQLITE_STATUS_PAGECACHE_USED, bReset);
-  }
-  displayStatLine(pArg, "Number of Pcache Overflow Bytes:",
-     "%lld (max %lld) bytes", SQLITE_STATUS_PAGECACHE_OVERFLOW, bReset);
-  displayStatLine(pArg, "Largest Allocation:",
-     "%lld bytes", SQLITE_STATUS_MALLOC_SIZE, bReset);
-  displayStatLine(pArg, "Largest Pcache Allocation:",
-     "%lld bytes", SQLITE_STATUS_PAGECACHE_SIZE, bReset);
+    displayStatLine(pArg, "Number of Pcache Overflow Bytes:",
+       "%lld (max %lld) bytes", SQLITE_STATUS_PAGECACHE_OVERFLOW, bReset);
+    displayStatLine(pArg, "Largest Allocation:",
+       "%lld bytes", SQLITE_STATUS_MALLOC_SIZE, bReset);
+    displayStatLine(pArg, "Largest Pcache Allocation:",
+       "%lld bytes", SQLITE_STATUS_PAGECACHE_SIZE, bReset);
 #ifdef YYTRACKMAXSTACKDEPTH
-  displayStatLine(pArg, "Deepest Parser Stack:",
-     "%lld (max %lld)", SQLITE_STATUS_PARSER_STACK, bReset);
+    displayStatLine(pArg, "Deepest Parser Stack:",
+       "%lld (max %lld)", SQLITE_STATUS_PARSER_STACK, bReset);
 #endif
+  }
 
-  if( db ){
+  if( pArg && pArg->out && db ){
     if( pArg->shellFlgs & SHFLG_Lookaside ){
       iHiwtr = iCur = -1;
       sqlite3_db_status(db, SQLITE_DBSTATUS_LOOKASIDE_USED,
@@ -9882,9 +9241,6 @@
     sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_WRITE, &iCur, &iHiwtr, 1);
     raw_printf(pArg->out, "Page cache writes:                   %d\n", iCur);
     iHiwtr = iCur = -1;
-    sqlite3_db_status(db, SQLITE_DBSTATUS_CACHE_SPILL, &iCur, &iHiwtr, 1);
-    raw_printf(pArg->out, "Page cache spills:                   %d\n", iCur);
-    iHiwtr = iCur = -1;
     sqlite3_db_status(db, SQLITE_DBSTATUS_SCHEMA_USED, &iCur, &iHiwtr, bReset);
     raw_printf(pArg->out, "Schema Heap Usage:                   %d bytes\n",
             iCur);
@@ -9894,7 +9250,7 @@
             iCur);
   }
 
-  if( pArg->pStmt ){
+  if( pArg && pArg->out && db && pArg->pStmt ){
     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_FULLSCAN_STEP,
                                bReset);
     raw_printf(pArg->out, "Fullscan Steps:                      %d\n", iCur);
@@ -9904,12 +9260,6 @@
     raw_printf(pArg->out, "Autoindex Inserts:                   %d\n", iCur);
     iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_VM_STEP, bReset);
     raw_printf(pArg->out, "Virtual Machine Steps:               %d\n", iCur);
-    iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_REPREPARE, bReset);
-    raw_printf(pArg->out, "Reprepare operations:                %d\n", iCur);
-    iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_RUN, bReset);
-    raw_printf(pArg->out, "Number of times run:                 %d\n", iCur);
-    iCur = sqlite3_stmt_status(pArg->pStmt, SQLITE_STMTSTATUS_MEMUSED, bReset);
-    raw_printf(pArg->out, "Memory used by prepared stmt:        %d\n", iCur);
   }
 
 #ifdef __linux__
@@ -10125,7 +9475,8 @@
 */
 static void exec_prepared_stmt(
   ShellState *pArg,                                /* Pointer to ShellState */
-  sqlite3_stmt *pStmt                              /* Statment to run */
+  sqlite3_stmt *pStmt,                             /* Statment to run */
+  int (*xCallback)(void*,int,char**,char**,int*)   /* Callback function */
 ){
   int rc;
 
@@ -10135,47 +9486,54 @@
   rc = sqlite3_step(pStmt);
   /* if we have a result set... */
   if( SQLITE_ROW == rc ){
-    /* allocate space for col name ptr, value ptr, and type */
-    int nCol = sqlite3_column_count(pStmt);
-    void *pData = sqlite3_malloc64(3*nCol*sizeof(const char*) + 1);
-    if( !pData ){
-      rc = SQLITE_NOMEM;
-    }else{
-      char **azCols = (char **)pData;      /* Names of result columns */
-      char **azVals = &azCols[nCol];       /* Results */
-      int *aiTypes = (int *)&azVals[nCol]; /* Result types */
-      int i, x;
-      assert(sizeof(int) <= sizeof(char *));
-      /* save off ptrs to column names */
-      for(i=0; i<nCol; i++){
-        azCols[i] = (char *)sqlite3_column_name(pStmt, i);
-      }
-      do{
-        /* extract the data and data types */
+    /* if we have a callback... */
+    if( xCallback ){
+      /* allocate space for col name ptr, value ptr, and type */
+      int nCol = sqlite3_column_count(pStmt);
+      void *pData = sqlite3_malloc64(3*nCol*sizeof(const char*) + 1);
+      if( !pData ){
+        rc = SQLITE_NOMEM;
+      }else{
+        char **azCols = (char **)pData;      /* Names of result columns */
+        char **azVals = &azCols[nCol];       /* Results */
+        int *aiTypes = (int *)&azVals[nCol]; /* Result types */
+        int i, x;
+        assert(sizeof(int) <= sizeof(char *));
+        /* save off ptrs to column names */
         for(i=0; i<nCol; i++){
-          aiTypes[i] = x = sqlite3_column_type(pStmt, i);
-          if( x==SQLITE_BLOB && pArg && pArg->cMode==MODE_Insert ){
-            azVals[i] = "";
-          }else{
-            azVals[i] = (char*)sqlite3_column_text(pStmt, i);
-          }
-          if( !azVals[i] && (aiTypes[i]!=SQLITE_NULL) ){
-            rc = SQLITE_NOMEM;
-            break; /* from for */
-          }
-        } /* end for */
+          azCols[i] = (char *)sqlite3_column_name(pStmt, i);
+        }
+        do{
+          /* extract the data and data types */
+          for(i=0; i<nCol; i++){
+            aiTypes[i] = x = sqlite3_column_type(pStmt, i);
+            if( x==SQLITE_BLOB && pArg && pArg->cMode==MODE_Insert ){
+              azVals[i] = "";
+            }else{
+              azVals[i] = (char*)sqlite3_column_text(pStmt, i);
+            }
+            if( !azVals[i] && (aiTypes[i]!=SQLITE_NULL) ){
+              rc = SQLITE_NOMEM;
+              break; /* from for */
+            }
+          } /* end for */
 
-        /* if data and types extracted successfully... */
-        if( SQLITE_ROW == rc ){
-          /* call the supplied callback with the result row data */
-          if( shell_callback(pArg, nCol, azVals, azCols, aiTypes) ){
-            rc = SQLITE_ABORT;
-          }else{
-            rc = sqlite3_step(pStmt);
+          /* if data and types extracted successfully... */
+          if( SQLITE_ROW == rc ){
+            /* call the supplied callback with the result row data */
+            if( xCallback(pArg, nCol, azVals, azCols, aiTypes) ){
+              rc = SQLITE_ABORT;
+            }else{
+              rc = sqlite3_step(pStmt);
+            }
           }
-        }
-      } while( SQLITE_ROW == rc );
-      sqlite3_free(pData);
+        } while( SQLITE_ROW == rc );
+        sqlite3_free(pData);
+      }
+    }else{
+      do{
+        rc = sqlite3_step(pStmt);
+      } while( rc == SQLITE_ROW );
     }
   }
 }
@@ -10321,15 +9679,17 @@
 ** and callback data argument.
 */
 static int shell_exec(
-  ShellState *pArg,                         /* Pointer to ShellState */
+  sqlite3 *db,                              /* An open database */
   const char *zSql,                         /* SQL to be evaluated */
+  int (*xCallback)(void*,int,char**,char**,int*),   /* Callback function */
+                                            /* (not the same as sqlite3_exec) */
+  ShellState *pArg,                         /* Pointer to ShellState */
   char **pzErrMsg                           /* Error msg written here */
 ){
   sqlite3_stmt *pStmt = NULL;     /* Statement to execute. */
   int rc = SQLITE_OK;             /* Return Code */
   int rc2;
   const char *zLeftover;          /* Tail of unprocessed SQL */
-  sqlite3 *db = pArg->db;
 
   if( pzErrMsg ){
     *pzErrMsg = NULL;
@@ -10400,18 +9760,13 @@
           if( rc==SQLITE_OK ){
             pArg->cMode = MODE_Explain;
             explain_data_prepare(pArg, pExplain);
-            exec_prepared_stmt(pArg, pExplain);
+            exec_prepared_stmt(pArg, pExplain, xCallback);
             explain_data_delete(pArg);
           }
           sqlite3_finalize(pExplain);
           sqlite3_free(zEQP);
         }
-        if( pArg->autoEQP>=AUTOEQP_trigger && triggerEQP==0 ){
-          sqlite3_db_config(db, SQLITE_DBCONFIG_TRIGGER_EQP, 0, 0);
-          /* Reprepare pStmt before reactiving trace modes */
-          sqlite3_finalize(pStmt);
-          sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
-        }
+        sqlite3_db_config(db, SQLITE_DBCONFIG_TRIGGER_EQP, triggerEQP, 0);
         restore_debug_trace_modes();
       }
 
@@ -10431,7 +9786,7 @@
         }
       }
 
-      exec_prepared_stmt(pArg, pStmt);
+      exec_prepared_stmt(pArg, pStmt, xCallback);
       explain_data_delete(pArg);
 
       /* print usage stats if stats on */
@@ -10694,11 +10049,11 @@
     savedMode = p->mode;
     p->zDestTable = sTable.z;
     p->mode = p->cMode = MODE_Insert;
-    rc = shell_exec(p, sSelect.z, 0);
+    rc = shell_exec(p->db, sSelect.z, shell_callback, p, 0);
     if( (rc&0xff)==SQLITE_CORRUPT ){
       raw_printf(p->out, "/****** CORRUPTION ERROR *******/\n");
       toggleSelectOrder(p->db);
-      shell_exec(p, sSelect.z, 0);
+      shell_exec(p->db, sSelect.z, shell_callback, p, 0);
       toggleSelectOrder(p->db);
     }
     p->zDestTable = savedDestTable;
@@ -10815,7 +10170,6 @@
   "                         on the output.\n"
   ".open ?OPTIONS? ?FILE? Close existing database and reopen FILE\n"
   "                         The --new option starts with an empty file\n"
-  "                         Other options: --readonly --append --zip\n"
   ".output ?FILE?         Send output to FILE or stdout\n"
   ".print STRING...       Print literal STRING\n"
   ".prompt MAIN CONTINUE  Replace the standard prompts\n"
@@ -10833,14 +10187,10 @@
   ".session CMD ...       Create or control sessions\n"
 #endif
   ".sha3sum ?OPTIONS...?  Compute a SHA3 hash of database content\n"
-#ifndef SQLITE_NOHAVE_SYSTEM
   ".shell CMD ARGS...     Run CMD ARGS... in a system shell\n"
-#endif
   ".show                  Show the current values for various settings\n"
   ".stats ?on|off?        Show stats or turn stats on or off\n"
-#ifndef SQLITE_NOHAVE_SYSTEM
   ".system CMD ARGS...    Run CMD ARGS... in a system shell\n"
-#endif
   ".tables ?TABLE?        List names of tables\n"
   "                         If TABLE specified, only list tables matching\n"
   "                         LIKE pattern TABLE.\n"
@@ -10969,21 +10319,13 @@
 /*
 ** Try to deduce the type of file for zName based on its content.  Return
 ** one of the SHELL_OPEN_* constants.
-**
-** If the file does not exist or is empty but its name looks like a ZIP
-** archive and the dfltZip flag is true, then assume it is a ZIP archive.
-** Otherwise, assume an ordinary database regardless of the filename if
-** the type cannot be determined from content.
 */
-static int deduceDatabaseType(const char *zName, int dfltZip){
+static int deduceDatabaseType(const char *zName){
   FILE *f = fopen(zName, "rb");
   size_t n;
   int rc = SHELL_OPEN_UNSPEC;
   char zBuf[100];
-  if( f==0 ){
-    if( dfltZip && sqlite3_strlike("%.zip",zName,0)==0 ) return SHELL_OPEN_ZIPFILE;
-    return SHELL_OPEN_NORMAL;
-  }
+  if( f==0 ) return SHELL_OPEN_NORMAL;
   fseek(f, -25, SEEK_END);
   n = fread(zBuf, 25, 1, f);
   if( n==1 && memcmp(zBuf, "Start-Of-SQLite3-", 17)==0 ){
@@ -10994,8 +10336,6 @@
     if( n==1 && zBuf[0]==0x50 && zBuf[1]==0x4b && zBuf[2]==0x05
        && zBuf[3]==0x06 ){
       rc = SHELL_OPEN_ZIPFILE;
-    }else if( n==0 && dfltZip && sqlite3_strlike("%.zip",zName,0)==0 ){
-      return SHELL_OPEN_ZIPFILE;
     }
   }
   fclose(f);
@@ -11010,7 +10350,7 @@
   if( p->db==0 ){
     sqlite3_initialize();
     if( p->openMode==SHELL_OPEN_UNSPEC && access(p->zDbFilename,0)==0 ){
-      p->openMode = (u8)deduceDatabaseType(p->zDbFilename, 0);
+      p->openMode = deduceDatabaseType(p->zDbFilename);
     }
     switch( p->openMode ){
       case SHELL_OPEN_APPENDVFS: {
@@ -11022,10 +10362,6 @@
         sqlite3_open(":memory:", &p->db);
         break;
       }
-      case SHELL_OPEN_READONLY: {
-        sqlite3_open_v2(p->zDbFilename, &p->db, SQLITE_OPEN_READONLY, 0);
-        break;
-      }
       case SHELL_OPEN_UNSPEC:
       case SHELL_OPEN_NORMAL: {
         sqlite3_open(p->zDbFilename, &p->db);
@@ -11055,12 +10391,27 @@
                             shellModuleSchema, 0, 0);
     sqlite3_create_function(p->db, "shell_putsnl", 1, SQLITE_UTF8, p,
                             shellPutsFunc, 0, 0);
-#ifndef SQLITE_NOHAVE_SYSTEM
     sqlite3_create_function(p->db, "edit", 1, SQLITE_UTF8, 0,
                             editFunc, 0, 0);
     sqlite3_create_function(p->db, "edit", 2, SQLITE_UTF8, 0,
                             editFunc, 0, 0);
-#endif
+
+    // Begin Android Add
+    #ifndef NO_ANDROID_FUNCS
+        InitializeIcuOrDie();
+        int err = register_localized_collators(p->db, "en_US", 0);
+        if (err != SQLITE_OK) {
+          fprintf(stderr, "register_localized_collators() failed\n");
+          exit(1);
+        }
+        err = register_android_functions(p->db, 0);
+        if (err != SQLITE_OK) {
+          fprintf(stderr, "register_android_functions() failed\n");
+          exit(1);
+        }
+    #endif
+    // End Android Add
+
     if( p->openMode==SHELL_OPEN_ZIPFILE ){
       char *zSql = sqlite3_mprintf(
          "CREATE VIRTUAL TABLE zip USING zipfile(%Q);", p->zDbFilename);
@@ -11675,7 +11026,6 @@
 #endif
   }else{
     output_file_close(p->out);
-#ifndef SQLITE_NOHAVE_SYSTEM
     if( p->doXdgOpen ){
       const char *zXdgOpenCmd =
 #if defined(_WIN32)
@@ -11694,7 +11044,6 @@
       outputModePop(p);
       p->doXdgOpen = 0;
     }
-#endif /* !defined(SQLITE_NOHAVE_SYSTEM) */
   }
   p->outfile[0] = 0;
   p->out = stdout;
@@ -12805,8 +12154,8 @@
       "  data BLOB               -- compressed content\n"
       ")";
   const char *zDrop = "DROP TABLE IF EXISTS sqlar";
-  const char *zInsertFmt[2] = {
-     "REPLACE INTO %s(name,mode,mtime,sz,data)\n"
+  const char *zInsertFmt = 
+     "REPLACE INTO sqlar(name,mode,mtime,sz,data)\n"
      "  SELECT\n"
      "    %s,\n"
      "    mode,\n"
@@ -12815,70 +12164,30 @@
      "      WHEN '-' THEN length(data)\n"
      "      WHEN 'd' THEN 0\n"
      "      ELSE -1 END,\n"
-     "    sqlar_compress(data)\n"
-     "  FROM fsdir(%Q,%Q)\n"
-     "  WHERE lsmode(mode) NOT LIKE '?%%';",
-     "REPLACE INTO %s(name,mode,mtime,data)\n"
-     "  SELECT\n"
-     "    %s,\n"
-     "    mode,\n"
-     "    mtime,\n"
-     "    data\n"
+     "    CASE WHEN lsmode(mode) LIKE 'd%%' THEN NULL else data END\n"
      "  FROM fsdir(%Q,%Q)\n"
-     "  WHERE lsmode(mode) NOT LIKE '?%%';"
-  };
+     "  WHERE lsmode(mode) NOT LIKE '?%%';";
   int i;                          /* For iterating through azFile[] */
   int rc;                         /* Return code */
-  const char *zTab = 0;           /* SQL table into which to insert */
-  char *zSql;
-  char zTemp[50];
 
-  arExecSql(pAr, "PRAGMA page_size=512");
   rc = arExecSql(pAr, "SAVEPOINT ar;");
   if( rc!=SQLITE_OK ) return rc;
-  zTemp[0] = 0; 
-  if( pAr->bZip ){
-    /* Initialize the zipfile virtual table, if necessary */
-    if( pAr->zFile ){
-      sqlite3_uint64 r;
-      sqlite3_randomness(sizeof(r),&r);
-      sqlite3_snprintf(sizeof(zTemp),zTemp,"zip%016llx",r);
-      zTab = zTemp;
-      zSql = sqlite3_mprintf(
-         "CREATE VIRTUAL TABLE temp.%s USING zipfile(%Q)",
-         zTab, pAr->zFile
-      );
-      rc = arExecSql(pAr, zSql);
-      sqlite3_free(zSql);
-    }else{
-      zTab = "zip";
-    }
-  }else{
-    /* Initialize the table for an SQLAR */
-    zTab = "sqlar";
-    if( bUpdate==0 ){
-      rc = arExecSql(pAr, zDrop);
-      if( rc!=SQLITE_OK ) goto end_ar_transaction;
-    }
-    rc = arExecSql(pAr, zCreate);
+  if( bUpdate==0 ){
+    rc = arExecSql(pAr, zDrop);
+    if( rc!=SQLITE_OK ) return rc;
   }
+  rc = arExecSql(pAr, zCreate);
   for(i=0; i<pAr->nArg && rc==SQLITE_OK; i++){
-    char *zSql2 = sqlite3_mprintf(zInsertFmt[pAr->bZip], zTab,
+    char *zSql = sqlite3_mprintf(zInsertFmt,
         pAr->bVerbose ? "shell_putsnl(name)" : "name",
         pAr->azArg[i], pAr->zDir);
-    rc = arExecSql(pAr, zSql2);
-    sqlite3_free(zSql2);
+    rc = arExecSql(pAr, zSql);
+    sqlite3_free(zSql);
   }
-end_ar_transaction:
   if( rc!=SQLITE_OK ){
     arExecSql(pAr, "ROLLBACK TO ar; RELEASE ar;");
   }else{
     rc = arExecSql(pAr, "RELEASE ar;");
-    if( pAr->bZip && pAr->zFile ){
-      zSql = sqlite3_mprintf("DROP TABLE %s", zTemp);
-      arExecSql(pAr, zSql);
-      sqlite3_free(zSql);
-    }
   }
   return rc;
 }
@@ -12900,17 +12209,20 @@
     cmd.p = pState;
     cmd.db = pState->db;
     if( cmd.zFile ){
-      eDbType = deduceDatabaseType(cmd.zFile, 1);
+      eDbType = deduceDatabaseType(cmd.zFile);
     }else{
       eDbType = pState->openMode;
     }
     if( eDbType==SHELL_OPEN_ZIPFILE ){
-      if( cmd.eCmd==AR_CMD_EXTRACT || cmd.eCmd==AR_CMD_LIST ){
-        if( cmd.zFile==0 ){
-          cmd.zSrcTable = sqlite3_mprintf("zip");
-        }else{
-          cmd.zSrcTable = sqlite3_mprintf("zipfile(%Q)", cmd.zFile);
-        }
+      if( cmd.zFile==0 ){
+        cmd.zSrcTable = sqlite3_mprintf("zip");
+      }else{
+        cmd.zSrcTable = sqlite3_mprintf("zipfile(%Q)", cmd.zFile);
+      }
+      if( cmd.eCmd==AR_CMD_CREATE || cmd.eCmd==AR_CMD_UPDATE ){
+        utf8_printf(stderr, "zip archives are read-only\n");
+        rc = SQLITE_ERROR;
+        goto end_ar_command;
       }
       cmd.bZip = 1;
     }else if( cmd.zFile ){
@@ -12935,12 +12247,14 @@
         goto end_ar_command;
       }
       sqlite3_fileio_init(cmd.db, 0, 0);
+#ifdef SQLITE_HAVE_ZLIB
       sqlite3_sqlar_init(cmd.db, 0, 0);
+#endif
       sqlite3_create_function(cmd.db, "shell_putsnl", 1, SQLITE_UTF8, cmd.p,
                               shellPutsFunc, 0, 0);
 
     }
-    if( cmd.zSrcTable==0 && cmd.bZip==0 ){
+    if( cmd.zSrcTable==0 ){
       if( cmd.eCmd!=AR_CMD_CREATE
        && sqlite3_table_column_metadata(cmd.db,0,"sqlar","name",0,0,0,0,0)
       ){
@@ -13333,7 +12647,7 @@
       }else if( strcmp(azArg[1],"trigger")==0 ){
         p->autoEQP = AUTOEQP_trigger;
       }else{
-        p->autoEQP = (u8)booleanValue(azArg[1]);
+        p->autoEQP = booleanValue(azArg[1]);
       }
     }else{
       raw_printf(stderr, "Usage: .eqp off|on|trigger|full\n");
@@ -13420,11 +12734,14 @@
                    callback, &data, &zErrMsg);
       data.cMode = data.mode = MODE_Insert;
       data.zDestTable = "sqlite_stat1";
-      shell_exec(p, "SELECT * FROM sqlite_stat1", &zErrMsg);
+      shell_exec(p->db, "SELECT * FROM sqlite_stat1",
+                 shell_callback, &data,&zErrMsg);
       data.zDestTable = "sqlite_stat3";
-      shell_exec(p, "SELECT * FROM sqlite_stat3", &zErrMsg);
+      shell_exec(p->db, "SELECT * FROM sqlite_stat3",
+                 shell_callback, &data,&zErrMsg);
       data.zDestTable = "sqlite_stat4";
-      shell_exec(p, "SELECT * FROM sqlite_stat4", &zErrMsg);
+      shell_exec(p->db, "SELECT * FROM sqlite_stat4",
+                 shell_callback, &data, &zErrMsg);
       raw_printf(p->out, "ANALYZE sqlite_master;\n");
     }
   }else
@@ -13905,14 +13222,12 @@
       const char *z = azArg[iName];
       if( optionMatch(z,"new") ){
         newFlag = 1;
-#ifdef SQLITE_HAVE_ZLIB
+#ifdef SQLITE_HAVE_ZIP
       }else if( optionMatch(z, "zip") ){
         p->openMode = SHELL_OPEN_ZIPFILE;
 #endif
       }else if( optionMatch(z, "append") ){
         p->openMode = SHELL_OPEN_APPENDVFS;
-      }else if( optionMatch(z, "readonly") ){
-        p->openMode = SHELL_OPEN_READONLY;
       }else if( z[0]=='-' ){
         utf8_printf(stderr, "unknown option: %s\n", z);
         rc = 1;
@@ -13969,7 +13284,6 @@
     }
     output_reset(p);
     if( zFile[0]=='-' && zFile[1]=='-' ) zFile++;
-#ifndef SQLITE_NOHAVE_SYSTEM
     if( strcmp(zFile, "-e")==0 || strcmp(zFile, "-x")==0 ){
       p->doXdgOpen = 1;
       outputModePush(p);
@@ -13984,7 +13298,6 @@
       }
       zFile = p->zTempFile;
     }
-#endif /* SQLITE_NOHAVE_SYSTEM */
     if( zFile[0]=='|' ){
 #ifdef SQLITE_OMIT_POPEN
       raw_printf(stderr, "Error: pipes are not supported in this OS\n");
@@ -14104,9 +13417,10 @@
     sqlite3_close(pSrc);
   }else
 
+
   if( c=='s' && strncmp(azArg[0], "scanstats", n)==0 ){
     if( nArg==2 ){
-      p->scanstatsOn = (u8)booleanValue(azArg[1]);
+      p->scanstatsOn = booleanValue(azArg[1]);
 #ifndef SQLITE_ENABLE_STMT_SCANSTATUS
       raw_printf(stderr, "Warning: .scanstats not available in this build.\n");
 #endif
@@ -14145,8 +13459,8 @@
       }
     }
     if( zName!=0 ){
-      int isMaster = sqlite3_strlike(zName, "sqlite_master", '\\')==0;
-      if( isMaster || sqlite3_strlike(zName,"sqlite_temp_master", '\\')==0 ){
+      int isMaster = sqlite3_strlike(zName, "sqlite_master", 0)==0;
+      if( isMaster || sqlite3_strlike(zName,"sqlite_temp_master",0)==0 ){
         char *new_argv[2], *new_colv[2];
         new_argv[0] = sqlite3_mprintf(
                       "CREATE TABLE %s (\n"
@@ -14206,18 +13520,13 @@
       appendText(&sSelect, ") WHERE ", 0);
       if( zName ){
         char *zQarg = sqlite3_mprintf("%Q", zName);
-        int bGlob = strchr(zName, '*') != 0 || strchr(zName, '?') != 0 ||
-                    strchr(zName, '[') != 0;
         if( strchr(zName, '.') ){
           appendText(&sSelect, "lower(printf('%s.%s',sname,tbl_name))", 0);
         }else{
           appendText(&sSelect, "lower(tbl_name)", 0);
         }
-        appendText(&sSelect, bGlob ? " GLOB " : " LIKE ", 0);
+        appendText(&sSelect, strchr(zName, '*') ? " GLOB " : " LIKE ", 0);
         appendText(&sSelect, zQarg, 0);
-        if( !bGlob ){
-          appendText(&sSelect, " ESCAPE '\\' ", 0);
-        }
         appendText(&sSelect, " AND ", 0);
         sqlite3_free(zQarg);
       }
@@ -14632,7 +13941,7 @@
       }else{
         zLike = z;
         bSeparate = 1;
-        if( sqlite3_strlike("sqlite\\_%", zLike, '\\')==0 ) bSchema = 1;
+        if( sqlite3_strlike("sqlite_%", zLike, 0)==0 ) bSchema = 1;
       }
     }
     if( bSchema ){
@@ -14699,12 +14008,11 @@
     if( bDebug ){
       utf8_printf(p->out, "%s\n", zSql);
     }else{
-      shell_exec(p, zSql, 0);
+      shell_exec(p->db, zSql, shell_callback, p, 0);
     }
     sqlite3_free(zSql);
   }else
 
-#ifndef SQLITE_NOHAVE_SYSTEM
   if( c=='s'
    && (strncmp(azArg[0], "shell", n)==0 || strncmp(azArg[0],"system",n)==0)
   ){
@@ -14724,7 +14032,6 @@
     sqlite3_free(zCmd);
     if( x ) raw_printf(stderr, "System command returns %d\n", x);
   }else
-#endif /* !defined(SQLITE_NOHAVE_SYSTEM) */
 
   if( c=='s' && strncmp(azArg[0], "show", n)==0 ){
     static const char *azBool[] = { "off", "on", "trigger", "full"};
@@ -14764,7 +14071,7 @@
 
   if( c=='s' && strncmp(azArg[0], "stats", n)==0 ){
     if( nArg==2 ){
-      p->statsOn = (u8)booleanValue(azArg[1]);
+      p->statsOn = booleanValue(azArg[1]);
     }else if( nArg==1 ){
       display_stats(p->db, p, 0);
     }else{
@@ -15305,16 +14612,6 @@
 }
 
 /*
-** We need a default sqlite3_complete() implementation to use in case
-** the shell is compiled with SQLITE_OMIT_COMPLETE.  The default assumes
-** any arbitrary text is a complete SQL statement.  This is not very
-** user-friendly, but it does seem to work.
-*/
-#ifdef SQLITE_OMIT_COMPLETE
-int sqlite3_complete(const char *zSql){ return 1; }
-#endif
-
-/*
 ** Return true if zSql is a complete SQL statement.  Return false if it
 ** ends in the middle of a string literal or C-style comment.
 */
@@ -15338,7 +14635,7 @@
   open_db(p, 0);
   if( ShellHasFlag(p,SHFLG_Backslash) ) resolve_backslashes(zSql);
   BEGIN_TIMER;
-  rc = shell_exec(p, zSql, &zErrMsg);
+  rc = shell_exec(p->db, zSql, shell_callback, p, &zErrMsg);
   END_TIMER;
   if( rc || zErrMsg ){
     char zPrefix[100];
@@ -15570,10 +14867,6 @@
 ** Show available command line options
 */
 static const char zOptions[] =
-#if defined(SQLITE_HAVE_ZLIB) && !defined(SQLITE_OMIT_VIRTUALTABLE)
-  "   -A ARGS...           run \".archive ARGS\" and exit\n"
-#endif
-  "   -append              append the database to the end of the file\n"
   "   -ascii               set output mode to 'ascii'\n"
   "   -bail                stop after hitting an error\n"
   "   -batch               force batch I/O\n"
@@ -15600,7 +14893,6 @@
   "   -nullvalue TEXT      set text string for NULL values. Default ''\n"
   "   -pagecache SIZE N    use N slots of SZ bytes each for page cache memory\n"
   "   -quote               set output mode to 'quote'\n"
-  "   -readonly            open the database read-only\n"
   "   -separator SEP       set output column separator. Default: '|'\n"
   "   -stats               print memory stats before each finalize\n"
   "   -version             show SQLite version\n"
@@ -15608,9 +14900,6 @@
 #ifdef SQLITE_ENABLE_VFSTRACE
   "   -vfstrace            enable tracing of all VFS calls\n"
 #endif
-#ifdef SQLITE_HAVE_ZLIB
-  "   -zip                 open the file as a ZIP Archive\n"
-#endif
 ;
 static void usage(int showDetail){
   utf8_printf(stderr,
@@ -15713,39 +15002,21 @@
   }
 #endif
   main_init(&data);
-
-  /* On Windows, we must translate command-line arguments into UTF-8.
-  ** The SQLite memory allocator subsystem has to be enabled in order to
-  ** do this.  But we want to run an sqlite3_shutdown() afterwards so that
-  ** subsequent sqlite3_config() calls will work.  So copy all results into
-  ** memory that does not come from the SQLite memory allocator.
-  */
 #if !SQLITE_SHELL_IS_UTF8
   sqlite3_initialize();
-  argv = malloc(sizeof(argv[0])*argc);
+  argv = sqlite3_malloc64(sizeof(argv[0])*argc);
   if( argv==0 ){
     raw_printf(stderr, "out of memory\n");
     exit(1);
   }
   for(i=0; i<argc; i++){
-    char *z = sqlite3_win32_unicode_to_utf8(wargv[i]);
-    int n;
-    if( z==0 ){
-      raw_printf(stderr, "out of memory\n");
-      exit(1);
-    }
-    n = (int)strlen(z);
-    argv[i] = malloc( n+1 );
+    argv[i] = sqlite3_win32_unicode_to_utf8(wargv[i]);
     if( argv[i]==0 ){
       raw_printf(stderr, "out of memory\n");
       exit(1);
     }
-    memcpy(argv[i], z, n+1);
-    sqlite3_free(z);
   }
-  sqlite3_shutdown();
 #endif
-
   assert( argc>=1 && argv && argv[0] );
   Argv0 = argv[0];
 
@@ -15865,20 +15136,12 @@
         utf8_printf(stderr, "no such VFS: \"%s\"\n", argv[i]);
         exit(1);
       }
-#ifdef SQLITE_HAVE_ZLIB
+#ifdef SQLITE_HAVE_ZIP
     }else if( strcmp(z,"-zip")==0 ){
       data.openMode = SHELL_OPEN_ZIPFILE;
 #endif
     }else if( strcmp(z,"-append")==0 ){
       data.openMode = SHELL_OPEN_APPENDVFS;
-    }else if( strcmp(z,"-readonly")==0 ){
-      data.openMode = SHELL_OPEN_READONLY;
-#if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)
-    }else if( strncmp(z, "-A",2)==0 ){
-      /* All remaining command-line arguments are passed to the ".archive"
-      ** command, so ignore them */
-      break;
-#endif
     }
   }
   if( data.zDbFilename==0 ){
@@ -15932,14 +15195,12 @@
     }else if( strcmp(z,"-csv")==0 ){
       data.mode = MODE_Csv;
       memcpy(data.colSeparator,",",2);
-#ifdef SQLITE_HAVE_ZLIB
+#ifdef SQLITE_HAVE_ZIP
     }else if( strcmp(z,"-zip")==0 ){
       data.openMode = SHELL_OPEN_ZIPFILE;
 #endif
     }else if( strcmp(z,"-append")==0 ){
       data.openMode = SHELL_OPEN_APPENDVFS;
-    }else if( strcmp(z,"-readonly")==0 ){
-      data.openMode = SHELL_OPEN_READONLY;
     }else if( strcmp(z,"-ascii")==0 ){
       data.mode = MODE_Ascii;
       sqlite3_snprintf(sizeof(data.colSeparator), data.colSeparator,
@@ -16017,7 +15278,7 @@
         if( rc && bail_on_error ) return rc==2 ? 0 : rc;
       }else{
         open_db(&data, 0);
-        rc = shell_exec(&data, z, &zErrMsg);
+        rc = shell_exec(data.db, z, shell_callback, &data, &zErrMsg);
         if( zErrMsg!=0 ){
           utf8_printf(stderr,"Error: %s\n", zErrMsg);
           if( bail_on_error ) return rc!=0 ? rc : 1;
@@ -16026,23 +15287,6 @@
           if( bail_on_error ) return rc;
         }
       }
-#if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_HAVE_ZLIB)
-    }else if( strncmp(z, "-A", 2)==0 ){
-      if( nCmd>0 ){
-        utf8_printf(stderr, "Error: cannot mix regular SQL or dot-commands"
-                            " with \"%s\"\n", z);
-        return 1;
-      }
-      open_db(&data, 0);
-      if( z[2] ){
-        argv[i] = &z[2];
-        arDotCommand(&data, argv+(i-1), argc-(i-1));
-      }else{
-        arDotCommand(&data, argv+i, argc-i);
-      }
-      readStdin = 0;
-      break;
-#endif
     }else{
       utf8_printf(stderr,"%s: Error: unknown option: %s\n", Argv0, z);
       raw_printf(stderr,"Use -help for a list of options.\n");
@@ -16062,7 +15306,7 @@
         if( rc ) return rc==2 ? 0 : rc;
       }else{
         open_db(&data, 0);
-        rc = shell_exec(&data, azCmd[i], &zErrMsg);
+        rc = shell_exec(data.db, azCmd[i], shell_callback, &data, &zErrMsg);
         if( zErrMsg!=0 ){
           utf8_printf(stderr,"Error: %s\n", zErrMsg);
           return rc!=0 ? rc : 1;
@@ -16125,8 +15369,8 @@
   data.doXdgOpen = 0;
   clearTempFile(&data);
 #if !SQLITE_SHELL_IS_UTF8
-  for(i=0; i<argc; i++) free(argv[i]);
-  free(argv);
+  for(i=0; i<argc; i++) sqlite3_free(argv[i]);
+  sqlite3_free(argv);
 #endif
   return rc;
 }
diff -r -u -d orig/sqlite3.c ./sqlite3.c
--- orig/sqlite3.c	2018-04-02 13:20:53.000000000 +0200
+++ ./sqlite3.c	2018-04-05 23:08:42.940577141 +0200
@@ -1,6 +1,6 @@
 /******************************************************************************
 ** This file is an amalgamation of many separate C source files from SQLite
-** version 3.23.0.  By combining all the individual C code files into this
+** version 3.22.0.  By combining all the individual C code files into this
 ** single large file, the entire code can be compiled as a single translation
 ** unit.  This allows many compilers to do optimizations that would not be
 ** possible if the files were compiled separately.  Performance improvements
@@ -213,7 +213,7 @@
   "ENABLE_BATCH_ATOMIC_WRITE",
 #endif
 #if SQLITE_ENABLE_CEROD
-  "ENABLE_CEROD=" CTIMEOPT_VAL(SQLITE_ENABLE_CEROD),
+  "ENABLE_CEROD",
 #endif
 #if SQLITE_ENABLE_COLUMN_METADATA
   "ENABLE_COLUMN_METADATA",
@@ -1147,9 +1147,9 @@
 ** [sqlite3_libversion_number()], [sqlite3_sourceid()],
 ** [sqlite_version()] and [sqlite_source_id()].
 */
-#define SQLITE_VERSION        "3.23.0"
-#define SQLITE_VERSION_NUMBER 3023000
-#define SQLITE_SOURCE_ID      "2018-04-02 11:04:16 736b53f57f70b23172c30880186dce7ad9baa3b74e3838cae5847cffb98f5cd2"
+#define SQLITE_VERSION        "3.22.0"
+#define SQLITE_VERSION_NUMBER 3022000
+#define SQLITE_SOURCE_ID      "2018-01-22 18:45:57 0c55d179733b46d8d0ba4d88e01a25e10677046ee3da1d5b1581e86726f2171d"
 
 /*
 ** CAPI3REF: Run-Time Library Version Numbers
@@ -2088,12 +2088,6 @@
 ** so that all subsequent write operations are independent.
 ** ^SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without
 ** a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].
-**
-** <li>[[SQLITE_FCNTL_LOCK_TIMEOUT]]
-** The [SQLITE_FCNTL_LOCK_TIMEOUT] opcode causes attempts to obtain
-** a file lock using the xLock or xShmLock methods of the VFS to wait
-** for up to M milliseconds before failing, where M is the single 
-** unsigned integer parameter.
 ** </ul>
 */
 #define SQLITE_FCNTL_LOCKSTATE               1
@@ -2128,7 +2122,6 @@
 #define SQLITE_FCNTL_BEGIN_ATOMIC_WRITE     31
 #define SQLITE_FCNTL_COMMIT_ATOMIC_WRITE    32
 #define SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE  33
-#define SQLITE_FCNTL_LOCK_TIMEOUT           34
 
 /* deprecated names */
 #define SQLITE_GET_LOCKPROXYFILE      SQLITE_FCNTL_GET_LOCKPROXYFILE
@@ -3085,13 +3078,11 @@
 ** connections at all to the database. If so, it performs a checkpoint 
 ** operation before closing the connection. This option may be used to
 ** override this behaviour. The first parameter passed to this operation
-** is an integer - positive to disable checkpoints-on-close, or zero (the
-** default) to enable them, and negative to leave the setting unchanged.
-** The second parameter is a pointer to an integer
+** is an integer - non-zero to disable checkpoints-on-close, or zero (the
+** default) to enable them. The second parameter is a pointer to an integer
 ** into which is written 0 or 1 to indicate whether checkpoints-on-close
 ** have been disabled - 0 if they are not disabled, 1 if they are.
 ** </dd>
-**
 ** <dt>SQLITE_DBCONFIG_ENABLE_QPSG</dt>
 ** <dd>^(The SQLITE_DBCONFIG_ENABLE_QPSG option activates or deactivates
 ** the [query planner stability guarantee] (QPSG).  When the QPSG is active,
@@ -3101,20 +3092,13 @@
 ** slower.  But the QPSG has the advantage of more predictable behavior.  With
 ** the QPSG active, SQLite will always use the same query plan in the field as
 ** was used during testing in the lab.
-** The first argument to this setting is an integer which is 0 to disable 
-** the QPSG, positive to enable QPSG, or negative to leave the setting
-** unchanged. The second parameter is a pointer to an integer into which
-** is written 0 or 1 to indicate whether the QPSG is disabled or enabled
-** following this call.
 ** </dd>
-**
 ** <dt>SQLITE_DBCONFIG_TRIGGER_EQP</dt>
 ** <dd> By default, the output of EXPLAIN QUERY PLAN commands does not 
 ** include output for any operations performed by trigger programs. This
 ** option is used to set or clear (the default) a flag that governs this
 ** behavior. The first parameter passed to this operation is an integer -
-** positive to enable output for trigger programs, or zero to disable it,
-** or negative to leave the setting unchanged.
+** non-zero to enable output for trigger programs, or zero to disable it.
 ** The second parameter is a pointer to an integer into which is written 
 ** 0 or 1 to indicate whether output-for-triggers has been disabled - 0 if 
 ** it is not disabled, 1 if it is.  
@@ -3536,16 +3520,16 @@
 **
 ** These routines are work-alikes of the "printf()" family of functions
 ** from the standard C library.
-** These routines understand most of the common formatting options from
-** the standard library printf() 
-** plus some additional non-standard formats ([%q], [%Q], [%w], and [%z]).
-** See the [built-in printf()] documentation for details.
+** These routines understand most of the common K&R formatting options,
+** plus some additional non-standard formats, detailed below.
+** Note that some of the more obscure formatting options from recent
+** C-library standards are omitted from this implementation.
 **
 ** ^The sqlite3_mprintf() and sqlite3_vmprintf() routines write their
-** results into memory obtained from [sqlite3_malloc64()].
+** results into memory obtained from [sqlite3_malloc()].
 ** The strings returned by these two routines should be
 ** released by [sqlite3_free()].  ^Both routines return a
-** NULL pointer if [sqlite3_malloc64()] is unable to allocate enough
+** NULL pointer if [sqlite3_malloc()] is unable to allocate enough
 ** memory to hold the resulting string.
 **
 ** ^(The sqlite3_snprintf() routine is similar to "snprintf()" from
@@ -3569,7 +3553,71 @@
 **
 ** ^The sqlite3_vsnprintf() routine is a varargs version of sqlite3_snprintf().
 **
-** See also:  [built-in printf()], [printf() SQL function]
+** These routines all implement some additional formatting
+** options that are useful for constructing SQL statements.
+** All of the usual printf() formatting options apply.  In addition, there
+** is are "%q", "%Q", "%w" and "%z" options.
+**
+** ^(The %q option works like %s in that it substitutes a nul-terminated
+** string from the argument list.  But %q also doubles every '\'' character.
+** %q is designed for use inside a string literal.)^  By doubling each '\''
+** character it escapes that character and allows it to be inserted into
+** the string.
+**
+** For example, assume the string variable zText contains text as follows:
+**
+** <blockquote><pre>
+**  char *zText = "It's a happy day!";
+** </pre></blockquote>
+**
+** One can use this text in an SQL statement as follows:
+**
+** <blockquote><pre>
+**  char *zSQL = sqlite3_mprintf("INSERT INTO table VALUES('%q')", zText);
+**  sqlite3_exec(db, zSQL, 0, 0, 0);
+**  sqlite3_free(zSQL);
+** </pre></blockquote>
+**
+** Because the %q format string is used, the '\'' character in zText
+** is escaped and the SQL generated is as follows:
+**
+** <blockquote><pre>
+**  INSERT INTO table1 VALUES('It''s a happy day!')
+** </pre></blockquote>
+**
+** This is correct.  Had we used %s instead of %q, the generated SQL
+** would have looked like this:
+**
+** <blockquote><pre>
+**  INSERT INTO table1 VALUES('It's a happy day!');
+** </pre></blockquote>
+**
+** This second example is an SQL syntax error.  As a general rule you should
+** always use %q instead of %s when inserting text into a string literal.
+**
+** ^(The %Q option works like %q except it also adds single quotes around
+** the outside of the total string.  Additionally, if the parameter in the
+** argument list is a NULL pointer, %Q substitutes the text "NULL" (without
+** single quotes).)^  So, for example, one could say:
+**
+** <blockquote><pre>
+**  char *zSQL = sqlite3_mprintf("INSERT INTO table VALUES(%Q)", zText);
+**  sqlite3_exec(db, zSQL, 0, 0, 0);
+**  sqlite3_free(zSQL);
+** </pre></blockquote>
+**
+** The code above will render a correct SQL statement in the zSQL
+** variable even if the zText variable is a NULL pointer.
+**
+** ^(The "%w" formatting option is like "%q" except that it expects to
+** be contained within double-quotes instead of single quotes, and it
+** escapes the double-quote character instead of the single-quote
+** character.)^  The "%w" formatting option is intended for safely inserting
+** table and column names into a constructed SQL statement.
+**
+** ^(The "%z" formatting option works like "%s" but with the
+** addition that after the string has been read and copied into
+** the result, [sqlite3_free()] is called on the input string.)^
 */
 SQLITE_API char *sqlite3_mprintf(const char*,...);
 SQLITE_API char *sqlite3_vmprintf(const char*, va_list);
@@ -4635,13 +4683,13 @@
 ** or [GLOB] operator or if the parameter is compared to an indexed column
 ** and the [SQLITE_ENABLE_STAT3] compile-time option is enabled.
 ** </li>
-** </ol>
 **
 ** <p>^sqlite3_prepare_v3() differs from sqlite3_prepare_v2() only in having
 ** the extra prepFlags parameter, which is a bit array consisting of zero or
 ** more of the [SQLITE_PREPARE_PERSISTENT|SQLITE_PREPARE_*] flags.  ^The
 ** sqlite3_prepare_v2() interface works exactly the same as
 ** sqlite3_prepare_v3() with a zero prepFlags parameter.
+** </ol>
 */
 SQLITE_API int sqlite3_prepare(
   sqlite3 *db,            /* Database handle */
@@ -8270,15 +8318,6 @@
 ** highwater mark associated with SQLITE_DBSTATUS_CACHE_WRITE is always 0.
 ** </dd>
 **
-** [[SQLITE_DBSTATUS_CACHE_SPILL]] ^(<dt>SQLITE_DBSTATUS_CACHE_SPILL</dt>
-** <dd>This parameter returns the number of dirty cache entries that have
-** been written to disk in the middle of a transaction due to the page
-** cache overflowing. Transactions are more efficient if they are written
-** to disk all at once. When pages spill mid-transaction, that introduces
-** additional overhead. This parameter can be used help identify
-** inefficiencies that can be resolve by increasing the cache size.
-** </dd>
-**
 ** [[SQLITE_DBSTATUS_DEFERRED_FKS]] ^(<dt>SQLITE_DBSTATUS_DEFERRED_FKS</dt>
 ** <dd>This parameter returns zero for the current value if and only if
 ** all foreign key constraints (deferred or immediate) have been
@@ -8298,8 +8337,7 @@
 #define SQLITE_DBSTATUS_CACHE_WRITE          9
 #define SQLITE_DBSTATUS_DEFERRED_FKS        10
 #define SQLITE_DBSTATUS_CACHE_USED_SHARED   11
-#define SQLITE_DBSTATUS_CACHE_SPILL         12
-#define SQLITE_DBSTATUS_MAX                 12   /* Largest defined DBSTATUS */
+#define SQLITE_DBSTATUS_MAX                 11   /* Largest defined DBSTATUS */
 
 
 /*
@@ -9780,128 +9818,6 @@
 SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_recover(sqlite3 *db, const char *zDb);
 
 /*
-** CAPI3REF: Serialize a database
-**
-** The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory
-** that is a serialization of the S database on [database connection] D.
-** If P is not a NULL pointer, then the size of the database in bytes
-** is written into *P.
-**
-** For an ordinary on-disk database file, the serialization is just a
-** copy of the disk file.  For an in-memory database or a "TEMP" database,
-** the serialization is the same sequence of bytes which would be written
-** to disk if that database where backed up to disk.
-**
-** The usual case is that sqlite3_serialize() copies the serialization of
-** the database into memory obtained from [sqlite3_malloc64()] and returns
-** a pointer to that memory.  The caller is responsible for freeing the
-** returned value to avoid a memory leak.  However, if the F argument
-** contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocations
-** are made, and the sqlite3_serialize() function will return a pointer
-** to the contiguous memory representation of the database that SQLite
-** is currently using for that database, or NULL if the no such contiguous
-** memory representation of the database exists.  A contiguous memory
-** representation of the database will usually only exist if there has
-** been a prior call to [sqlite3_deserialize(D,S,...)] with the same
-** values of D and S.
-** The size of the database is written into *P even if the 
-** SQLITE_SERIALIZE_NOCOPY bit is set but no contigious copy
-** of the database exists.
-**
-** A call to sqlite3_serialize(D,S,P,F) might return NULL even if the
-** SQLITE_SERIALIZE_NOCOPY bit is omitted from argument F if a memory
-** allocation error occurs.
-**
-** This interface is only available if SQLite is compiled with the
-** [SQLITE_ENABLE_DESERIALIZE] option.
-*/
-SQLITE_API unsigned char *sqlite3_serialize(
-  sqlite3 *db,           /* The database connection */
-  const char *zSchema,   /* Which DB to serialize. ex: "main", "temp", ... */
-  sqlite3_int64 *piSize, /* Write size of the DB here, if not NULL */
-  unsigned int mFlags    /* Zero or more SQLITE_SERIALIZE_* flags */
-);
-
-/*
-** CAPI3REF: Flags for sqlite3_serialize
-**
-** Zero or more of the following constants can be OR-ed together for
-** the F argument to [sqlite3_serialize(D,S,P,F)].
-**
-** SQLITE_SERIALIZE_NOCOPY means that [sqlite3_serialize()] will return
-** a pointer to contiguous in-memory database that it is currently using,
-** without making a copy of the database.  If SQLite is not currently using
-** a contiguous in-memory database, then this option causes
-** [sqlite3_serialize()] to return a NULL pointer.  SQLite will only be
-** using a contiguous in-memory database if it has been initialized by a
-** prior call to [sqlite3_deserialize()].
-*/
-#define SQLITE_SERIALIZE_NOCOPY 0x001   /* Do no memory allocations */
-
-/*
-** CAPI3REF: Deserialize a database
-**
-** The sqlite3_deserialize(D,S,P,N,M,F) interface causes the 
-** [database connection] D to disconnect from database S and then
-** reopen S as an in-memory database based on the serialization contained
-** in P.  The serialized database P is N bytes in size.  M is the size of
-** the buffer P, which might be larger than N.  If M is larger than N, and
-** the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite is
-** permitted to add content to the in-memory database as long as the total
-** size does not exceed M bytes.
-**
-** If the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in F, then SQLite will
-** invoke sqlite3_free() on the serialization buffer when the database
-** connection closes.  If the SQLITE_DESERIALIZE_RESIZEABLE bit is set, then
-** SQLite will try to increase the buffer size using sqlite3_realloc64()
-** if writes on the database cause it to grow larger than M bytes.
-**
-** The sqlite3_deserialize() interface will fail with SQLITE_BUSY if the
-** database is currently in a read transaction or is involved in a backup
-** operation.
-**
-** If sqlite3_deserialize(D,S,P,N,M,F) fails for any reason and if the 
-** SQLITE_DESERIALIZE_FREEONCLOSE bit is set in argument F, then
-** [sqlite3_free()] is invoked on argument P prior to returning.
-**
-** This interface is only available if SQLite is compiled with the
-** [SQLITE_ENABLE_DESERIALIZE] option.
-*/
-SQLITE_API int sqlite3_deserialize(
-  sqlite3 *db,            /* The database connection */
-  const char *zSchema,    /* Which DB to reopen with the deserialization */
-  unsigned char *pData,   /* The serialized database content */
-  sqlite3_int64 szDb,     /* Number bytes in the deserialization */
-  sqlite3_int64 szBuf,    /* Total size of buffer pData[] */
-  unsigned mFlags         /* Zero or more SQLITE_DESERIALIZE_* flags */
-);
-
-/*
-** CAPI3REF: Flags for sqlite3_deserialize()
-**
-** The following are allowed values for 6th argument (the F argument) to
-** the [sqlite3_deserialize(D,S,P,N,M,F)] interface.
-**
-** The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization
-** in the P argument is held in memory obtained from [sqlite3_malloc64()]
-** and that SQLite should take ownership of this memory and automatically
-** free it when it has finished using it.  Without this flag, the caller
-** is resposible for freeing any dynamically allocated memory.
-**
-** The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to
-** grow the size of the database using calls to [sqlite3_realloc64()].  This
-** flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used.
-** Without this flag, the deserialized database cannot increase in size beyond
-** the number of bytes specified by the M parameter.
-**
-** The SQLITE_DESERIALIZE_READONLY flag means that the deserialized database
-** should be treated as read-only.
-*/
-#define SQLITE_DESERIALIZE_FREEONCLOSE 1 /* Call sqlite3_free() on close */
-#define SQLITE_DESERIALIZE_RESIZEABLE  2 /* Resize using sqlite3_realloc64() */
-#define SQLITE_DESERIALIZE_READONLY    4 /* Database is read-only */
-
-/*
 ** Undo the hack that converts floating point types to integer for
 ** builds on processors without floating point support.
 */
@@ -10048,23 +9964,16 @@
 
 /*
 ** CAPI3REF: Session Object Handle
-**
-** An instance of this object is a [session] that can be used to
-** record changes to a database.
 */
 typedef struct sqlite3_session sqlite3_session;
 
 /*
 ** CAPI3REF: Changeset Iterator Handle
-**
-** An instance of this object acts as a cursor for iterating
-** over the elements of a [changeset] or [patchset].
 */
 typedef struct sqlite3_changeset_iter sqlite3_changeset_iter;
 
 /*
 ** CAPI3REF: Create A New Session Object
-** CONSTRUCTOR: sqlite3_session
 **
 ** Create a new session object attached to database handle db. If successful,
 ** a pointer to the new object is written to *ppSession and SQLITE_OK is
@@ -10101,7 +10010,6 @@
 
 /*
 ** CAPI3REF: Delete A Session Object
-** DESTRUCTOR: sqlite3_session
 **
 ** Delete a session object previously allocated using 
 ** [sqlite3session_create()]. Once a session object has been deleted, the
@@ -10117,7 +10025,6 @@
 
 /*
 ** CAPI3REF: Enable Or Disable A Session Object
-** METHOD: sqlite3_session
 **
 ** Enable or disable the recording of changes by a session object. When
 ** enabled, a session object records changes made to the database. When
@@ -10137,7 +10044,6 @@
 
 /*
 ** CAPI3REF: Set Or Clear the Indirect Change Flag
-** METHOD: sqlite3_session
 **
 ** Each change recorded by a session object is marked as either direct or
 ** indirect. A change is marked as indirect if either:
@@ -10167,7 +10073,6 @@
 
 /*
 ** CAPI3REF: Attach A Table To A Session Object
-** METHOD: sqlite3_session
 **
 ** If argument zTab is not NULL, then it is the name of a table to attach
 ** to the session object passed as the first argument. All subsequent changes 
@@ -10230,7 +10135,6 @@
 
 /*
 ** CAPI3REF: Set a table filter on a Session Object.
-** METHOD: sqlite3_session
 **
 ** The second argument (xFilter) is the "filter callback". For changes to rows 
 ** in tables that are not attached to the Session object, the filter is called
@@ -10249,7 +10153,6 @@
 
 /*
 ** CAPI3REF: Generate A Changeset From A Session Object
-** METHOD: sqlite3_session
 **
 ** Obtain a changeset containing changes to the tables attached to the 
 ** session object passed as the first argument. If successful, 
@@ -10359,8 +10262,7 @@
 );
 
 /*
-** CAPI3REF: Load The Difference Between Tables Into A Session
-** METHOD: sqlite3_session
+** CAPI3REF: Load The Difference Between Tables Into A Session 
 **
 ** If it is not already attached to the session object passed as the first
 ** argument, this function attaches table zTbl in the same manner as the
@@ -10425,7 +10327,6 @@
 
 /*
 ** CAPI3REF: Generate A Patchset From A Session Object
-** METHOD: sqlite3_session
 **
 ** The differences between a patchset and a changeset are that:
 **
@@ -10477,7 +10378,6 @@
 
 /*
 ** CAPI3REF: Create An Iterator To Traverse A Changeset 
-** CONSTRUCTOR: sqlite3_changeset_iter
 **
 ** Create an iterator used to iterate through the contents of a changeset.
 ** If successful, *pp is set to point to the iterator handle and SQLITE_OK
@@ -10518,7 +10418,6 @@
 
 /*
 ** CAPI3REF: Advance A Changeset Iterator
-** METHOD: sqlite3_changeset_iter
 **
 ** This function may only be used with iterators created by function
 ** [sqlite3changeset_start()]. If it is called on an iterator passed to
@@ -10543,7 +10442,6 @@
 
 /*
 ** CAPI3REF: Obtain The Current Operation From A Changeset Iterator
-** METHOD: sqlite3_changeset_iter
 **
 ** The pIter argument passed to this function may either be an iterator
 ** passed to a conflict-handler by [sqlite3changeset_apply()], or an iterator
@@ -10578,7 +10476,6 @@
 
 /*
 ** CAPI3REF: Obtain The Primary Key Definition Of A Table
-** METHOD: sqlite3_changeset_iter
 **
 ** For each modified table, a changeset includes the following:
 **
@@ -10610,7 +10507,6 @@
 
 /*
 ** CAPI3REF: Obtain old.* Values From A Changeset Iterator
-** METHOD: sqlite3_changeset_iter
 **
 ** The pIter argument passed to this function may either be an iterator
 ** passed to a conflict-handler by [sqlite3changeset_apply()], or an iterator
@@ -10641,7 +10537,6 @@
 
 /*
 ** CAPI3REF: Obtain new.* Values From A Changeset Iterator
-** METHOD: sqlite3_changeset_iter
 **
 ** The pIter argument passed to this function may either be an iterator
 ** passed to a conflict-handler by [sqlite3changeset_apply()], or an iterator
@@ -10675,7 +10570,6 @@
 
 /*
 ** CAPI3REF: Obtain Conflicting Row Values From A Changeset Iterator
-** METHOD: sqlite3_changeset_iter
 **
 ** This function should only be used with iterator objects passed to a
 ** conflict-handler callback by [sqlite3changeset_apply()] with either
@@ -10703,7 +10597,6 @@
 
 /*
 ** CAPI3REF: Determine The Number Of Foreign Key Constraint Violations
-** METHOD: sqlite3_changeset_iter
 **
 ** This function may only be called with an iterator passed to an
 ** SQLITE_CHANGESET_FOREIGN_KEY conflict handler callback. In this case
@@ -10720,7 +10613,6 @@
 
 /*
 ** CAPI3REF: Finalize A Changeset Iterator
-** METHOD: sqlite3_changeset_iter
 **
 ** This function is used to finalize an iterator allocated with
 ** [sqlite3changeset_start()].
@@ -10737,7 +10629,6 @@
 ** to that error is returned by this function. Otherwise, SQLITE_OK is
 ** returned. This is to allow the following pattern (pseudo-code):
 **
-** <pre>
 **   sqlite3changeset_start();
 **   while( SQLITE_ROW==sqlite3changeset_next() ){
 **     // Do something with change.
@@ -10746,7 +10637,6 @@
 **   if( rc!=SQLITE_OK ){
 **     // An error has occurred 
 **   }
-** </pre>
 */
 SQLITE_API int sqlite3changeset_finalize(sqlite3_changeset_iter *pIter);
 
@@ -10794,7 +10684,6 @@
 ** sqlite3_changegroup object. Calling it produces similar results as the
 ** following code fragment:
 **
-** <pre>
 **   sqlite3_changegroup *pGrp;
 **   rc = sqlite3_changegroup_new(&pGrp);
 **   if( rc==SQLITE_OK ) rc = sqlite3changegroup_add(pGrp, nA, pA);
@@ -10805,7 +10694,6 @@
 **     *ppOut = 0;
 **     *pnOut = 0;
 **   }
-** </pre>
 **
 ** Refer to the sqlite3_changegroup documentation below for details.
 */
@@ -10821,15 +10709,11 @@
 
 /*
 ** CAPI3REF: Changegroup Handle
-**
-** A changegroup is an object used to combine two or more 
-** [changesets] or [patchsets]
 */
 typedef struct sqlite3_changegroup sqlite3_changegroup;
 
 /*
 ** CAPI3REF: Create A New Changegroup Object
-** CONSTRUCTOR: sqlite3_changegroup
 **
 ** An sqlite3_changegroup object is used to combine two or more changesets
 ** (or patchsets) into a single changeset (or patchset). A single changegroup
@@ -10867,7 +10751,6 @@
 
 /*
 ** CAPI3REF: Add A Changeset To A Changegroup
-** METHOD: sqlite3_changegroup
 **
 ** Add all changes within the changeset (or patchset) in buffer pData (size
 ** nData bytes) to the changegroup. 
@@ -10945,7 +10828,6 @@
 
 /*
 ** CAPI3REF: Obtain A Composite Changeset From A Changegroup
-** METHOD: sqlite3_changegroup
 **
 ** Obtain a buffer containing a changeset (or patchset) representing the
 ** current contents of the changegroup. If the inputs to the changegroup
@@ -10976,25 +10858,25 @@
 
 /*
 ** CAPI3REF: Delete A Changegroup Object
-** DESTRUCTOR: sqlite3_changegroup
 */
 SQLITE_API void sqlite3changegroup_delete(sqlite3_changegroup*);
 
 /*
 ** CAPI3REF: Apply A Changeset To A Database
 **
-** Apply a changeset or patchset to a database. These functions attempt to
-** update the "main" database attached to handle db with the changes found in
-** the changeset passed via the second and third arguments. 
+** Apply a changeset to a database. This function attempts to update the
+** "main" database attached to handle db with the changes found in the
+** changeset passed via the second and third arguments.
 **
-** The fourth argument (xFilter) passed to these functions is the "filter
+** The fourth argument (xFilter) passed to this function is the "filter
 ** callback". If it is not NULL, then for each table affected by at least one
 ** change in the changeset, the filter callback is invoked with
 ** the table name as the second argument, and a copy of the context pointer
-** passed as the sixth argument as the first. If the "filter callback"
-** returns zero, then no attempt is made to apply any changes to the table.
-** Otherwise, if the return value is non-zero or the xFilter argument to
-** is NULL, all changes related to the table are attempted.
+** passed as the sixth argument to this function as the first. If the "filter
+** callback" returns zero, then no attempt is made to apply any changes to 
+** the table. Otherwise, if the return value is non-zero or the xFilter
+** argument to this function is NULL, all changes related to the table are
+** attempted.
 **
 ** For each table that is not excluded by the filter callback, this function 
 ** tests that the target database contains a compatible table. A table is 
@@ -11039,7 +10921,7 @@
 **
 ** <dl>
 ** <dt>DELETE Changes<dd>
-**   For each DELETE change, the function checks if the target database 
+**   For each DELETE change, this function checks if the target database 
 **   contains a row with the same primary key value (or values) as the 
 **   original row values stored in the changeset. If it does, and the values 
 **   stored in all non-primary key columns also match the values stored in 
@@ -11084,7 +10966,7 @@
 **   [SQLITE_CHANGESET_REPLACE].
 **
 ** <dt>UPDATE Changes<dd>
-**   For each UPDATE change, the function checks if the target database 
+**   For each UPDATE change, this function checks if the target database 
 **   contains a row with the same primary key value (or values) as the 
 **   original row values stored in the changeset. If it does, and the values 
 **   stored in all modified non-primary key columns also match the values
@@ -11115,21 +10997,11 @@
 ** This can be used to further customize the applications conflict
 ** resolution strategy.
 **
-** All changes made by these functions are enclosed in a savepoint transaction.
+** All changes made by this function are enclosed in a savepoint transaction.
 ** If any other error (aside from a constraint failure when attempting to
 ** write to the target database) occurs, then the savepoint transaction is
 ** rolled back, restoring the target database to its original state, and an 
 ** SQLite error code returned.
-**
-** If the output parameters (ppRebase) and (pnRebase) are non-NULL and
-** the input is a changeset (not a patchset), then sqlite3changeset_apply_v2()
-** may set (*ppRebase) to point to a "rebase" that may be used with the 
-** sqlite3_rebaser APIs buffer before returning. In this case (*pnRebase)
-** is set to the size of the buffer in bytes. It is the responsibility of the
-** caller to eventually free any such buffer using sqlite3_free(). The buffer
-** is only allocated and populated if one or more conflicts were encountered
-** while applying the patchset. See comments surrounding the sqlite3_rebaser
-** APIs for further details.
 */
 SQLITE_API int sqlite3changeset_apply(
   sqlite3 *db,                    /* Apply change to "main" db of this handle */
@@ -11146,22 +11018,6 @@
   ),
   void *pCtx                      /* First argument passed to xConflict */
 );
-SQLITE_API int sqlite3changeset_apply_v2(
-  sqlite3 *db,                    /* Apply change to "main" db of this handle */
-  int nChangeset,                 /* Size of changeset in bytes */
-  void *pChangeset,               /* Changeset blob */
-  int(*xFilter)(
-    void *pCtx,                   /* Copy of sixth arg to _apply() */
-    const char *zTab              /* Table name */
-  ),
-  int(*xConflict)(
-    void *pCtx,                   /* Copy of sixth arg to _apply() */
-    int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */
-    sqlite3_changeset_iter *p     /* Handle describing change and conflict */
-  ),
-  void *pCtx,                     /* First argument passed to xConflict */
-  void **ppRebase, int *pnRebase
-);
 
 /* 
 ** CAPI3REF: Constants Passed To The Conflict Handler
@@ -11259,161 +11115,6 @@
 #define SQLITE_CHANGESET_REPLACE    1
 #define SQLITE_CHANGESET_ABORT      2
 
-/* 
-** CAPI3REF: Rebasing changesets
-** EXPERIMENTAL
-**
-** Suppose there is a site hosting a database in state S0. And that
-** modifications are made that move that database to state S1 and a
-** changeset recorded (the "local" changeset). Then, a changeset based
-** on S0 is received from another site (the "remote" changeset) and 
-** applied to the database. The database is then in state 
-** (S1+"remote"), where the exact state depends on any conflict
-** resolution decisions (OMIT or REPLACE) made while applying "remote".
-** Rebasing a changeset is to update it to take those conflict 
-** resolution decisions into account, so that the same conflicts
-** do not have to be resolved elsewhere in the network. 
-**
-** For example, if both the local and remote changesets contain an
-** INSERT of the same key on "CREATE TABLE t1(a PRIMARY KEY, b)":
-**
-**   local:  INSERT INTO t1 VALUES(1, 'v1');
-**   remote: INSERT INTO t1 VALUES(1, 'v2');
-**
-** and the conflict resolution is REPLACE, then the INSERT change is
-** removed from the local changeset (it was overridden). Or, if the
-** conflict resolution was "OMIT", then the local changeset is modified
-** to instead contain:
-**
-**           UPDATE t1 SET b = 'v2' WHERE a=1;
-**
-** Changes within the local changeset are rebased as follows:
-**
-** <dl>
-** <dt>Local INSERT<dd>
-**   This may only conflict with a remote INSERT. If the conflict 
-**   resolution was OMIT, then add an UPDATE change to the rebased
-**   changeset. Or, if the conflict resolution was REPLACE, add
-**   nothing to the rebased changeset.
-**
-** <dt>Local DELETE<dd>
-**   This may conflict with a remote UPDATE or DELETE. In both cases the
-**   only possible resolution is OMIT. If the remote operation was a
-**   DELETE, then add no change to the rebased changeset. If the remote
-**   operation was an UPDATE, then the old.* fields of change are updated
-**   to reflect the new.* values in the UPDATE.
-**
-** <dt>Local UPDATE<dd>
-**   This may conflict with a remote UPDATE or DELETE. If it conflicts
-**   with a DELETE, and the conflict resolution was OMIT, then the update
-**   is changed into an INSERT. Any undefined values in the new.* record
-**   from the update change are filled in using the old.* values from
-**   the conflicting DELETE. Or, if the conflict resolution was REPLACE,
-**   the UPDATE change is simply omitted from the rebased changeset.
-**
-**   If conflict is with a remote UPDATE and the resolution is OMIT, then
-**   the old.* values are rebased using the new.* values in the remote
-**   change. Or, if the resolution is REPLACE, then the change is copied
-**   into the rebased changeset with updates to columns also updated by
-**   the conflicting remote UPDATE removed. If this means no columns would 
-**   be updated, the change is omitted.
-** </dl>
-**
-** A local change may be rebased against multiple remote changes 
-** simultaneously. If a single key is modified by multiple remote 
-** changesets, they are combined as follows before the local changeset
-** is rebased:
-**
-** <ul>
-**    <li> If there has been one or more REPLACE resolutions on a
-**         key, it is rebased according to a REPLACE.
-**
-**    <li> If there have been no REPLACE resolutions on a key, then
-**         the local changeset is rebased according to the most recent
-**         of the OMIT resolutions.
-** </ul>
-**
-** Note that conflict resolutions from multiple remote changesets are 
-** combined on a per-field basis, not per-row. This means that in the 
-** case of multiple remote UPDATE operations, some fields of a single 
-** local change may be rebased for REPLACE while others are rebased for 
-** OMIT.
-**
-** In order to rebase a local changeset, the remote changeset must first
-** be applied to the local database using sqlite3changeset_apply_v2() and
-** the buffer of rebase information captured. Then:
-**
-** <ol>
-**   <li> An sqlite3_rebaser object is created by calling 
-**        sqlite3rebaser_create().
-**   <li> The new object is configured with the rebase buffer obtained from
-**        sqlite3changeset_apply_v2() by calling sqlite3rebaser_configure().
-**        If the local changeset is to be rebased against multiple remote
-**        changesets, then sqlite3rebaser_configure() should be called
-**        multiple times, in the same order that the multiple
-**        sqlite3changeset_apply_v2() calls were made.
-**   <li> Each local changeset is rebased by calling sqlite3rebaser_rebase().
-**   <li> The sqlite3_rebaser object is deleted by calling
-**        sqlite3rebaser_delete().
-** </ol>
-*/
-typedef struct sqlite3_rebaser sqlite3_rebaser;
-
-/*
-** CAPI3REF: Create a changeset rebaser object.
-** EXPERIMENTAL
-**
-** Allocate a new changeset rebaser object. If successful, set (*ppNew) to
-** point to the new object and return SQLITE_OK. Otherwise, if an error
-** occurs, return an SQLite error code (e.g. SQLITE_NOMEM) and set (*ppNew) 
-** to NULL. 
-*/
-SQLITE_API int sqlite3rebaser_create(sqlite3_rebaser **ppNew);
-
-/*
-** CAPI3REF: Configure a changeset rebaser object.
-** EXPERIMENTAL
-**
-** Configure the changeset rebaser object to rebase changesets according
-** to the conflict resolutions described by buffer pRebase (size nRebase
-** bytes), which must have been obtained from a previous call to
-** sqlite3changeset_apply_v2().
-*/
-SQLITE_API int sqlite3rebaser_configure(
-  sqlite3_rebaser*, 
-  int nRebase, const void *pRebase
-); 
-
-/*
-** CAPI3REF: Rebase a changeset
-** EXPERIMENTAL
-**
-** Argument pIn must point to a buffer containing a changeset nIn bytes
-** in size. This function allocates and populates a buffer with a copy
-** of the changeset rebased rebased according to the configuration of the
-** rebaser object passed as the first argument. If successful, (*ppOut)
-** is set to point to the new buffer containing the rebased changset and 
-** (*pnOut) to its size in bytes and SQLITE_OK returned. It is the
-** responsibility of the caller to eventually free the new buffer using
-** sqlite3_free(). Otherwise, if an error occurs, (*ppOut) and (*pnOut)
-** are set to zero and an SQLite error code returned.
-*/
-SQLITE_API int sqlite3rebaser_rebase(
-  sqlite3_rebaser*,
-  int nIn, const void *pIn, 
-  int *pnOut, void **ppOut 
-);
-
-/*
-** CAPI3REF: Delete a changeset rebaser object.
-** EXPERIMENTAL
-**
-** Delete the changeset rebaser object and all associated resources. There
-** should be one call to this function for each successful invocation
-** of sqlite3rebaser_create().
-*/
-SQLITE_API void sqlite3rebaser_delete(sqlite3_rebaser *p); 
-
 /*
 ** CAPI3REF: Streaming Versions of API functions.
 **
@@ -11518,22 +11219,6 @@
   ),
   void *pCtx                      /* First argument passed to xConflict */
 );
-SQLITE_API int sqlite3changeset_apply_v2_strm(
-  sqlite3 *db,                    /* Apply change to "main" db of this handle */
-  int (*xInput)(void *pIn, void *pData, int *pnData), /* Input function */
-  void *pIn,                                          /* First arg for xInput */
-  int(*xFilter)(
-    void *pCtx,                   /* Copy of sixth arg to _apply() */
-    const char *zTab              /* Table name */
-  ),
-  int(*xConflict)(
-    void *pCtx,                   /* Copy of sixth arg to _apply() */
-    int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */
-    sqlite3_changeset_iter *p     /* Handle describing change and conflict */
-  ),
-  void *pCtx,                     /* First argument passed to xConflict */
-  void **ppRebase, int *pnRebase
-);
 SQLITE_API int sqlite3changeset_concat_strm(
   int (*xInputA)(void *pIn, void *pData, int *pnData),
   void *pInA,
@@ -11571,13 +11256,6 @@
     int (*xOutput)(void *pOut, const void *pData, int nData), 
     void *pOut
 );
-SQLITE_API int sqlite3rebaser_rebase_strm(
-  sqlite3_rebaser *pRebaser,
-  int (*xInput)(void *pIn, void *pData, int *pnData),
-  void *pIn,
-  int (*xOutput)(void *pOut, const void *pData, int nData),
-  void *pOut
-);
 
 
 /*
@@ -12995,25 +12673,23 @@
 #define TK_INDEX                          140
 #define TK_ALTER                          141
 #define TK_ADD                            142
-#define TK_TRUEFALSE                      143
-#define TK_ISNOT                          144
-#define TK_FUNCTION                       145
-#define TK_COLUMN                         146
-#define TK_AGG_FUNCTION                   147
-#define TK_AGG_COLUMN                     148
-#define TK_UMINUS                         149
-#define TK_UPLUS                          150
-#define TK_TRUTH                          151
-#define TK_REGISTER                       152
-#define TK_VECTOR                         153
-#define TK_SELECT_COLUMN                  154
-#define TK_IF_NULL_ROW                    155
-#define TK_ASTERISK                       156
-#define TK_SPAN                           157
-#define TK_END_OF_FILE                    158
-#define TK_UNCLOSED_STRING                159
-#define TK_SPACE                          160
-#define TK_ILLEGAL                        161
+#define TK_ISNOT                          143
+#define TK_FUNCTION                       144
+#define TK_COLUMN                         145
+#define TK_AGG_FUNCTION                   146
+#define TK_AGG_COLUMN                     147
+#define TK_UMINUS                         148
+#define TK_UPLUS                          149
+#define TK_REGISTER                       150
+#define TK_VECTOR                         151
+#define TK_SELECT_COLUMN                  152
+#define TK_IF_NULL_ROW                    153
+#define TK_ASTERISK                       154
+#define TK_SPAN                           155
+#define TK_END_OF_FILE                    156
+#define TK_UNCLOSED_STRING                157
+#define TK_SPACE                          158
+#define TK_ILLEGAL                        159
 
 /* The token codes above must all fit in 8 bits */
 #define TKFLG_MASK           0xff  
@@ -13457,10 +13133,9 @@
 */
 typedef struct BusyHandler BusyHandler;
 struct BusyHandler {
-  int (*xBusyHandler)(void *,int);  /* The busy callback */
-  void *pBusyArg;                   /* First arg to busy callback */
-  int nBusy;                        /* Incremented with each busy call */
-  u8 bExtraFileArg;                 /* Include sqlite3_file as callback arg */
+  int (*xFunc)(void *,int);  /* The busy callback */
+  void *pArg;                /* First arg to busy callback */
+  int nBusy;                 /* Incremented with each busy call */
 };
 
 /*
@@ -14260,81 +13935,80 @@
 #define OP_Concat         93 /* same as TK_CONCAT, synopsis: r[P3]=r[P2]+r[P1] */
 #define OP_Compare        94 /* synopsis: r[P1@P3] <-> r[P2@P3]            */
 #define OP_BitNot         95 /* same as TK_BITNOT, synopsis: r[P1]= ~r[P1] */
-#define OP_IsTrue         96 /* synopsis: r[P2] = coalesce(r[P1]==TRUE,P3) ^ P4 */
+#define OP_Offset         96 /* synopsis: r[P3] = sqlite_offset(P1)        */
 #define OP_String8        97 /* same as TK_STRING, synopsis: r[P2]='P4'    */
-#define OP_Offset         98 /* synopsis: r[P3] = sqlite_offset(P1)        */
-#define OP_Column         99 /* synopsis: r[P3]=PX                         */
-#define OP_Affinity      100 /* synopsis: affinity(r[P1@P2])               */
-#define OP_MakeRecord    101 /* synopsis: r[P3]=mkrec(r[P1@P2])            */
-#define OP_Count         102 /* synopsis: r[P2]=count()                    */
-#define OP_ReadCookie    103
-#define OP_SetCookie     104
-#define OP_ReopenIdx     105 /* synopsis: root=P2 iDb=P3                   */
-#define OP_OpenRead      106 /* synopsis: root=P2 iDb=P3                   */
-#define OP_OpenWrite     107 /* synopsis: root=P2 iDb=P3                   */
-#define OP_OpenDup       108
-#define OP_OpenAutoindex 109 /* synopsis: nColumn=P2                       */
-#define OP_OpenEphemeral 110 /* synopsis: nColumn=P2                       */
-#define OP_SorterOpen    111
-#define OP_SequenceTest  112 /* synopsis: if( cursor[P1].ctr++ ) pc = P2   */
-#define OP_OpenPseudo    113 /* synopsis: P3 columns in r[P2]              */
-#define OP_Close         114
-#define OP_ColumnsUsed   115
-#define OP_Sequence      116 /* synopsis: r[P2]=cursor[P1].ctr++           */
-#define OP_NewRowid      117 /* synopsis: r[P2]=rowid                      */
-#define OP_Insert        118 /* synopsis: intkey=r[P3] data=r[P2]          */
-#define OP_InsertInt     119 /* synopsis: intkey=P3 data=r[P2]             */
-#define OP_Delete        120
-#define OP_ResetCount    121
-#define OP_SorterCompare 122 /* synopsis: if key(P1)!=trim(r[P3],P4) goto P2 */
-#define OP_SorterData    123 /* synopsis: r[P2]=data                       */
-#define OP_RowData       124 /* synopsis: r[P2]=data                       */
-#define OP_Rowid         125 /* synopsis: r[P2]=rowid                      */
-#define OP_NullRow       126
-#define OP_SeekEnd       127
-#define OP_SorterInsert  128 /* synopsis: key=r[P2]                        */
-#define OP_IdxInsert     129 /* synopsis: key=r[P2]                        */
-#define OP_IdxDelete     130 /* synopsis: key=r[P2@P3]                     */
-#define OP_DeferredSeek  131 /* synopsis: Move P3 to P1.rowid if needed    */
+#define OP_Column         98 /* synopsis: r[P3]=PX                         */
+#define OP_Affinity       99 /* synopsis: affinity(r[P1@P2])               */
+#define OP_MakeRecord    100 /* synopsis: r[P3]=mkrec(r[P1@P2])            */
+#define OP_Count         101 /* synopsis: r[P2]=count()                    */
+#define OP_ReadCookie    102
+#define OP_SetCookie     103
+#define OP_ReopenIdx     104 /* synopsis: root=P2 iDb=P3                   */
+#define OP_OpenRead      105 /* synopsis: root=P2 iDb=P3                   */
+#define OP_OpenWrite     106 /* synopsis: root=P2 iDb=P3                   */
+#define OP_OpenDup       107
+#define OP_OpenAutoindex 108 /* synopsis: nColumn=P2                       */
+#define OP_OpenEphemeral 109 /* synopsis: nColumn=P2                       */
+#define OP_SorterOpen    110
+#define OP_SequenceTest  111 /* synopsis: if( cursor[P1].ctr++ ) pc = P2   */
+#define OP_OpenPseudo    112 /* synopsis: P3 columns in r[P2]              */
+#define OP_Close         113
+#define OP_ColumnsUsed   114
+#define OP_Sequence      115 /* synopsis: r[P2]=cursor[P1].ctr++           */
+#define OP_NewRowid      116 /* synopsis: r[P2]=rowid                      */
+#define OP_Insert        117 /* synopsis: intkey=r[P3] data=r[P2]          */
+#define OP_InsertInt     118 /* synopsis: intkey=P3 data=r[P2]             */
+#define OP_Delete        119
+#define OP_ResetCount    120
+#define OP_SorterCompare 121 /* synopsis: if key(P1)!=trim(r[P3],P4) goto P2 */
+#define OP_SorterData    122 /* synopsis: r[P2]=data                       */
+#define OP_RowData       123 /* synopsis: r[P2]=data                       */
+#define OP_Rowid         124 /* synopsis: r[P2]=rowid                      */
+#define OP_NullRow       125
+#define OP_SeekEnd       126
+#define OP_SorterInsert  127 /* synopsis: key=r[P2]                        */
+#define OP_IdxInsert     128 /* synopsis: key=r[P2]                        */
+#define OP_IdxDelete     129 /* synopsis: key=r[P2@P3]                     */
+#define OP_DeferredSeek  130 /* synopsis: Move P3 to P1.rowid if needed    */
+#define OP_IdxRowid      131 /* synopsis: r[P2]=rowid                      */
 #define OP_Real          132 /* same as TK_FLOAT, synopsis: r[P2]=P4       */
-#define OP_IdxRowid      133 /* synopsis: r[P2]=rowid                      */
-#define OP_Destroy       134
-#define OP_Clear         135
-#define OP_ResetSorter   136
-#define OP_CreateBtree   137 /* synopsis: r[P2]=root iDb=P1 flags=P3       */
-#define OP_SqlExec       138
-#define OP_ParseSchema   139
-#define OP_LoadAnalysis  140
-#define OP_DropTable     141
-#define OP_DropIndex     142
-#define OP_DropTrigger   143
-#define OP_IntegrityCk   144
-#define OP_RowSetAdd     145 /* synopsis: rowset(P1)=r[P2]                 */
-#define OP_Param         146
-#define OP_FkCounter     147 /* synopsis: fkctr[P1]+=P2                    */
-#define OP_MemMax        148 /* synopsis: r[P1]=max(r[P1],r[P2])           */
-#define OP_OffsetLimit   149 /* synopsis: if r[P1]>0 then r[P2]=r[P1]+max(0,r[P3]) else r[P2]=(-1) */
-#define OP_AggStep0      150 /* synopsis: accum=r[P3] step(r[P2@P5])       */
-#define OP_AggStep       151 /* synopsis: accum=r[P3] step(r[P2@P5])       */
-#define OP_AggFinal      152 /* synopsis: accum=r[P1] N=P2                 */
-#define OP_Expire        153
-#define OP_TableLock     154 /* synopsis: iDb=P1 root=P2 write=P3          */
-#define OP_VBegin        155
-#define OP_VCreate       156
-#define OP_VDestroy      157
-#define OP_VOpen         158
-#define OP_VColumn       159 /* synopsis: r[P3]=vcolumn(P2)                */
-#define OP_VRename       160
-#define OP_Pagecount     161
-#define OP_MaxPgcnt      162
-#define OP_PureFunc0     163
-#define OP_Function0     164 /* synopsis: r[P3]=func(r[P2@P5])             */
-#define OP_PureFunc      165
-#define OP_Function      166 /* synopsis: r[P3]=func(r[P2@P5])             */
-#define OP_Trace         167
-#define OP_CursorHint    168
-#define OP_Noop          169
-#define OP_Explain       170
+#define OP_Destroy       133
+#define OP_Clear         134
+#define OP_ResetSorter   135
+#define OP_CreateBtree   136 /* synopsis: r[P2]=root iDb=P1 flags=P3       */
+#define OP_SqlExec       137
+#define OP_ParseSchema   138
+#define OP_LoadAnalysis  139
+#define OP_DropTable     140
+#define OP_DropIndex     141
+#define OP_DropTrigger   142
+#define OP_IntegrityCk   143
+#define OP_RowSetAdd     144 /* synopsis: rowset(P1)=r[P2]                 */
+#define OP_Param         145
+#define OP_FkCounter     146 /* synopsis: fkctr[P1]+=P2                    */
+#define OP_MemMax        147 /* synopsis: r[P1]=max(r[P1],r[P2])           */
+#define OP_OffsetLimit   148 /* synopsis: if r[P1]>0 then r[P2]=r[P1]+max(0,r[P3]) else r[P2]=(-1) */
+#define OP_AggStep0      149 /* synopsis: accum=r[P3] step(r[P2@P5])       */
+#define OP_AggStep       150 /* synopsis: accum=r[P3] step(r[P2@P5])       */
+#define OP_AggFinal      151 /* synopsis: accum=r[P1] N=P2                 */
+#define OP_Expire        152
+#define OP_TableLock     153 /* synopsis: iDb=P1 root=P2 write=P3          */
+#define OP_VBegin        154
+#define OP_VCreate       155
+#define OP_VDestroy      156
+#define OP_VOpen         157
+#define OP_VColumn       158 /* synopsis: r[P3]=vcolumn(P2)                */
+#define OP_VRename       159
+#define OP_Pagecount     160
+#define OP_MaxPgcnt      161
+#define OP_PureFunc0     162
+#define OP_Function0     163 /* synopsis: r[P3]=func(r[P2@P5])             */
+#define OP_PureFunc      164
+#define OP_Function      165 /* synopsis: r[P3]=func(r[P2@P5])             */
+#define OP_Trace         166
+#define OP_CursorHint    167
+#define OP_Noop          168
+#define OP_Explain       169
 
 /* Properties such as "out2" or "jump" that are specified in
 ** comments following the "case" for each opcode in the vdbe.c
@@ -14359,16 +14033,16 @@
 /*  72 */ 0x10, 0x10, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00,\
 /*  80 */ 0x02, 0x02, 0x02, 0x00, 0x26, 0x26, 0x26, 0x26,\
 /*  88 */ 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x00, 0x12,\
-/*  96 */ 0x12, 0x10, 0x20, 0x00, 0x00, 0x00, 0x10, 0x10,\
+/*  96 */ 0x20, 0x10, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00,\
 /* 104 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
-/* 112 */ 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00,\
-/* 120 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00,\
-/* 128 */ 0x04, 0x04, 0x00, 0x00, 0x10, 0x10, 0x10, 0x00,\
-/* 136 */ 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
-/* 144 */ 0x00, 0x06, 0x10, 0x00, 0x04, 0x1a, 0x00, 0x00,\
+/* 112 */ 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00,\
+/* 120 */ 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x04,\
+/* 128 */ 0x04, 0x00, 0x00, 0x10, 0x10, 0x10, 0x00, 0x00,\
+/* 136 */ 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
+/* 144 */ 0x06, 0x10, 0x00, 0x04, 0x1a, 0x00, 0x00, 0x00,\
 /* 152 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
-/* 160 */ 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,\
-/* 168 */ 0x00, 0x00, 0x00,}
+/* 160 */ 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\
+/* 168 */ 0x00, 0x00,}
 
 /* The sqlite3P2Values() routine is able to run faster if it knows
 ** the value of the largest JUMP opcode.  The smaller the maximum
@@ -14669,7 +14343,7 @@
 SQLITE_PRIVATE int sqlite3PagerReadFileheader(Pager*, int, unsigned char*);
 
 /* Functions used to configure a Pager object. */
-SQLITE_PRIVATE void sqlite3PagerSetBusyHandler(Pager*, int(*)(void *), void *);
+SQLITE_PRIVATE void sqlite3PagerSetBusyhandler(Pager*, int(*)(void *), void *);
 SQLITE_PRIVATE int sqlite3PagerSetPagesize(Pager*, u32*, int);
 #ifdef SQLITE_HAS_CODEC
 SQLITE_PRIVATE void sqlite3PagerAlignReserve(Pager*,Pager*);
@@ -14755,11 +14429,6 @@
 SQLITE_PRIVATE void sqlite3PagerCacheStat(Pager *, int, int, int *);
 SQLITE_PRIVATE void sqlite3PagerClearCache(Pager*);
 SQLITE_PRIVATE int sqlite3SectorSize(sqlite3_file *);
-#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
-SQLITE_PRIVATE void sqlite3PagerResetLockTimeout(Pager *pPager);
-#else
-# define sqlite3PagerResetLockTimeout(X)
-#endif
 
 /* Functions used to truncate the database file. */
 SQLITE_PRIVATE void sqlite3PagerTruncateImage(Pager*,Pgno);
@@ -15579,9 +15248,8 @@
     int newTnum;                /* Rootpage of table being initialized */
     u8 iDb;                     /* Which db file is being initialized */
     u8 busy;                    /* TRUE if currently initializing */
-    unsigned orphanTrigger : 1; /* Last statement is orphaned TEMP trigger */
-    unsigned imposterTable : 1; /* Building an imposter table */
-    unsigned reopenMemdb : 1;   /* ATTACH is really a reopen using MemDB */
+    u8 orphanTrigger;           /* Last statement is orphaned TEMP trigger */
+    u8 imposterTable;           /* Building an imposter table */
   } init;
   int nVdbeActive;              /* Number of VDBEs currently running */
   int nVdbeRead;                /* Number of active VDBEs that read or write */
@@ -15746,8 +15414,6 @@
 #define SQLITE_CursorHints    0x0400   /* Add OP_CursorHint opcodes */
 #define SQLITE_Stat34         0x0800   /* Use STAT3 or STAT4 data */
    /* TH3 expects the Stat34  ^^^^^^ value to be 0x0800.  Don't change it */
-#define SQLITE_PushDown       0x1000   /* The push-down optimization */
-#define SQLITE_SimplifyJoin   0x2000   /* Convert LEFT JOIN to JOIN */
 #define SQLITE_AllOpts        0xffff   /* All optimizations */
 
 /*
@@ -15971,7 +15637,6 @@
 #define COLFLAG_PRIMKEY  0x0001    /* Column is part of the primary key */
 #define COLFLAG_HIDDEN   0x0002    /* A hidden column in a virtual table */
 #define COLFLAG_HASTYPE  0x0004    /* Type name follows column name */
-#define COLFLAG_UNIQUE   0x0008    /* Column def contains "UNIQUE" or "PK" */
 
 /*
 ** A "Collating Sequence" is defined by an instance of the following
@@ -17209,6 +16874,7 @@
   int nMaxArg;         /* Max args passed to user function by sub-program */
 #if SELECTTRACE_ENABLED
   int nSelect;         /* Number of SELECT statements seen */
+  int nSelectIndent;   /* How far to indent SELECTTRACE() output */
 #endif
 #ifndef SQLITE_OMIT_SHARED_CACHE
   int nTableLock;        /* Number of locks in aTableLock */
@@ -17572,9 +17238,9 @@
     struct CCurHint *pCCurHint;               /* Used by codeCursorHint() */
     int *aiCol;                               /* array of column indexes */
     struct IdxCover *pIdxCover;               /* Check for index coverage */
-    struct IdxExprTrans *pIdxTrans;           /* Convert idxed expr to column */
+    struct IdxExprTrans *pIdxTrans;           /* Convert indexed expr to column */
     ExprList *pGroupBy;                       /* GROUP BY clause */
-    Select *pSelect;                          /* HAVING to WHERE clause ctx */
+    struct HavingToWhereCtx *pHavingCtx;      /* HAVING to WHERE clause ctx */
   } u;
 };
 
@@ -18038,7 +17704,6 @@
 SQLITE_PRIVATE int sqlite3ExprCompareSkip(Expr*, Expr*, int);
 SQLITE_PRIVATE int sqlite3ExprListCompare(ExprList*, ExprList*, int);
 SQLITE_PRIVATE int sqlite3ExprImpliesExpr(Parse*,Expr*, Expr*, int);
-SQLITE_PRIVATE int sqlite3ExprImpliesNonNullRow(Expr*,int);
 SQLITE_PRIVATE void sqlite3ExprAnalyzeAggregates(NameContext*, Expr*);
 SQLITE_PRIVATE void sqlite3ExprAnalyzeAggList(NameContext*,ExprList*);
 SQLITE_PRIVATE int sqlite3ExprCoveredByIndex(Expr*, int iCur, Index *pIdx);
@@ -18056,8 +17721,6 @@
 SQLITE_PRIVATE void sqlite3Savepoint(Parse*, int, Token*);
 SQLITE_PRIVATE void sqlite3CloseSavepoints(sqlite3 *);
 SQLITE_PRIVATE void sqlite3LeaveMutexAndCloseZombie(sqlite3*);
-SQLITE_PRIVATE int sqlite3ExprIdToTrueFalse(Expr*);
-SQLITE_PRIVATE int sqlite3ExprTruthValue(const Expr*);
 SQLITE_PRIVATE int sqlite3ExprIsConstant(Expr*);
 SQLITE_PRIVATE int sqlite3ExprIsConstantNotJoin(Expr*);
 SQLITE_PRIVATE int sqlite3ExprIsConstantOrFunction(Expr*, u8);
@@ -18240,10 +17903,6 @@
 SQLITE_PRIVATE const char *sqlite3ErrName(int);
 #endif
 
-#ifdef SQLITE_ENABLE_DESERIALIZE
-SQLITE_PRIVATE int sqlite3MemdbInit(void);
-#endif
-
 SQLITE_PRIVATE const char *sqlite3ErrStr(int);
 SQLITE_PRIVATE int sqlite3ReadSchema(Parse *pParse);
 SQLITE_PRIVATE CollSeq *sqlite3FindCollSeq(sqlite3*,u8 enc, const char*,int);
@@ -18292,9 +17951,6 @@
 SQLITE_PRIVATE int sqlite3PendingByte;
 #endif
 #endif
-#ifdef VDBE_PROFILE
-SQLITE_PRIVATE sqlite3_uint64 sqlite3NProfileCnt;
-#endif
 SQLITE_PRIVATE void sqlite3RootPageMoved(sqlite3*, int, int, int);
 SQLITE_PRIVATE void sqlite3Reindex(Parse*, Token*, Token*);
 SQLITE_PRIVATE void sqlite3AlterFunctions(void);
@@ -18317,7 +17973,7 @@
 SQLITE_PRIVATE CollSeq *sqlite3GetCollSeq(Parse*, u8, CollSeq *, const char*);
 SQLITE_PRIVATE char sqlite3AffinityType(const char*, u8*);
 SQLITE_PRIVATE void sqlite3Analyze(Parse*, Token*, Token*);
-SQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler*, sqlite3_file*);
+SQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler*);
 SQLITE_PRIVATE int sqlite3FindDb(sqlite3*, Token*);
 SQLITE_PRIVATE int sqlite3FindDbName(sqlite3 *, const char *);
 SQLITE_PRIVATE int sqlite3AnalysisLoad(sqlite3*,int iDB);
@@ -18918,13 +18574,6 @@
    { "1", 1 }
 };
 
-#ifdef VDBE_PROFILE
-/*
-** The following performance counter can be used in place of
-** sqlite3Hwtime() for profiling.  This is a no-op on standard builds.
-*/
-SQLITE_PRIVATE sqlite3_uint64 sqlite3NProfileCnt = 0;
-#endif
 
 /*
 ** The value of the "pending" byte must be 0x40000000 (1 byte past the
@@ -19208,6 +18857,8 @@
 ** If the MEM_Null flag is set, then the value is an SQL NULL value.
 ** For a pointer type created using sqlite3_bind_pointer() or
 ** sqlite3_result_pointer() the MEM_Term and MEM_Subtype flags are also set.
+** If both MEM_Null and MEM_Zero are set, that means that the value is
+** an unchanging column value from VColumn.
 **
 ** If the MEM_Str flag is set then Mem.z points at a string representation.
 ** Usually this is encoded in the same unicode encoding as the main
@@ -19301,6 +18952,7 @@
   int iOp;                /* Instruction number of OP_Function */
   int isError;            /* Error code returned by the function. */
   u8 skipFlag;            /* Skip accumulator loading if true */
+  u8 fErrorOrAux;         /* isError!=0 or pVdbe->pAuxData modified */
   u8 argc;                /* Number of arguments */
   sqlite3_value *argv[1]; /* Argument set */
 };
@@ -19470,7 +19122,6 @@
 SQLITE_PRIVATE i64 sqlite3VdbeIntValue(Mem*);
 SQLITE_PRIVATE int sqlite3VdbeMemIntegerify(Mem*);
 SQLITE_PRIVATE double sqlite3VdbeRealValue(Mem*);
-SQLITE_PRIVATE int sqlite3VdbeBooleanValue(Mem*, int ifNull);
 SQLITE_PRIVATE void sqlite3VdbeIntegerAffinity(Mem*);
 SQLITE_PRIVATE int sqlite3VdbeMemRealify(Mem*);
 SQLITE_PRIVATE int sqlite3VdbeMemNumerify(Mem*);
@@ -19864,9 +19515,6 @@
     ** pagers the database handle is connected to. *pHighwater is always set 
     ** to zero.
     */
-    case SQLITE_DBSTATUS_CACHE_SPILL:
-      op = SQLITE_DBSTATUS_CACHE_WRITE+1;
-      /* Fall through into the next case */
     case SQLITE_DBSTATUS_CACHE_HIT:
     case SQLITE_DBSTATUS_CACHE_MISS:
     case SQLITE_DBSTATUS_CACHE_WRITE:{
@@ -21288,9 +20936,7 @@
 */
 SQLITE_PRIVATE int sqlite3OsFileControl(sqlite3_file *id, int op, void *pArg){
 #ifdef SQLITE_TEST
-  if( op!=SQLITE_FCNTL_COMMIT_PHASETWO
-   && op!=SQLITE_FCNTL_LOCK_TIMEOUT
-  ){
+  if( op!=SQLITE_FCNTL_COMMIT_PHASETWO ){
     /* Faults are not injected into COMMIT_PHASETWO because, assuming SQLite
     ** is using a regular VFS, it is called after the corresponding
     ** transaction has been committed. Injecting a fault at this point
@@ -21304,11 +20950,10 @@
     DO_OS_MALLOC_TEST(id);
   }
 #endif
-  if( id->pMethods==0 ) return SQLITE_NOTFOUND;
   return id->pMethods->xFileControl(id, op, pArg);
 }
 SQLITE_PRIVATE void sqlite3OsFileControlHint(sqlite3_file *id, int op, void *pArg){
-  if( id->pMethods ) (void)id->pMethods->xFileControl(id, op, pArg);
+  (void)id->pMethods->xFileControl(id, op, pArg);
 }
 
 SQLITE_PRIVATE int sqlite3OsSectorSize(sqlite3_file *id){
@@ -24463,12 +24108,11 @@
 #endif
 };
 #if SQLITE_MUTEX_NREF
-# define SQLITE3_MUTEX_INITIALIZER(id) \
-     {PTHREAD_MUTEX_INITIALIZER,id,0,(pthread_t)0,0}
+#define SQLITE3_MUTEX_INITIALIZER {PTHREAD_MUTEX_INITIALIZER,0,0,(pthread_t)0,0}
 #elif defined(SQLITE_ENABLE_API_ARMOR)
-# define SQLITE3_MUTEX_INITIALIZER(id) { PTHREAD_MUTEX_INITIALIZER, id }
+#define SQLITE3_MUTEX_INITIALIZER { PTHREAD_MUTEX_INITIALIZER, 0 }
 #else
-#define SQLITE3_MUTEX_INITIALIZER(id) { PTHREAD_MUTEX_INITIALIZER }
+#define SQLITE3_MUTEX_INITIALIZER { PTHREAD_MUTEX_INITIALIZER }
 #endif
 
 /*
@@ -24565,18 +24209,18 @@
 */
 static sqlite3_mutex *pthreadMutexAlloc(int iType){
   static sqlite3_mutex staticMutexes[] = {
-    SQLITE3_MUTEX_INITIALIZER(2),
-    SQLITE3_MUTEX_INITIALIZER(3),
-    SQLITE3_MUTEX_INITIALIZER(4),
-    SQLITE3_MUTEX_INITIALIZER(5),
-    SQLITE3_MUTEX_INITIALIZER(6),
-    SQLITE3_MUTEX_INITIALIZER(7),
-    SQLITE3_MUTEX_INITIALIZER(8),
-    SQLITE3_MUTEX_INITIALIZER(9),
-    SQLITE3_MUTEX_INITIALIZER(10),
-    SQLITE3_MUTEX_INITIALIZER(11),
-    SQLITE3_MUTEX_INITIALIZER(12),
-    SQLITE3_MUTEX_INITIALIZER(13)
+    SQLITE3_MUTEX_INITIALIZER,
+    SQLITE3_MUTEX_INITIALIZER,
+    SQLITE3_MUTEX_INITIALIZER,
+    SQLITE3_MUTEX_INITIALIZER,
+    SQLITE3_MUTEX_INITIALIZER,
+    SQLITE3_MUTEX_INITIALIZER,
+    SQLITE3_MUTEX_INITIALIZER,
+    SQLITE3_MUTEX_INITIALIZER,
+    SQLITE3_MUTEX_INITIALIZER,
+    SQLITE3_MUTEX_INITIALIZER,
+    SQLITE3_MUTEX_INITIALIZER,
+    SQLITE3_MUTEX_INITIALIZER
   };
   sqlite3_mutex *p;
   switch( iType ){
@@ -24595,9 +24239,6 @@
         pthread_mutex_init(&p->mutex, &recursiveAttr);
         pthread_mutexattr_destroy(&recursiveAttr);
 #endif
-#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)
-        p->id = SQLITE_MUTEX_RECURSIVE;
-#endif
       }
       break;
     }
@@ -24605,9 +24246,6 @@
       p = sqlite3MallocZero( sizeof(*p) );
       if( p ){
         pthread_mutex_init(&p->mutex, 0);
-#if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)
-        p->id = SQLITE_MUTEX_FAST;
-#endif
       }
       break;
     }
@@ -24623,7 +24261,7 @@
     }
   }
 #if SQLITE_MUTEX_NREF || defined(SQLITE_ENABLE_API_ARMOR)
-  assert( p==0 || p->id==iType );
+  if( p ) p->id = iType;
 #endif
   return p;
 }
@@ -25140,7 +24778,7 @@
 #ifdef SQLITE_DEBUG
   volatile int nRef;         /* Number of enterances */
   volatile DWORD owner;      /* Thread holding this mutex */
-  volatile LONG trace;       /* True to trace changes */
+  volatile int trace;        /* True to trace changes */
 #endif
 };
 
@@ -25152,10 +24790,10 @@
 #define SQLITE_W32_MUTEX_INITIALIZER { 0 }
 
 #ifdef SQLITE_DEBUG
-#define SQLITE3_MUTEX_INITIALIZER(id) { SQLITE_W32_MUTEX_INITIALIZER, id, \
+#define SQLITE3_MUTEX_INITIALIZER { SQLITE_W32_MUTEX_INITIALIZER, 0, \
                                     0L, (DWORD)0, 0 }
 #else
-#define SQLITE3_MUTEX_INITIALIZER(id) { SQLITE_W32_MUTEX_INITIALIZER, id }
+#define SQLITE3_MUTEX_INITIALIZER { SQLITE_W32_MUTEX_INITIALIZER, 0 }
 #endif
 
 #ifdef SQLITE_DEBUG
@@ -25198,18 +24836,18 @@
 ** Initialize and deinitialize the mutex subsystem.
 */
 static sqlite3_mutex winMutex_staticMutexes[] = {
-  SQLITE3_MUTEX_INITIALIZER(2),
-  SQLITE3_MUTEX_INITIALIZER(3),
-  SQLITE3_MUTEX_INITIALIZER(4),
-  SQLITE3_MUTEX_INITIALIZER(5),
-  SQLITE3_MUTEX_INITIALIZER(6),
-  SQLITE3_MUTEX_INITIALIZER(7),
-  SQLITE3_MUTEX_INITIALIZER(8),
-  SQLITE3_MUTEX_INITIALIZER(9),
-  SQLITE3_MUTEX_INITIALIZER(10),
-  SQLITE3_MUTEX_INITIALIZER(11),
-  SQLITE3_MUTEX_INITIALIZER(12),
-  SQLITE3_MUTEX_INITIALIZER(13)
+  SQLITE3_MUTEX_INITIALIZER,
+  SQLITE3_MUTEX_INITIALIZER,
+  SQLITE3_MUTEX_INITIALIZER,
+  SQLITE3_MUTEX_INITIALIZER,
+  SQLITE3_MUTEX_INITIALIZER,
+  SQLITE3_MUTEX_INITIALIZER,
+  SQLITE3_MUTEX_INITIALIZER,
+  SQLITE3_MUTEX_INITIALIZER,
+  SQLITE3_MUTEX_INITIALIZER,
+  SQLITE3_MUTEX_INITIALIZER,
+  SQLITE3_MUTEX_INITIALIZER,
+  SQLITE3_MUTEX_INITIALIZER
 };
 
 static int winMutex_isInit = 0;
@@ -25339,15 +24977,15 @@
       }
 #endif
       p = &winMutex_staticMutexes[iType-2];
+      p->id = iType;
 #ifdef SQLITE_DEBUG
 #ifdef SQLITE_WIN32_MUTEX_TRACE_STATIC
-      InterlockedCompareExchange(&p->trace, 1, 0);
+      p->trace = 1;
 #endif
 #endif
       break;
     }
   }
-  assert( p==0 || p->id==iType );
   return p;
 }
 
@@ -26426,11 +26064,6 @@
   PrintfArguments *pArgList = 0; /* Arguments for SQLITE_PRINTF_SQLFUNC */
   char buf[etBUFSIZE];       /* Conversion buffer */
 
-  /* pAccum never starts out with an empty buffer that was obtained from 
-  ** malloc().  This precondition is required by the mprintf("%z...")
-  ** optimization. */
-  assert( pAccum->nChar>0 || (pAccum->printfFlags&SQLITE_PRINTF_MALLOCED)==0 );
-
   bufpt = 0;
   if( (pAccum->printfFlags & SQLITE_PRINTF_SQLFUNC)!=0 ){
     pArgList = va_arg(ap, PrintfArguments*);
@@ -26849,38 +26482,9 @@
       case etCHARX:
         if( bArgList ){
           bufpt = getTextArg(pArgList);
-          length = 1;
-          if( bufpt ){
-            buf[0] = c = *(bufpt++);
-            if( (c&0xc0)==0xc0 ){
-              while( length<4 && (bufpt[0]&0xc0)==0x80 ){
-                buf[length++] = *(bufpt++);
-              }
-            }
-          }else{
-            buf[0] = 0;
-          }
+          c = bufpt ? bufpt[0] : 0;
         }else{
-          unsigned int ch = va_arg(ap,unsigned int);
-          if( ch<0x00080 ){
-            buf[0] = ch & 0xff;
-            length = 1;
-          }else if( ch<0x00800 ){
-            buf[0] = 0xc0 + (u8)((ch>>6)&0x1f);
-            buf[1] = 0x80 + (u8)(ch & 0x3f);
-            length = 2;
-          }else if( ch<0x10000 ){
-            buf[0] = 0xe0 + (u8)((ch>>12)&0x0f);
-            buf[1] = 0x80 + (u8)((ch>>6) & 0x3f);
-            buf[2] = 0x80 + (u8)(ch & 0x3f);
-            length = 3;
-          }else{
-            buf[0] = 0xf0 + (u8)((ch>>18) & 0x07);
-            buf[1] = 0x80 + (u8)((ch>>12) & 0x3f);
-            buf[2] = 0x80 + (u8)((ch>>6) & 0x3f);
-            buf[3] = 0x80 + (u8)(ch & 0x3f);
-            length = 4;
-          }
+          c = va_arg(ap,int);
         }
         if( precision>1 ){
           width -= precision-1;
@@ -26888,13 +26492,12 @@
             sqlite3AppendChar(pAccum, width-1, ' ');
             width = 0;
           }
-          while( precision-- > 1 ){
-            sqlite3StrAccumAppend(pAccum, buf, length);
-          }
+          sqlite3AppendChar(pAccum, precision-1, c);
         }
+        length = 1;
+        buf[0] = c;
         bufpt = buf;
-        flag_altform2 = 1;
-        goto adjust_width_for_utf8;
+        break;
       case etSTRING:
       case etDYNSTRING:
         if( bArgList ){
@@ -26906,45 +26509,17 @@
         if( bufpt==0 ){
           bufpt = "";
         }else if( xtype==etDYNSTRING ){
-          if( pAccum->nChar==0 && pAccum->mxAlloc && width==0 && precision<0 ){
-            /* Special optimization for sqlite3_mprintf("%z..."):
-            ** Extend an existing memory allocation rather than creating
-            ** a new one. */
-            assert( (pAccum->printfFlags&SQLITE_PRINTF_MALLOCED)==0 );
-            pAccum->zText = bufpt;
-            pAccum->nAlloc = sqlite3DbMallocSize(pAccum->db, bufpt);
-            pAccum->nChar = 0x7fffffff & (int)strlen(bufpt);
-            pAccum->printfFlags |= SQLITE_PRINTF_MALLOCED;
-            length = 0;
-            break;
-          }
           zExtra = bufpt;
         }
         if( precision>=0 ){
-          if( flag_altform2 ){
-            /* Set length to the number of bytes needed in order to display
-            ** precision characters */
-            unsigned char *z = (unsigned char*)bufpt;
-            while( precision-- > 0 && z[0] ){
-              SQLITE_SKIP_UTF8(z);
-            }
-            length = (int)(z - (unsigned char*)bufpt);
-          }else{
-            for(length=0; length<precision && bufpt[length]; length++){}
-          }
+          for(length=0; length<precision && bufpt[length]; length++){}
         }else{
           length = 0x7fffffff & (int)strlen(bufpt);
         }
-      adjust_width_for_utf8:
-        if( flag_altform2 && width>0 ){
-          /* Adjust width to account for extra bytes in UTF-8 characters */
-          int ii = length - 1;
-          while( ii>=0 ) if( (bufpt[ii--] & 0xc0)==0x80 ) width++;
-        }
         break;
-      case etSQLESCAPE:           /* %q: Escape ' characters */
-      case etSQLESCAPE2:          /* %Q: Escape ' and enclose in '...' */
-      case etSQLESCAPE3: {        /* %w: Escape " characters */
+      case etSQLESCAPE:           /* Escape ' characters */
+      case etSQLESCAPE2:          /* Escape ' and enclose in '...' */
+      case etSQLESCAPE3: {        /* Escape " characters */
         int i, j, k, n, isnull;
         int needQuote;
         char ch;
@@ -26958,17 +26533,9 @@
         }
         isnull = escarg==0;
         if( isnull ) escarg = (xtype==etSQLESCAPE2 ? "NULL" : "(NULL)");
-        /* For %q, %Q, and %w, the precision is the number of byte (or
-        ** characters if the ! flags is present) to use from the input.
-        ** Because of the extra quoting characters inserted, the number
-        ** of output characters may be larger than the precision.
-        */
         k = precision;
         for(i=n=0; k!=0 && (ch=escarg[i])!=0; i++, k--){
           if( ch==q )  n++;
-          if( flag_altform2 && (ch&0xc0)==0xc0 ){
-            while( (escarg[i+1]&0xc0)==0x80 ){ i++; }
-          }
         }
         needQuote = !isnull && xtype==etSQLESCAPE2;
         n += i + 3;
@@ -26991,7 +26558,10 @@
         if( needQuote ) bufpt[j++] = q;
         bufpt[j] = 0;
         length = j;
-        goto adjust_width_for_utf8;
+        /* The precision in %q and %Q means how many input characters to
+        ** consume, not the length of the output...
+        ** if( precision>=0 && precision<length ) length = precision; */
+        break;
       }
       case etTOKEN: {
         Token *pToken;
@@ -27030,10 +26600,7 @@
     /*
     ** The text of the conversion is pointed to by "bufpt" and is
     ** "length" characters long.  The field width is "width".  Do
-    ** the output.  Both length and width are in bytes, not characters,
-    ** at this point.  If the "!" flag was present on string conversions
-    ** indicating that width and precision should be expressed in characters,
-    ** then the values have been translated prior to reaching this point.
+    ** the output.
     */
     width -= length;
     if( width>0 ){
@@ -27548,21 +27115,11 @@
     sqlite3TreeViewPush(pView, 1);
   }
   do{
-#if SELECTTRACE_ENABLED
-    sqlite3TreeViewLine(pView,
-      "SELECT%s%s (%s/%p) selFlags=0x%x nSelectRow=%d",
-      ((p->selFlags & SF_Distinct) ? " DISTINCT" : ""),
-      ((p->selFlags & SF_Aggregate) ? " agg_flag" : ""),
-      p->zSelName, p, p->selFlags,
-      (int)p->nSelectRow
-    );
-#else
     sqlite3TreeViewLine(pView, "SELECT%s%s (0x%p) selFlags=0x%x nSelectRow=%d",
       ((p->selFlags & SF_Distinct) ? " DISTINCT" : ""),
       ((p->selFlags & SF_Aggregate) ? " agg_flag" : ""), p, p->selFlags,
       (int)p->nSelectRow
     );
-#endif
     if( cnt++ ) sqlite3TreeViewPop(pView);
     if( p->pPrior ){
       n = 1000;
@@ -27713,11 +27270,6 @@
       sqlite3TreeViewLine(pView,"NULL");
       break;
     }
-    case TK_TRUEFALSE: {
-      sqlite3TreeViewLine(pView,
-         sqlite3ExprTruthValue(pExpr) ? "TRUE" : "FALSE");
-      break;
-    }
 #ifndef SQLITE_OMIT_BLOB_LITERAL
     case TK_BLOB: {
       sqlite3TreeViewLine(pView,"%s", pExpr->u.zToken);
@@ -27774,19 +27326,6 @@
     case TK_ISNULL:  zUniOp = "ISNULL"; break;
     case TK_NOTNULL: zUniOp = "NOTNULL"; break;
 
-    case TK_TRUTH: {
-      int x;
-      const char *azOp[] = {
-         "IS-FALSE", "IS-TRUE", "IS-NOT-FALSE", "IS-NOT-TRUE"
-      };
-      assert( pExpr->op2==TK_IS || pExpr->op2==TK_ISNOT );
-      assert( pExpr->pRight );
-      assert( pExpr->pRight->op==TK_TRUEFALSE );
-      x = (pExpr->op2==TK_ISNOT)*2 + sqlite3ExprTruthValue(pExpr->pRight);
-      zUniOp = azOp[x];
-      break;
-    }
-
     case TK_SPAN: {
       sqlite3TreeViewLine(pView, "SPAN %Q", pExpr->u.zToken);
       sqlite3TreeViewExpr(pView, pExpr->pLeft, 0);
@@ -29524,7 +29063,7 @@
 ** Returns:
 **
 **     0    Successful transformation.  Fits in a 64-bit signed integer.
-**     1    Excess non-space text after the integer value
+**     1    Excess text after the integer value
 **     2    Integer too large for a 64-bit signed integer or is malformed
 **     3    Special case of 9223372036854775808
 **
@@ -29567,57 +29106,47 @@
   for(i=0; &zNum[i]<zEnd && (c=zNum[i])>='0' && c<='9'; i+=incr){
     u = u*10 + c - '0';
   }
-  testcase( i==18*incr );
-  testcase( i==19*incr );
-  testcase( i==20*incr );
   if( u>LARGEST_INT64 ){
-    /* This test and assignment is needed only to suppress UB warnings
-    ** from clang and -fsanitize=undefined.  This test and assignment make
-    ** the code a little larger and slower, and no harm comes from omitting
-    ** them, but we must appaise the undefined-behavior pharisees. */
     *pNum = neg ? SMALLEST_INT64 : LARGEST_INT64;
   }else if( neg ){
     *pNum = -(i64)u;
   }else{
     *pNum = (i64)u;
   }
-  rc = 0;
-  if( (i==0 && zStart==zNum)     /* No digits */
+  testcase( i==18 );
+  testcase( i==19 );
+  testcase( i==20 );
+  if( &zNum[i]<zEnd              /* Extra bytes at the end */
+   || (i==0 && zStart==zNum)     /* No digits */
    || nonNum                     /* UTF16 with high-order bytes non-zero */
   ){
     rc = 1;
-  }else if( &zNum[i]<zEnd ){     /* Extra bytes at the end */
-    int jj = i;
-    do{
-      if( !sqlite3Isspace(zNum[jj]) ){
-        rc = 1;          /* Extra non-space text after the integer */
-        break;
-      }
-      jj += incr;
-    }while( &zNum[jj]<zEnd );
+  }else{
+    rc = 0;
   }
-  if( i<19*incr ){
+  if( i>19*incr ){                /* Too many digits */
+    /* zNum is empty or contains non-numeric text or is longer
+    ** than 19 digits (thus guaranteeing that it is too large) */
+    return 2;
+  }else if( i<19*incr ){
     /* Less than 19 digits, so we know that it fits in 64 bits */
     assert( u<=LARGEST_INT64 );
     return rc;
   }else{
     /* zNum is a 19-digit numbers.  Compare it against 9223372036854775808. */
-    c = i>19*incr ? 1 : compare2pow63(zNum, incr);
+    c = compare2pow63(zNum, incr);
     if( c<0 ){
       /* zNum is less than 9223372036854775808 so it fits */
       assert( u<=LARGEST_INT64 );
       return rc;
+    }else if( c>0 ){
+      /* zNum is greater than 9223372036854775808 so it overflows */
+      return 2;
     }else{
-      *pNum = neg ? SMALLEST_INT64 : LARGEST_INT64;
-      if( c>0 ){
-        /* zNum is greater than 9223372036854775808 so it overflows */
-        return 2;
-      }else{
-        /* zNum is exactly 9223372036854775808.  Fits if negative.  The
-        ** special case 2 overflow if positive */
-        assert( u-1==LARGEST_INT64 );
-        return neg ? rc : 3;
-      }
+      /* zNum is exactly 9223372036854775808.  Fits if negative.  The
+      ** special case 2 overflow if positive */
+      assert( u-1==LARGEST_INT64 );
+      return neg ? rc : 3;
     }
   }
 }
@@ -30934,81 +30463,80 @@
     /*  93 */ "Concat"           OpHelp("r[P3]=r[P2]+r[P1]"),
     /*  94 */ "Compare"          OpHelp("r[P1@P3] <-> r[P2@P3]"),
     /*  95 */ "BitNot"           OpHelp("r[P1]= ~r[P1]"),
-    /*  96 */ "IsTrue"           OpHelp("r[P2] = coalesce(r[P1]==TRUE,P3) ^ P4"),
+    /*  96 */ "Offset"           OpHelp("r[P3] = sqlite_offset(P1)"),
     /*  97 */ "String8"          OpHelp("r[P2]='P4'"),
-    /*  98 */ "Offset"           OpHelp("r[P3] = sqlite_offset(P1)"),
-    /*  99 */ "Column"           OpHelp("r[P3]=PX"),
-    /* 100 */ "Affinity"         OpHelp("affinity(r[P1@P2])"),
-    /* 101 */ "MakeRecord"       OpHelp("r[P3]=mkrec(r[P1@P2])"),
-    /* 102 */ "Count"            OpHelp("r[P2]=count()"),
-    /* 103 */ "ReadCookie"       OpHelp(""),
-    /* 104 */ "SetCookie"        OpHelp(""),
-    /* 105 */ "ReopenIdx"        OpHelp("root=P2 iDb=P3"),
-    /* 106 */ "OpenRead"         OpHelp("root=P2 iDb=P3"),
-    /* 107 */ "OpenWrite"        OpHelp("root=P2 iDb=P3"),
-    /* 108 */ "OpenDup"          OpHelp(""),
-    /* 109 */ "OpenAutoindex"    OpHelp("nColumn=P2"),
-    /* 110 */ "OpenEphemeral"    OpHelp("nColumn=P2"),
-    /* 111 */ "SorterOpen"       OpHelp(""),
-    /* 112 */ "SequenceTest"     OpHelp("if( cursor[P1].ctr++ ) pc = P2"),
-    /* 113 */ "OpenPseudo"       OpHelp("P3 columns in r[P2]"),
-    /* 114 */ "Close"            OpHelp(""),
-    /* 115 */ "ColumnsUsed"      OpHelp(""),
-    /* 116 */ "Sequence"         OpHelp("r[P2]=cursor[P1].ctr++"),
-    /* 117 */ "NewRowid"         OpHelp("r[P2]=rowid"),
-    /* 118 */ "Insert"           OpHelp("intkey=r[P3] data=r[P2]"),
-    /* 119 */ "InsertInt"        OpHelp("intkey=P3 data=r[P2]"),
-    /* 120 */ "Delete"           OpHelp(""),
-    /* 121 */ "ResetCount"       OpHelp(""),
-    /* 122 */ "SorterCompare"    OpHelp("if key(P1)!=trim(r[P3],P4) goto P2"),
-    /* 123 */ "SorterData"       OpHelp("r[P2]=data"),
-    /* 124 */ "RowData"          OpHelp("r[P2]=data"),
-    /* 125 */ "Rowid"            OpHelp("r[P2]=rowid"),
-    /* 126 */ "NullRow"          OpHelp(""),
-    /* 127 */ "SeekEnd"          OpHelp(""),
-    /* 128 */ "SorterInsert"     OpHelp("key=r[P2]"),
-    /* 129 */ "IdxInsert"        OpHelp("key=r[P2]"),
-    /* 130 */ "IdxDelete"        OpHelp("key=r[P2@P3]"),
-    /* 131 */ "DeferredSeek"     OpHelp("Move P3 to P1.rowid if needed"),
+    /*  98 */ "Column"           OpHelp("r[P3]=PX"),
+    /*  99 */ "Affinity"         OpHelp("affinity(r[P1@P2])"),
+    /* 100 */ "MakeRecord"       OpHelp("r[P3]=mkrec(r[P1@P2])"),
+    /* 101 */ "Count"            OpHelp("r[P2]=count()"),
+    /* 102 */ "ReadCookie"       OpHelp(""),
+    /* 103 */ "SetCookie"        OpHelp(""),
+    /* 104 */ "ReopenIdx"        OpHelp("root=P2 iDb=P3"),
+    /* 105 */ "OpenRead"         OpHelp("root=P2 iDb=P3"),
+    /* 106 */ "OpenWrite"        OpHelp("root=P2 iDb=P3"),
+    /* 107 */ "OpenDup"          OpHelp(""),
+    /* 108 */ "OpenAutoindex"    OpHelp("nColumn=P2"),
+    /* 109 */ "OpenEphemeral"    OpHelp("nColumn=P2"),
+    /* 110 */ "SorterOpen"       OpHelp(""),
+    /* 111 */ "SequenceTest"     OpHelp("if( cursor[P1].ctr++ ) pc = P2"),
+    /* 112 */ "OpenPseudo"       OpHelp("P3 columns in r[P2]"),
+    /* 113 */ "Close"            OpHelp(""),
+    /* 114 */ "ColumnsUsed"      OpHelp(""),
+    /* 115 */ "Sequence"         OpHelp("r[P2]=cursor[P1].ctr++"),
+    /* 116 */ "NewRowid"         OpHelp("r[P2]=rowid"),
+    /* 117 */ "Insert"           OpHelp("intkey=r[P3] data=r[P2]"),
+    /* 118 */ "InsertInt"        OpHelp("intkey=P3 data=r[P2]"),
+    /* 119 */ "Delete"           OpHelp(""),
+    /* 120 */ "ResetCount"       OpHelp(""),
+    /* 121 */ "SorterCompare"    OpHelp("if key(P1)!=trim(r[P3],P4) goto P2"),
+    /* 122 */ "SorterData"       OpHelp("r[P2]=data"),
+    /* 123 */ "RowData"          OpHelp("r[P2]=data"),
+    /* 124 */ "Rowid"            OpHelp("r[P2]=rowid"),
+    /* 125 */ "NullRow"          OpHelp(""),
+    /* 126 */ "SeekEnd"          OpHelp(""),
+    /* 127 */ "SorterInsert"     OpHelp("key=r[P2]"),
+    /* 128 */ "IdxInsert"        OpHelp("key=r[P2]"),
+    /* 129 */ "IdxDelete"        OpHelp("key=r[P2@P3]"),
+    /* 130 */ "DeferredSeek"     OpHelp("Move P3 to P1.rowid if needed"),
+    /* 131 */ "IdxRowid"         OpHelp("r[P2]=rowid"),
     /* 132 */ "Real"             OpHelp("r[P2]=P4"),
-    /* 133 */ "IdxRowid"         OpHelp("r[P2]=rowid"),
-    /* 134 */ "Destroy"          OpHelp(""),
-    /* 135 */ "Clear"            OpHelp(""),
-    /* 136 */ "ResetSorter"      OpHelp(""),
-    /* 137 */ "CreateBtree"      OpHelp("r[P2]=root iDb=P1 flags=P3"),
-    /* 138 */ "SqlExec"          OpHelp(""),
-    /* 139 */ "ParseSchema"      OpHelp(""),
-    /* 140 */ "LoadAnalysis"     OpHelp(""),
-    /* 141 */ "DropTable"        OpHelp(""),
-    /* 142 */ "DropIndex"        OpHelp(""),
-    /* 143 */ "DropTrigger"      OpHelp(""),
-    /* 144 */ "IntegrityCk"      OpHelp(""),
-    /* 145 */ "RowSetAdd"        OpHelp("rowset(P1)=r[P2]"),
-    /* 146 */ "Param"            OpHelp(""),
-    /* 147 */ "FkCounter"        OpHelp("fkctr[P1]+=P2"),
-    /* 148 */ "MemMax"           OpHelp("r[P1]=max(r[P1],r[P2])"),
-    /* 149 */ "OffsetLimit"      OpHelp("if r[P1]>0 then r[P2]=r[P1]+max(0,r[P3]) else r[P2]=(-1)"),
-    /* 150 */ "AggStep0"         OpHelp("accum=r[P3] step(r[P2@P5])"),
-    /* 151 */ "AggStep"          OpHelp("accum=r[P3] step(r[P2@P5])"),
-    /* 152 */ "AggFinal"         OpHelp("accum=r[P1] N=P2"),
-    /* 153 */ "Expire"           OpHelp(""),
-    /* 154 */ "TableLock"        OpHelp("iDb=P1 root=P2 write=P3"),
-    /* 155 */ "VBegin"           OpHelp(""),
-    /* 156 */ "VCreate"          OpHelp(""),
-    /* 157 */ "VDestroy"         OpHelp(""),
-    /* 158 */ "VOpen"            OpHelp(""),
-    /* 159 */ "VColumn"          OpHelp("r[P3]=vcolumn(P2)"),
-    /* 160 */ "VRename"          OpHelp(""),
-    /* 161 */ "Pagecount"        OpHelp(""),
-    /* 162 */ "MaxPgcnt"         OpHelp(""),
-    /* 163 */ "PureFunc0"        OpHelp(""),
-    /* 164 */ "Function0"        OpHelp("r[P3]=func(r[P2@P5])"),
-    /* 165 */ "PureFunc"         OpHelp(""),
-    /* 166 */ "Function"         OpHelp("r[P3]=func(r[P2@P5])"),
-    /* 167 */ "Trace"            OpHelp(""),
-    /* 168 */ "CursorHint"       OpHelp(""),
-    /* 169 */ "Noop"             OpHelp(""),
-    /* 170 */ "Explain"          OpHelp(""),
+    /* 133 */ "Destroy"          OpHelp(""),
+    /* 134 */ "Clear"            OpHelp(""),
+    /* 135 */ "ResetSorter"      OpHelp(""),
+    /* 136 */ "CreateBtree"      OpHelp("r[P2]=root iDb=P1 flags=P3"),
+    /* 137 */ "SqlExec"          OpHelp(""),
+    /* 138 */ "ParseSchema"      OpHelp(""),
+    /* 139 */ "LoadAnalysis"     OpHelp(""),
+    /* 140 */ "DropTable"        OpHelp(""),
+    /* 141 */ "DropIndex"        OpHelp(""),
+    /* 142 */ "DropTrigger"      OpHelp(""),
+    /* 143 */ "IntegrityCk"      OpHelp(""),
+    /* 144 */ "RowSetAdd"        OpHelp("rowset(P1)=r[P2]"),
+    /* 145 */ "Param"            OpHelp(""),
+    /* 146 */ "FkCounter"        OpHelp("fkctr[P1]+=P2"),
+    /* 147 */ "MemMax"           OpHelp("r[P1]=max(r[P1],r[P2])"),
+    /* 148 */ "OffsetLimit"      OpHelp("if r[P1]>0 then r[P2]=r[P1]+max(0,r[P3]) else r[P2]=(-1)"),
+    /* 149 */ "AggStep0"         OpHelp("accum=r[P3] step(r[P2@P5])"),
+    /* 150 */ "AggStep"          OpHelp("accum=r[P3] step(r[P2@P5])"),
+    /* 151 */ "AggFinal"         OpHelp("accum=r[P1] N=P2"),
+    /* 152 */ "Expire"           OpHelp(""),
+    /* 153 */ "TableLock"        OpHelp("iDb=P1 root=P2 write=P3"),
+    /* 154 */ "VBegin"           OpHelp(""),
+    /* 155 */ "VCreate"          OpHelp(""),
+    /* 156 */ "VDestroy"         OpHelp(""),
+    /* 157 */ "VOpen"            OpHelp(""),
+    /* 158 */ "VColumn"          OpHelp("r[P3]=vcolumn(P2)"),
+    /* 159 */ "VRename"          OpHelp(""),
+    /* 160 */ "Pagecount"        OpHelp(""),
+    /* 161 */ "MaxPgcnt"         OpHelp(""),
+    /* 162 */ "PureFunc0"        OpHelp(""),
+    /* 163 */ "Function0"        OpHelp("r[P3]=func(r[P2@P5])"),
+    /* 164 */ "PureFunc"         OpHelp(""),
+    /* 165 */ "Function"         OpHelp("r[P3]=func(r[P2@P5])"),
+    /* 166 */ "Trace"            OpHelp(""),
+    /* 167 */ "CursorHint"       OpHelp(""),
+    /* 168 */ "Noop"             OpHelp(""),
+    /* 169 */ "Explain"          OpHelp(""),
   };
   return azName[i];
 }
@@ -31247,9 +30775,6 @@
 #if SQLITE_ENABLE_LOCKING_STYLE || defined(__APPLE__)
   unsigned fsFlags;                   /* cached details from statfs() */
 #endif
-#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
-  unsigned iBusyTimeout;              /* Wait this many millisec on locks */
-#endif
 #if OS_VXWORKS
   struct vxworksFileId *pId;          /* Unique file ID */
 #endif
@@ -31687,11 +31212,7 @@
 #endif
 #define osFchown    ((int(*)(int,uid_t,gid_t))aSyscall[20].pCurrent)
 
-#if defined(HAVE_FCHOWN)
   { "geteuid",      (sqlite3_syscall_ptr)geteuid,         0 },
-#else
-  { "geteuid",      (sqlite3_syscall_ptr)0,               0 },
-#endif
 #define osGeteuid   ((uid_t(*)(void))aSyscall[21].pCurrent)
 
 #if !defined(SQLITE_OMIT_WAL) || SQLITE_MAX_MMAP_SIZE>0
@@ -31919,16 +31440,15 @@
 **     assert( unixMutexHeld() );
 **   unixEnterLeave()
 */
-static sqlite3_mutex *unixBigLock = 0;
 static void unixEnterMutex(void){
-  sqlite3_mutex_enter(unixBigLock);
+  sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1));
 }
 static void unixLeaveMutex(void){
-  sqlite3_mutex_leave(unixBigLock);
+  sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1));
 }
 #ifdef SQLITE_DEBUG
 static int unixMutexHeld(void) {
-  return sqlite3_mutex_held(unixBigLock);
+  return sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1));
 }
 #endif
 
@@ -32685,43 +32205,6 @@
 }
 
 /*
-** Set a posix-advisory-lock.
-**
-** There are two versions of this routine.  If compiled with
-** SQLITE_ENABLE_SETLK_TIMEOUT then the routine has an extra parameter
-** which is a pointer to a unixFile.  If the unixFile->iBusyTimeout
-** value is set, then it is the number of milliseconds to wait before
-** failing the lock.  The iBusyTimeout value is always reset back to
-** zero on each call.
-**
-** If SQLITE_ENABLE_SETLK_TIMEOUT is not defined, then do a non-blocking
-** attempt to set the lock.
-*/
-#ifndef SQLITE_ENABLE_SETLK_TIMEOUT
-# define osSetPosixAdvisoryLock(h,x,t) osFcntl(h,F_SETLK,x)
-#else
-static int osSetPosixAdvisoryLock(
-  int h,                /* The file descriptor on which to take the lock */
-  struct flock *pLock,  /* The description of the lock */
-  unixFile *pFile       /* Structure holding timeout value */
-){
-  int rc = osFcntl(h,F_SETLK,pLock);
-  while( rc<0 && pFile->iBusyTimeout>0 ){
-    /* On systems that support some kind of blocking file lock with a timeout,
-    ** make appropriate changes here to invoke that blocking file lock.  On
-    ** generic posix, however, there is no such API.  So we simply try the
-    ** lock once every millisecond until either the timeout expires, or until
-    ** the lock is obtained. */
-    usleep(1000);
-    rc = osFcntl(h,F_SETLK,pLock);
-    pFile->iBusyTimeout--;
-  }
-  return rc;
-}
-#endif /* SQLITE_ENABLE_SETLK_TIMEOUT */
-
-
-/*
 ** Attempt to set a system-lock on the file pFile.  The lock is 
 ** described by pLock.
 **
@@ -32753,7 +32236,7 @@
       lock.l_start = SHARED_FIRST;
       lock.l_len = SHARED_SIZE;
       lock.l_type = F_WRLCK;
-      rc = osSetPosixAdvisoryLock(pFile->h, &lock, pFile);
+      rc = osFcntl(pFile->h, F_SETLK, &lock);
       if( rc<0 ) return rc;
       pInode->bProcessLock = 1;
       pInode->nLock++;
@@ -32761,7 +32244,7 @@
       rc = 0;
     }
   }else{
-    rc = osSetPosixAdvisoryLock(pFile->h, pLock, pFile);
+    rc = osFcntl(pFile->h, F_SETLK, pLock);
   }
   return rc;
 }
@@ -34945,7 +34428,7 @@
   SimulateIOError( rc=1 );
   if( rc!=0 ){
     storeLastErrno((unixFile*)id, errno);
-    return SQLITE_IOERR_FSTAT;
+    return unixLogError(SQLITE_IOERR_FSTAT, "fstat", ((unixFile*)id)->zPath);
   }
   *pSize = buf.st_size;
 
@@ -34981,7 +34464,7 @@
     struct stat buf;              /* Used to hold return values of fstat() */
    
     if( osFstat(pFile->h, &buf) ){
-      return SQLITE_IOERR_FSTAT;
+      return unixLogError(SQLITE_IOERR_FSTAT, "fstat", pFile->zPath);
     }
 
     nSize = ((nByte+pFile->szChunk-1) / pFile->szChunk) * pFile->szChunk;
@@ -35121,12 +34604,6 @@
       *(int*)pArg = fileHasMoved(pFile);
       return SQLITE_OK;
     }
-#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
-    case SQLITE_FCNTL_LOCK_TIMEOUT: {
-      pFile->iBusyTimeout = *(int*)pArg;
-      return SQLITE_OK;
-    }
-#endif
 #if SQLITE_MAX_MMAP_SIZE>0
     case SQLITE_FCNTL_MMAP_SIZE: {
       i64 newLimit = *(i64*)pArg;
@@ -35442,11 +34919,13 @@
 
   if( pShmNode->h>=0 ){
     /* Initialize the locking parameters */
+    memset(&f, 0, sizeof(f));
     f.l_type = lockType;
     f.l_whence = SEEK_SET;
     f.l_start = ofst;
     f.l_len = n;
-    rc = osSetPosixAdvisoryLock(pShmNode->h, &f, pFile);
+
+    rc = osFcntl(pShmNode->h, F_SETLK, &f);
     rc = (rc!=(-1)) ? SQLITE_OK : SQLITE_BUSY;
   }
 
@@ -35660,7 +35139,7 @@
     ** with the same permissions.
     */
     if( osFstat(pDbFd->h, &sStat) ){
-      rc = SQLITE_IOERR_FSTAT;
+      rc = unixLogError(SQLITE_IOERR_FSTAT, "fstat", pDbFd->zPath);
       goto shm_open_err;
     }
 
@@ -37111,6 +36590,7 @@
     randomnessPid = osGetpid(0);
     sqlite3_randomness(0,0);
   }
+
   memset(p, 0, sizeof(unixFile));
 
   if( eType==SQLITE_OPEN_MAIN_DB ){
@@ -38985,7 +38465,6 @@
   for(i=0; i<(sizeof(aVfs)/sizeof(sqlite3_vfs)); i++){
     sqlite3_vfs_register(&aVfs[i], i==0);
   }
-  unixBigLock = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);
   return SQLITE_OK; 
 }
 
@@ -38997,7 +38476,6 @@
 ** This routine is a no-op for unix.
 */
 SQLITE_API int sqlite3_os_end(void){ 
-  unixBigLock = 0;
   return SQLITE_OK; 
 }
  
@@ -42836,16 +42314,15 @@
 **     assert( winShmMutexHeld() );
 **   winShmLeaveMutex()
 */
-static sqlite3_mutex *winBigLock = 0;
 static void winShmEnterMutex(void){
-  sqlite3_mutex_enter(winBigLock);
+  sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1));
 }
 static void winShmLeaveMutex(void){
-  sqlite3_mutex_leave(winBigLock);
+  sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1));
 }
 #ifndef NDEBUG
 static int winShmMutexHeld(void) {
-  return sqlite3_mutex_held(winBigLock);
+  return sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1));
 }
 #endif
 
@@ -45268,10 +44745,6 @@
   sqlite3_vfs_register(&winLongPathNolockVfs, 0);
 #endif
 
-#ifndef SQLITE_OMIT_WAL
-  winBigLock = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_VFS1);
-#endif
-
   return SQLITE_OK;
 }
 
@@ -45282,609 +44755,12 @@
     sleepObj = NULL;
   }
 #endif
-
-#ifndef SQLITE_OMIT_WAL
-  winBigLock = 0;
-#endif
-
   return SQLITE_OK;
 }
 
 #endif /* SQLITE_OS_WIN */
 
 /************** End of os_win.c **********************************************/
-/************** Begin file memdb.c *******************************************/
-/*
-** 2016-09-07
-**
-** The author disclaims copyright to this source code.  In place of
-** a legal notice, here is a blessing:
-**
-**    May you do good and not evil.
-**    May you find forgiveness for yourself and forgive others.
-**    May you share freely, never taking more than you give.
-**
-******************************************************************************
-**
-** This file implements an in-memory VFS. A database is held as a contiguous
-** block of memory.
-**
-** This file also implements interface sqlite3_serialize() and
-** sqlite3_deserialize().
-*/
-#ifdef SQLITE_ENABLE_DESERIALIZE
-/* #include "sqliteInt.h" */
-
-/*
-** Forward declaration of objects used by this utility
-*/
-typedef struct sqlite3_vfs MemVfs;
-typedef struct MemFile MemFile;
-
-/* Access to a lower-level VFS that (might) implement dynamic loading,
-** access to randomness, etc.
-*/
-#define ORIGVFS(p) ((sqlite3_vfs*)((p)->pAppData))
-
-/* An open file */
-struct MemFile {
-  sqlite3_file base;              /* IO methods */
-  sqlite3_int64 sz;               /* Size of the file */
-  sqlite3_int64 szMax;            /* Space allocated to aData */
-  unsigned char *aData;           /* content of the file */
-  int nMmap;                      /* Number of memory mapped pages */
-  unsigned mFlags;                /* Flags */
-  int eLock;                      /* Most recent lock against this file */
-};
-
-/*
-** Methods for MemFile
-*/
-static int memdbClose(sqlite3_file*);
-static int memdbRead(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
-static int memdbWrite(sqlite3_file*,const void*,int iAmt, sqlite3_int64 iOfst);
-static int memdbTruncate(sqlite3_file*, sqlite3_int64 size);
-static int memdbSync(sqlite3_file*, int flags);
-static int memdbFileSize(sqlite3_file*, sqlite3_int64 *pSize);
-static int memdbLock(sqlite3_file*, int);
-/* static int memdbCheckReservedLock(sqlite3_file*, int *pResOut);// not used */
-static int memdbFileControl(sqlite3_file*, int op, void *pArg);
-/* static int memdbSectorSize(sqlite3_file*); // not used */
-static int memdbDeviceCharacteristics(sqlite3_file*);
-static int memdbFetch(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp);
-static int memdbUnfetch(sqlite3_file*, sqlite3_int64 iOfst, void *p);
-
-/*
-** Methods for MemVfs
-*/
-static int memdbOpen(sqlite3_vfs*, const char *, sqlite3_file*, int , int *);
-/* static int memdbDelete(sqlite3_vfs*, const char *zName, int syncDir); */
-static int memdbAccess(sqlite3_vfs*, const char *zName, int flags, int *);
-static int memdbFullPathname(sqlite3_vfs*, const char *zName, int, char *zOut);
-static void *memdbDlOpen(sqlite3_vfs*, const char *zFilename);
-static void memdbDlError(sqlite3_vfs*, int nByte, char *zErrMsg);
-static void (*memdbDlSym(sqlite3_vfs *pVfs, void *p, const char*zSym))(void);
-static void memdbDlClose(sqlite3_vfs*, void*);
-static int memdbRandomness(sqlite3_vfs*, int nByte, char *zOut);
-static int memdbSleep(sqlite3_vfs*, int microseconds);
-/* static int memdbCurrentTime(sqlite3_vfs*, double*); */
-static int memdbGetLastError(sqlite3_vfs*, int, char *);
-static int memdbCurrentTimeInt64(sqlite3_vfs*, sqlite3_int64*);
-
-static sqlite3_vfs memdb_vfs = {
-  2,                           /* iVersion */
-  0,                           /* szOsFile (set when registered) */
-  1024,                        /* mxPathname */
-  0,                           /* pNext */
-  "memdb",                     /* zName */
-  0,                           /* pAppData (set when registered) */ 
-  memdbOpen,                   /* xOpen */
-  0, /* memdbDelete, */        /* xDelete */
-  memdbAccess,                 /* xAccess */
-  memdbFullPathname,           /* xFullPathname */
-  memdbDlOpen,                 /* xDlOpen */
-  memdbDlError,                /* xDlError */
-  memdbDlSym,                  /* xDlSym */
-  memdbDlClose,                /* xDlClose */
-  memdbRandomness,             /* xRandomness */
-  memdbSleep,                  /* xSleep */
-  0, /* memdbCurrentTime, */   /* xCurrentTime */
-  memdbGetLastError,           /* xGetLastError */
-  memdbCurrentTimeInt64        /* xCurrentTimeInt64 */
-};
-
-static const sqlite3_io_methods memdb_io_methods = {
-  3,                              /* iVersion */
-  memdbClose,                      /* xClose */
-  memdbRead,                       /* xRead */
-  memdbWrite,                      /* xWrite */
-  memdbTruncate,                   /* xTruncate */
-  memdbSync,                       /* xSync */
-  memdbFileSize,                   /* xFileSize */
-  memdbLock,                       /* xLock */
-  memdbLock,                       /* xUnlock - same as xLock in this case */ 
-  0, /* memdbCheckReservedLock, */ /* xCheckReservedLock */
-  memdbFileControl,                /* xFileControl */
-  0, /* memdbSectorSize,*/         /* xSectorSize */
-  memdbDeviceCharacteristics,      /* xDeviceCharacteristics */
-  0,                               /* xShmMap */
-  0,                               /* xShmLock */
-  0,                               /* xShmBarrier */
-  0,                               /* xShmUnmap */
-  memdbFetch,                      /* xFetch */
-  memdbUnfetch                     /* xUnfetch */
-};
-
-
-
-/*
-** Close an memdb-file.
-**
-** The pData pointer is owned by the application, so there is nothing
-** to free.
-*/
-static int memdbClose(sqlite3_file *pFile){
-  MemFile *p = (MemFile *)pFile;
-  if( p->mFlags & SQLITE_DESERIALIZE_FREEONCLOSE ) sqlite3_free(p->aData);
-  return SQLITE_OK;
-}
-
-/*
-** Read data from an memdb-file.
-*/
-static int memdbRead(
-  sqlite3_file *pFile, 
-  void *zBuf, 
-  int iAmt, 
-  sqlite_int64 iOfst
-){
-  MemFile *p = (MemFile *)pFile;
-  if( iOfst+iAmt>p->sz ){
-    memset(zBuf, 0, iAmt);
-    if( iOfst<p->sz ) memcpy(zBuf, p->aData+iOfst, p->sz - iOfst);
-    return SQLITE_IOERR_SHORT_READ;
-  }
-  memcpy(zBuf, p->aData+iOfst, iAmt);
-  return SQLITE_OK;
-}
-
-/*
-** Try to enlarge the memory allocation to hold at least sz bytes
-*/
-static int memdbEnlarge(MemFile *p, sqlite3_int64 newSz){
-  unsigned char *pNew;
-  if( (p->mFlags & SQLITE_DESERIALIZE_RESIZEABLE)==0 || p->nMmap>0 ){
-    return SQLITE_FULL;
-  }
-  pNew = sqlite3_realloc64(p->aData, newSz);
-  if( pNew==0 ) return SQLITE_NOMEM;
-  p->aData = pNew;
-  p->szMax = newSz;
-  return SQLITE_OK;
-}
-
-/*
-** Write data to an memdb-file.
-*/
-static int memdbWrite(
-  sqlite3_file *pFile,
-  const void *z,
-  int iAmt,
-  sqlite_int64 iOfst
-){
-  MemFile *p = (MemFile *)pFile;
-  if( iOfst+iAmt>p->sz ){
-    int rc;
-    if( iOfst+iAmt>p->szMax
-     && (rc = memdbEnlarge(p, (iOfst+iAmt)*2))!=SQLITE_OK
-    ){
-      return rc;
-    }
-    if( iOfst>p->sz ) memset(p->aData+p->sz, 0, iOfst-p->sz);
-    p->sz = iOfst+iAmt;
-  }
-  memcpy(p->aData+iOfst, z, iAmt);
-  return SQLITE_OK;
-}
-
-/*
-** Truncate an memdb-file.
-**
-** In rollback mode (which is always the case for memdb, as it does not
-** support WAL mode) the truncate() method is only used to reduce
-** the size of a file, never to increase the size.
-*/
-static int memdbTruncate(sqlite3_file *pFile, sqlite_int64 size){
-  MemFile *p = (MemFile *)pFile;
-  if( NEVER(size>p->sz) ) return SQLITE_FULL;
-  p->sz = size; 
-  return SQLITE_OK;
-}
-
-/*
-** Sync an memdb-file.
-*/
-static int memdbSync(sqlite3_file *pFile, int flags){
-  return SQLITE_OK;
-}
-
-/*
-** Return the current file-size of an memdb-file.
-*/
-static int memdbFileSize(sqlite3_file *pFile, sqlite_int64 *pSize){
-  MemFile *p = (MemFile *)pFile;
-  *pSize = p->sz;
-  return SQLITE_OK;
-}
-
-/*
-** Lock an memdb-file.
-*/
-static int memdbLock(sqlite3_file *pFile, int eLock){
-  MemFile *p = (MemFile *)pFile;
-  p->eLock = eLock;
-  return SQLITE_OK;
-}
-
-#if 0 /* Never used because memdbAccess() always returns false */
-/*
-** Check if another file-handle holds a RESERVED lock on an memdb-file.
-*/
-static int memdbCheckReservedLock(sqlite3_file *pFile, int *pResOut){
-  *pResOut = 0;
-  return SQLITE_OK;
-}
-#endif
-
-/*
-** File control method. For custom operations on an memdb-file.
-*/
-static int memdbFileControl(sqlite3_file *pFile, int op, void *pArg){
-  MemFile *p = (MemFile *)pFile;
-  int rc = SQLITE_NOTFOUND;
-  if( op==SQLITE_FCNTL_VFSNAME ){
-    *(char**)pArg = sqlite3_mprintf("memdb(%p,%lld)", p->aData, p->sz);
-    rc = SQLITE_OK;
-  }
-  return rc;
-}
-
-#if 0  /* Not used because of SQLITE_IOCAP_POWERSAFE_OVERWRITE */
-/*
-** Return the sector-size in bytes for an memdb-file.
-*/
-static int memdbSectorSize(sqlite3_file *pFile){
-  return 1024;
-}
-#endif
-
-/*
-** Return the device characteristic flags supported by an memdb-file.
-*/
-static int memdbDeviceCharacteristics(sqlite3_file *pFile){
-  return SQLITE_IOCAP_ATOMIC | 
-         SQLITE_IOCAP_POWERSAFE_OVERWRITE |
-         SQLITE_IOCAP_SAFE_APPEND |
-         SQLITE_IOCAP_SEQUENTIAL;
-}
-
-/* Fetch a page of a memory-mapped file */
-static int memdbFetch(
-  sqlite3_file *pFile,
-  sqlite3_int64 iOfst,
-  int iAmt,
-  void **pp
-){
-  MemFile *p = (MemFile *)pFile;
-  p->nMmap++;
-  *pp = (void*)(p->aData + iOfst);
-  return SQLITE_OK;
-}
-
-/* Release a memory-mapped page */
-static int memdbUnfetch(sqlite3_file *pFile, sqlite3_int64 iOfst, void *pPage){
-  MemFile *p = (MemFile *)pFile;
-  p->nMmap--;
-  return SQLITE_OK;
-}
-
-/*
-** Open an mem file handle.
-*/
-static int memdbOpen(
-  sqlite3_vfs *pVfs,
-  const char *zName,
-  sqlite3_file *pFile,
-  int flags,
-  int *pOutFlags
-){
-  MemFile *p = (MemFile*)pFile;
-  if( (flags & SQLITE_OPEN_MAIN_DB)==0 ){
-    return ORIGVFS(pVfs)->xOpen(ORIGVFS(pVfs), zName, pFile, flags, pOutFlags);
-  }
-  memset(p, 0, sizeof(*p));
-  p->mFlags = SQLITE_DESERIALIZE_RESIZEABLE | SQLITE_DESERIALIZE_FREEONCLOSE;
-  assert( pOutFlags!=0 );  /* True because flags==SQLITE_OPEN_MAIN_DB */
-  *pOutFlags = flags | SQLITE_OPEN_MEMORY;
-  p->base.pMethods = &memdb_io_methods;
-  return SQLITE_OK;
-}
-
-#if 0 /* Only used to delete rollback journals, master journals, and WAL
-      ** files, none of which exist in memdb.  So this routine is never used */
-/*
-** Delete the file located at zPath. If the dirSync argument is true,
-** ensure the file-system modifications are synced to disk before
-** returning.
-*/
-static int memdbDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){
-  return SQLITE_IOERR_DELETE;
-}
-#endif
-
-/*
-** Test for access permissions. Return true if the requested permission
-** is available, or false otherwise.
-**
-** With memdb, no files ever exist on disk.  So always return false.
-*/
-static int memdbAccess(
-  sqlite3_vfs *pVfs, 
-  const char *zPath, 
-  int flags, 
-  int *pResOut
-){
-  *pResOut = 0;
-  return SQLITE_OK;
-}
-
-/*
-** Populate buffer zOut with the full canonical pathname corresponding
-** to the pathname in zPath. zOut is guaranteed to point to a buffer
-** of at least (INST_MAX_PATHNAME+1) bytes.
-*/
-static int memdbFullPathname(
-  sqlite3_vfs *pVfs, 
-  const char *zPath, 
-  int nOut, 
-  char *zOut
-){
-  sqlite3_snprintf(nOut, zOut, "%s", zPath);
-  return SQLITE_OK;
-}
-
-/*
-** Open the dynamic library located at zPath and return a handle.
-*/
-static void *memdbDlOpen(sqlite3_vfs *pVfs, const char *zPath){
-  return ORIGVFS(pVfs)->xDlOpen(ORIGVFS(pVfs), zPath);
-}
-
-/*
-** Populate the buffer zErrMsg (size nByte bytes) with a human readable
-** utf-8 string describing the most recent error encountered associated 
-** with dynamic libraries.
-*/
-static void memdbDlError(sqlite3_vfs *pVfs, int nByte, char *zErrMsg){
-  ORIGVFS(pVfs)->xDlError(ORIGVFS(pVfs), nByte, zErrMsg);
-}
-
-/*
-** Return a pointer to the symbol zSymbol in the dynamic library pHandle.
-*/
-static void (*memdbDlSym(sqlite3_vfs *pVfs, void *p, const char *zSym))(void){
-  return ORIGVFS(pVfs)->xDlSym(ORIGVFS(pVfs), p, zSym);
-}
-
-/*
-** Close the dynamic library handle pHandle.
-*/
-static void memdbDlClose(sqlite3_vfs *pVfs, void *pHandle){
-  ORIGVFS(pVfs)->xDlClose(ORIGVFS(pVfs), pHandle);
-}
-
-/*
-** Populate the buffer pointed to by zBufOut with nByte bytes of 
-** random data.
-*/
-static int memdbRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){
-  return ORIGVFS(pVfs)->xRandomness(ORIGVFS(pVfs), nByte, zBufOut);
-}
-
-/*
-** Sleep for nMicro microseconds. Return the number of microseconds 
-** actually slept.
-*/
-static int memdbSleep(sqlite3_vfs *pVfs, int nMicro){
-  return ORIGVFS(pVfs)->xSleep(ORIGVFS(pVfs), nMicro);
-}
-
-#if 0  /* Never used.  Modern cores only call xCurrentTimeInt64() */
-/*
-** Return the current time as a Julian Day number in *pTimeOut.
-*/
-static int memdbCurrentTime(sqlite3_vfs *pVfs, double *pTimeOut){
-  return ORIGVFS(pVfs)->xCurrentTime(ORIGVFS(pVfs), pTimeOut);
-}
-#endif
-
-static int memdbGetLastError(sqlite3_vfs *pVfs, int a, char *b){
-  return ORIGVFS(pVfs)->xGetLastError(ORIGVFS(pVfs), a, b);
-}
-static int memdbCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *p){
-  return ORIGVFS(pVfs)->xCurrentTimeInt64(ORIGVFS(pVfs), p);
-}
-
-/*
-** Translate a database connection pointer and schema name into a
-** MemFile pointer.
-*/
-static MemFile *memdbFromDbSchema(sqlite3 *db, const char *zSchema){
-  MemFile *p = 0;
-  int rc = sqlite3_file_control(db, zSchema, SQLITE_FCNTL_FILE_POINTER, &p);
-  if( rc ) return 0;
-  if( p->base.pMethods!=&memdb_io_methods ) return 0;
-  return p;
-}
-
-/*
-** Return the serialization of a database
-*/
-SQLITE_API unsigned char *sqlite3_serialize(
-  sqlite3 *db,              /* The database connection */
-  const char *zSchema,      /* Which database within the connection */
-  sqlite3_int64 *piSize,    /* Write size here, if not NULL */
-  unsigned int mFlags       /* Maybe SQLITE_SERIALIZE_NOCOPY */
-){
-  MemFile *p;
-  int iDb;
-  Btree *pBt;
-  sqlite3_int64 sz;
-  int szPage = 0;
-  sqlite3_stmt *pStmt = 0;
-  unsigned char *pOut;
-  char *zSql;
-  int rc;
-
-#ifdef SQLITE_ENABLE_API_ARMOR
-  if( !sqlite3SafetyCheckOk(db) ){
-    (void)SQLITE_MISUSE_BKPT;
-    return 0;
-  }
-#endif
-
-  if( zSchema==0 ) zSchema = db->aDb[0].zDbSName;
-  p = memdbFromDbSchema(db, zSchema);
-  iDb = sqlite3FindDbName(db, zSchema);
-  if( piSize ) *piSize = -1;
-  if( iDb<0 ) return 0;
-  if( p ){
-    if( piSize ) *piSize = p->sz;
-    if( mFlags & SQLITE_SERIALIZE_NOCOPY ){
-      pOut = p->aData;
-    }else{
-      pOut = sqlite3_malloc64( p->sz );
-      if( pOut ) memcpy(pOut, p->aData, p->sz);
-    }
-    return pOut;
-  }
-  pBt = db->aDb[iDb].pBt;
-  if( pBt==0 ) return 0;
-  szPage = sqlite3BtreeGetPageSize(pBt);
-  zSql = sqlite3_mprintf("PRAGMA \"%w\".page_count", zSchema);
-  rc = zSql ? sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0) : SQLITE_NOMEM;
-  sqlite3_free(zSql);
-  if( rc ) return 0;
-  rc = sqlite3_step(pStmt);
-  if( rc!=SQLITE_ROW ){
-    pOut = 0;
-  }else{
-    sz = sqlite3_column_int64(pStmt, 0)*szPage;
-    if( piSize ) *piSize = sz;
-    if( mFlags & SQLITE_SERIALIZE_NOCOPY ){
-      pOut = 0;
-    }else{
-      pOut = sqlite3_malloc64( sz );
-      if( pOut ){
-        int nPage = sqlite3_column_int(pStmt, 0);
-        Pager *pPager = sqlite3BtreePager(pBt);
-        int pgno;
-        for(pgno=1; pgno<=nPage; pgno++){
-          DbPage *pPage = 0;
-          unsigned char *pTo = pOut + szPage*(sqlite3_int64)(pgno-1);
-          rc = sqlite3PagerGet(pPager, pgno, (DbPage**)&pPage, 0);
-          if( rc==SQLITE_OK ){
-            memcpy(pTo, sqlite3PagerGetData(pPage), szPage);
-          }else{
-            memset(pTo, 0, szPage);
-          }
-          sqlite3PagerUnref(pPage);       
-        }
-      }
-    }
-  }
-  sqlite3_finalize(pStmt);
-  return pOut;
-}
-
-/* Convert zSchema to a MemDB and initialize its content.
-*/
-SQLITE_API int sqlite3_deserialize(
-  sqlite3 *db,            /* The database connection */
-  const char *zSchema,    /* Which DB to reopen with the deserialization */
-  unsigned char *pData,   /* The serialized database content */
-  sqlite3_int64 szDb,     /* Number bytes in the deserialization */
-  sqlite3_int64 szBuf,    /* Total size of buffer pData[] */
-  unsigned mFlags         /* Zero or more SQLITE_DESERIALIZE_* flags */
-){
-  MemFile *p;
-  char *zSql;
-  sqlite3_stmt *pStmt = 0;
-  int rc;
-  int iDb;
-
-#ifdef SQLITE_ENABLE_API_ARMOR
-  if( !sqlite3SafetyCheckOk(db) ){
-    return SQLITE_MISUSE_BKPT;
-  }
-  if( szDb<0 ) return SQLITE_MISUSE_BKPT;
-  if( szBuf<0 ) return SQLITE_MISUSE_BKPT;
-#endif
-
-  sqlite3_mutex_enter(db->mutex);
-  if( zSchema==0 ) zSchema = db->aDb[0].zDbSName;
-  iDb = sqlite3FindDbName(db, zSchema);
-  if( iDb<0 ){
-    rc = SQLITE_ERROR;
-    goto end_deserialize;
-  }    
-  zSql = sqlite3_mprintf("ATTACH x AS %Q", zSchema);
-  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
-  sqlite3_free(zSql);
-  if( rc ) goto end_deserialize;
-  db->init.iDb = (u8)iDb;
-  db->init.reopenMemdb = 1;
-  rc = sqlite3_step(pStmt);
-  db->init.reopenMemdb = 0;
-  if( rc!=SQLITE_DONE ){
-    rc = SQLITE_ERROR;
-    goto end_deserialize;
-  }
-  p = memdbFromDbSchema(db, zSchema);
-  if( p==0 ){
-    rc = SQLITE_ERROR;
-  }else{
-    p->aData = pData;
-    p->sz = szDb;
-    p->szMax = szBuf;
-    p->mFlags = mFlags;
-    rc = SQLITE_OK;
-  }
-
-end_deserialize:
-  sqlite3_finalize(pStmt);
-  sqlite3_mutex_leave(db->mutex);
-  return rc;
-}
-
-/* 
-** This routine is called when the extension is loaded.
-** Register the new VFS.
-*/
-SQLITE_PRIVATE int sqlite3MemdbInit(void){
-  sqlite3_vfs *pLower = sqlite3_vfs_find(0);
-  int sz = pLower->szOsFile;
-  memdb_vfs.pAppData = pLower;
-  /* In all known configurations of SQLite, the size of a default
-  ** sqlite3_file is greater than the size of a memdb sqlite3_file.
-  ** Should that ever change, remove the following NEVER() */
-  if( NEVER(sz<sizeof(MemFile)) ) sz = sizeof(MemFile);
-  memdb_vfs.szOsFile = sz;
-  return sqlite3_vfs_register(&memdb_vfs, 0);
-}
-#endif /* SQLITE_ENABLE_DESERIALIZE */
-
-/************** End of memdb.c ***********************************************/
 /************** Begin file bitvec.c ******************************************/
 /*
 ** 2008 February 16
@@ -46733,7 +45609,7 @@
       sqlite3_log(SQLITE_FULL, 
                   "spill page %d making room for %d - cache used: %d/%d",
                   pPg->pgno, pgno,
-                  sqlite3GlobalConfig.pcache2.xPagecount(pCache->pCache),
+                  sqlite3GlobalConfig.pcache.xPagecount(pCache->pCache),
                 numberOfCachePages(pCache));
 #endif
       pcacheTrace(("%p.SPILL %d\n",pCache,pPg->pgno));
@@ -49789,7 +48665,7 @@
   char *zJournal;             /* Name of the journal file */
   int (*xBusyHandler)(void*); /* Function to call when busy */
   void *pBusyHandlerArg;      /* Context argument for xBusyHandler */
-  int aStat[4];               /* Total cache hits, misses, writes, spills */
+  int aStat[3];               /* Total cache hits, misses and writes */
 #ifdef SQLITE_TEST
   int nRead;                  /* Database pages read */
 #endif
@@ -49817,7 +48693,6 @@
 #define PAGER_STAT_HIT   0
 #define PAGER_STAT_MISS  1
 #define PAGER_STAT_WRITE 2
-#define PAGER_STAT_SPILL 3
 
 /*
 ** The following global variables hold counters used for
@@ -50304,7 +49179,7 @@
 #endif
 
 #ifdef SQLITE_ENABLE_BATCH_ATOMIC_WRITE
-  if( pPager->dbSize>0 && (dc&SQLITE_IOCAP_BATCH_ATOMIC) ){
+  if( dc&SQLITE_IOCAP_BATCH_ATOMIC ){
     return -1;
   }
 #endif
@@ -51220,7 +50095,7 @@
     rc = pager_truncate(pPager, pPager->dbSize);
   }
 
-  if( rc==SQLITE_OK && bCommit ){
+  if( rc==SQLITE_OK && bCommit && isOpen(pPager->fd) ){
     rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_COMMIT_PHASETWO, 0);
     if( rc==SQLITE_NOTFOUND ) rc = SQLITE_OK;
   }
@@ -52039,7 +50914,9 @@
   ** assertion that the transaction counter was modified.
   */
 #ifdef SQLITE_DEBUG
-  sqlite3OsFileControlHint(pPager->fd,SQLITE_FCNTL_DB_UNCHANGED,0);
+  if( pPager->fd->pMethods ){
+    sqlite3OsFileControlHint(pPager->fd,SQLITE_FCNTL_DB_UNCHANGED,0);
+  }
 #endif
 
   /* If this playback is happening automatically as a result of an IO or 
@@ -52792,18 +51669,20 @@
 ** retried. If it returns zero, then the SQLITE_BUSY error is
 ** returned to the caller of the pager API function.
 */
-SQLITE_PRIVATE void sqlite3PagerSetBusyHandler(
+SQLITE_PRIVATE void sqlite3PagerSetBusyhandler(
   Pager *pPager,                       /* Pager object */
   int (*xBusyHandler)(void *),         /* Pointer to busy-handler function */
   void *pBusyHandlerArg                /* Argument to pass to xBusyHandler */
 ){
-  void **ap;
   pPager->xBusyHandler = xBusyHandler;
   pPager->pBusyHandlerArg = pBusyHandlerArg;
-  ap = (void **)&pPager->xBusyHandler;
-  assert( ((int(*)(void *))(ap[0]))==xBusyHandler );
-  assert( ap[1]==pBusyHandlerArg );
-  sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_BUSYHANDLER, (void *)ap);
+
+  if( isOpen(pPager->fd) ){
+    void **ap = (void **)&pPager->xBusyHandler;
+    assert( ((int(*)(void *))(ap[0]))==xBusyHandler );
+    assert( ap[1]==pBusyHandlerArg );
+    sqlite3OsFileControlHint(pPager->fd, SQLITE_FCNTL_BUSYHANDLER, (void *)ap);
+  }
 }
 
 /*
@@ -53189,30 +52068,6 @@
   }
 }
 
-/* Verify that the database file has not be deleted or renamed out from
-** under the pager.  Return SQLITE_OK if the database is still where it ought
-** to be on disk.  Return non-zero (SQLITE_READONLY_DBMOVED or some other error
-** code from sqlite3OsAccess()) if the database has gone missing.
-*/
-static int databaseIsUnmoved(Pager *pPager){
-  int bHasMoved = 0;
-  int rc;
-
-  if( pPager->tempFile ) return SQLITE_OK;
-  if( pPager->dbSize==0 ) return SQLITE_OK;
-  assert( pPager->zFilename && pPager->zFilename[0] );
-  rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_HAS_MOVED, &bHasMoved);
-  if( rc==SQLITE_NOTFOUND ){
-    /* If the HAS_MOVED file-control is unimplemented, assume that the file
-    ** has not been moved.  That is the historical behavior of SQLite: prior to
-    ** version 3.8.3, it never checked */
-    rc = SQLITE_OK;
-  }else if( rc==SQLITE_OK && bHasMoved ){
-    rc = SQLITE_READONLY_DBMOVED;
-  }
-  return rc;
-}
-
 
 /*
 ** Shutdown the page cache.  Free all memory and close all files.
@@ -53229,7 +52084,8 @@
 ** to the caller.
 */
 SQLITE_PRIVATE int sqlite3PagerClose(Pager *pPager, sqlite3 *db){
-  u8 *pTmp = (u8*)pPager->pTmpSpace;
+  u8 *pTmp = (u8 *)pPager->pTmpSpace;
+
   assert( db || pagerUseWal(pPager)==0 );
   assert( assert_pager_state(pPager) );
   disable_simulated_io_errors();
@@ -53238,17 +52094,11 @@
   /* pPager->errCode = 0; */
   pPager->exclusiveMode = 0;
 #ifndef SQLITE_OMIT_WAL
-  {
-    u8 *a = 0;
-    assert( db || pPager->pWal==0 );
-    if( db && 0==(db->flags & SQLITE_NoCkptOnClose) 
-     && SQLITE_OK==databaseIsUnmoved(pPager)
-    ){
-      a = pTmp;
-    }
-    sqlite3WalClose(pPager->pWal, db, pPager->walSyncFlags, pPager->pageSize,a);
-    pPager->pWal = 0;
-  }
+  assert( db || pPager->pWal==0 );
+  sqlite3WalClose(pPager->pWal, db, pPager->walSyncFlags, pPager->pageSize,
+      (db && (db->flags & SQLITE_NoCkptOnClose) ? 0 : pTmp)
+  );
+  pPager->pWal = 0;
 #endif
   pager_reset(pPager);
   if( MEMDB ){
@@ -53705,7 +52555,6 @@
     return SQLITE_OK;
   }
 
-  pPager->aStat[PAGER_STAT_SPILL]++;
   pPg->pDirty = 0;
   if( pagerUseWal(pPager) ){
     /* Write a single frame for this page to the log. */
@@ -53811,11 +52660,6 @@
   int rc = SQLITE_OK;      /* Return code */
   int tempFile = 0;        /* True for temp files (incl. in-memory files) */
   int memDb = 0;           /* True if this is an in-memory file */
-#ifdef SQLITE_ENABLE_DESERIALIZE
-  int memJM = 0;           /* Memory journal mode */
-#else
-# define memJM 0
-#endif
   int readOnly = 0;        /* True if this is a read-only file */
   int journalFileSize;     /* Bytes to allocate for each journal fd */
   char *zPathname = 0;     /* Full path to database file */
@@ -53943,10 +52787,7 @@
     int fout = 0;                    /* VFS flags returned by xOpen() */
     rc = sqlite3OsOpen(pVfs, pPager->zFilename, pPager->fd, vfsFlags, &fout);
     assert( !memDb );
-#ifdef SQLITE_ENABLE_DESERIALIZE
-    memJM = (fout&SQLITE_OPEN_MEMORY)!=0;
-#endif
-    readOnly = (fout&SQLITE_OPEN_READONLY)!=0;
+    readOnly = (fout&SQLITE_OPEN_READONLY);
 
     /* If the file was successfully opened for read/write access,
     ** choose a default page size in case we have to create the
@@ -54077,7 +52918,7 @@
   setSectorSize(pPager);
   if( !useJournal ){
     pPager->journalMode = PAGER_JOURNALMODE_OFF;
-  }else if( memDb || memJM ){
+  }else if( memDb ){
     pPager->journalMode = PAGER_JOURNALMODE_MEMORY;
   }
   /* pPager->xBusyHandler = 0; */
@@ -54092,6 +52933,30 @@
 }
 
 
+/* Verify that the database file has not be deleted or renamed out from
+** under the pager.  Return SQLITE_OK if the database is still were it ought
+** to be on disk.  Return non-zero (SQLITE_READONLY_DBMOVED or some other error
+** code from sqlite3OsAccess()) if the database has gone missing.
+*/
+static int databaseIsUnmoved(Pager *pPager){
+  int bHasMoved = 0;
+  int rc;
+
+  if( pPager->tempFile ) return SQLITE_OK;
+  if( pPager->dbSize==0 ) return SQLITE_OK;
+  assert( pPager->zFilename && pPager->zFilename[0] );
+  rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_HAS_MOVED, &bHasMoved);
+  if( rc==SQLITE_NOTFOUND ){
+    /* If the HAS_MOVED file-control is unimplemented, assume that the file
+    ** has not been moved.  That is the historical behavior of SQLite: prior to
+    ** version 3.8.3, it never checked */
+    rc = SQLITE_OK;
+  }else if( rc==SQLITE_OK && bHasMoved ){
+    rc = SQLITE_READONLY_DBMOVED;
+  }
+  return rc;
+}
+
 
 /*
 ** This function is called after transitioning from PAGER_UNLOCK to
@@ -54779,7 +53644,6 @@
   assert( pPg->pgno==1 );
   assert( (pPg->flags & PGHDR_MMAP)==0 ); /* Page1 is never memory mapped */
   pPager = pPg->pPager;
-  sqlite3PagerResetLockTimeout(pPager);
   sqlite3PcacheRelease(pPg);
   pagerUnlockIfUnused(pPager);
 }
@@ -55375,9 +54239,12 @@
 */
 SQLITE_PRIVATE int sqlite3PagerSync(Pager *pPager, const char *zMaster){
   int rc = SQLITE_OK;
-  void *pArg = (void*)zMaster;
-  rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_SYNC, pArg);
-  if( rc==SQLITE_NOTFOUND ) rc = SQLITE_OK;
+
+  if( isOpen(pPager->fd) ){
+    void *pArg = (void*)zMaster;
+    rc = sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_SYNC, pArg);
+    if( rc==SQLITE_NOTFOUND ) rc = SQLITE_OK;
+  }
   if( rc==SQLITE_OK && !pPager->noSync ){
     assert( !MEMDB );
     rc = sqlite3OsSync(pPager->fd, pPager->syncFlags);
@@ -55598,9 +54465,8 @@
       if( bBatch ){
         if( rc==SQLITE_OK ){
           rc = sqlite3OsFileControl(fd, SQLITE_FCNTL_COMMIT_ATOMIC_WRITE, 0);
-        }
-        if( rc!=SQLITE_OK ){
-          sqlite3OsFileControlHint(fd, SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE, 0);
+        }else{
+          sqlite3OsFileControl(fd, SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE, 0);
         }
       }
 
@@ -55824,12 +54690,8 @@
 #endif
 
 /*
-** Parameter eStat must be one of SQLITE_DBSTATUS_CACHE_HIT, _MISS, _WRITE,
-** or _WRITE+1.  The SQLITE_DBSTATUS_CACHE_WRITE+1 case is a translation
-** of SQLITE_DBSTATUS_CACHE_SPILL.  The _SPILL case is not contiguous because
-** it was added later.
-**
-** Before returning, *pnVal is incremented by the
+** Parameter eStat must be either SQLITE_DBSTATUS_CACHE_HIT or
+** SQLITE_DBSTATUS_CACHE_MISS. Before returning, *pnVal is incremented by the
 ** current cache hit or miss count, according to the value of eStat. If the 
 ** reset parameter is non-zero, the cache hit or miss count is zeroed before 
 ** returning.
@@ -55839,18 +54701,15 @@
   assert( eStat==SQLITE_DBSTATUS_CACHE_HIT
        || eStat==SQLITE_DBSTATUS_CACHE_MISS
        || eStat==SQLITE_DBSTATUS_CACHE_WRITE
-       || eStat==SQLITE_DBSTATUS_CACHE_WRITE+1
   );
 
   assert( SQLITE_DBSTATUS_CACHE_HIT+1==SQLITE_DBSTATUS_CACHE_MISS );
   assert( SQLITE_DBSTATUS_CACHE_HIT+2==SQLITE_DBSTATUS_CACHE_WRITE );
-  assert( PAGER_STAT_HIT==0 && PAGER_STAT_MISS==1
-           && PAGER_STAT_WRITE==2 && PAGER_STAT_SPILL==3 );
+  assert( PAGER_STAT_HIT==0 && PAGER_STAT_MISS==1 && PAGER_STAT_WRITE==2 );
 
-  eStat -= SQLITE_DBSTATUS_CACHE_HIT;
-  *pnVal += pPager->aStat[eStat];
+  *pnVal += pPager->aStat[eStat - SQLITE_DBSTATUS_CACHE_HIT];
   if( reset ){
-    pPager->aStat[eStat] = 0;
+    pPager->aStat[eStat - SQLITE_DBSTATUS_CACHE_HIT] = 0;
   }
 }
 
@@ -56054,16 +54913,6 @@
   return pPager->fd;
 }
 
-#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
-/*
-** Reset the lock timeout for pager.
-*/
-SQLITE_PRIVATE void sqlite3PagerResetLockTimeout(Pager *pPager){
-  int x = 0;
-  sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_LOCK_TIMEOUT, &x);
-}
-#endif
-
 /*
 ** Return the file handle for the journal file (if it exists).
 ** This will be either the rollback journal or the WAL file.
@@ -56524,7 +55373,6 @@
         pPager->walSyncFlags, pPager->pageSize, (u8 *)pPager->pTmpSpace,
         pnLog, pnCkpt
     );
-    sqlite3PagerResetLockTimeout(pPager);
   }
   return rc;
 }
@@ -57307,11 +56155,7 @@
 ** page and SQLITE_OK is returned. If an error (an OOM or VFS error) occurs,
 ** then an SQLite error code is returned and *ppPage is set to 0.
 */
-static SQLITE_NOINLINE int walIndexPageRealloc(
-  Wal *pWal,               /* The WAL context */
-  int iPage,               /* The page we seek */
-  volatile u32 **ppPage    /* Write the page pointer here */
-){
+static int walIndexPage(Wal *pWal, int iPage, volatile u32 **ppPage){
   int rc = SQLITE_OK;
 
   /* Enlarge the pWal->apWiData[] array if required */
@@ -57330,20 +56174,21 @@
   }
 
   /* Request a pointer to the required page from the VFS */
-  assert( pWal->apWiData[iPage]==0 );
-  if( pWal->exclusiveMode==WAL_HEAPMEMORY_MODE ){
-    pWal->apWiData[iPage] = (u32 volatile *)sqlite3MallocZero(WALINDEX_PGSZ);
-    if( !pWal->apWiData[iPage] ) rc = SQLITE_NOMEM_BKPT;
-  }else{
-    rc = sqlite3OsShmMap(pWal->pDbFd, iPage, WALINDEX_PGSZ, 
-        pWal->writeLock, (void volatile **)&pWal->apWiData[iPage]
-    );
-    assert( pWal->apWiData[iPage]!=0 || rc!=SQLITE_OK || pWal->writeLock==0 );
-    testcase( pWal->apWiData[iPage]==0 && rc==SQLITE_OK );
-    if( (rc&0xff)==SQLITE_READONLY ){
-      pWal->readOnly |= WAL_SHM_RDONLY;
-      if( rc==SQLITE_READONLY ){
-        rc = SQLITE_OK;
+  if( pWal->apWiData[iPage]==0 ){
+    if( pWal->exclusiveMode==WAL_HEAPMEMORY_MODE ){
+      pWal->apWiData[iPage] = (u32 volatile *)sqlite3MallocZero(WALINDEX_PGSZ);
+      if( !pWal->apWiData[iPage] ) rc = SQLITE_NOMEM_BKPT;
+    }else{
+      rc = sqlite3OsShmMap(pWal->pDbFd, iPage, WALINDEX_PGSZ, 
+          pWal->writeLock, (void volatile **)&pWal->apWiData[iPage]
+      );
+      assert( pWal->apWiData[iPage]!=0 || rc!=SQLITE_OK || pWal->writeLock==0 );
+      testcase( pWal->apWiData[iPage]==0 && rc==SQLITE_OK );
+      if( (rc&0xff)==SQLITE_READONLY ){
+        pWal->readOnly |= WAL_SHM_RDONLY;
+        if( rc==SQLITE_READONLY ){
+          rc = SQLITE_OK;
+        }
       }
     }
   }
@@ -57352,16 +56197,6 @@
   assert( iPage==0 || *ppPage || rc!=SQLITE_OK );
   return rc;
 }
-static int walIndexPage(
-  Wal *pWal,               /* The WAL context */
-  int iPage,               /* The page we seek */
-  volatile u32 **ppPage    /* Write the page pointer here */
-){
-  if( pWal->nWiData<=iPage || (*ppPage = pWal->apWiData[iPage])==0 ){
-    return walIndexPageRealloc(pWal, iPage, ppPage);
-  }
-  return SQLITE_OK;
-}
 
 /*
 ** Return a pointer to the WalCkptInfo structure in the wal-index.
@@ -58338,9 +57173,8 @@
 
 /*
 ** Construct a WalInterator object that can be used to loop over all 
-** pages in the WAL following frame nBackfill in ascending order. Frames
-** nBackfill or earlier may be included - excluding them is an optimization
-** only. The caller must hold the checkpoint lock.
+** pages in the WAL in ascending order. The caller must hold the checkpoint
+** lock.
 **
 ** On success, make *pp point to the newly allocated WalInterator object
 ** return SQLITE_OK. Otherwise, return an error code. If this routine
@@ -58349,7 +57183,7 @@
 ** The calling routine should invoke walIteratorFree() to destroy the
 ** WalIterator object when it has finished with it.
 */
-static int walIteratorInit(Wal *pWal, u32 nBackfill, WalIterator **pp){
+static int walIteratorInit(Wal *pWal, WalIterator **pp){
   WalIterator *p;                 /* Return value */
   int nSegment;                   /* Number of segments to merge */
   u32 iLast;                      /* Last frame in log */
@@ -58386,7 +57220,7 @@
     rc = SQLITE_NOMEM_BKPT;
   }
 
-  for(i=walFramePage(nBackfill+1); rc==SQLITE_OK && i<nSegment; i++){
+  for(i=0; rc==SQLITE_OK && i<nSegment; i++){
     volatile ht_slot *aHash;
     u32 iZero;
     volatile u32 *aPgno;
@@ -58420,7 +57254,6 @@
 
   if( rc!=SQLITE_OK ){
     walIteratorFree(p);
-    p = 0;
   }
   *pp = p;
   return rc;
@@ -58543,6 +57376,13 @@
   pInfo = walCkptInfo(pWal);
   if( pInfo->nBackfill<pWal->hdr.mxFrame ){
 
+    /* Allocate the iterator */
+    rc = walIteratorInit(pWal, &pIter);
+    if( rc!=SQLITE_OK ){
+      return rc;
+    }
+    assert( pIter );
+
     /* EVIDENCE-OF: R-62920-47450 The busy-handler callback is never invoked
     ** in the SQLITE_CHECKPOINT_PASSIVE mode. */
     assert( eMode!=SQLITE_CHECKPOINT_PASSIVE || xBusy==0 );
@@ -58579,13 +57419,7 @@
       }
     }
 
-    /* Allocate the iterator */
-    if( pInfo->nBackfill<mxSafeFrame ){
-      rc = walIteratorInit(pWal, pInfo->nBackfill, &pIter);
-      assert( rc==SQLITE_OK || pIter==0 );
-    }
-
-    if( pIter
+    if( pInfo->nBackfill<mxSafeFrame
      && (rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(0),1))==SQLITE_OK
     ){
       i64 nSize;                    /* Current size of database file */
@@ -59635,7 +58469,7 @@
   **     table after the current read-transaction had started.
   */
   iMinHash = walFramePage(pWal->minFrame);
-  for(iHash=walFramePage(iLast); iHash>=iMinHash; iHash--){
+  for(iHash=walFramePage(iLast); iHash>=iMinHash && iRead==0; iHash--){
     volatile ht_slot *aHash;      /* Pointer to hash table */
     volatile u32 *aPgno;          /* Pointer to array of page numbers */
     u32 iZero;                    /* Frame number corresponding to aPgno[0] */
@@ -59658,7 +58492,6 @@
         return SQLITE_CORRUPT_BKPT;
       }
     }
-    if( iRead ) break;
   }
 
 #ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT
@@ -61073,20 +59906,20 @@
   u8 curFlags;              /* zero or more BTCF_* flags defined below */
   u8 curPagerFlags;         /* Flags to send to sqlite3PagerGet() */
   u8 hints;                 /* As configured by CursorSetHints() */
-  int skipNext;    /* Prev() is noop if negative. Next() is noop if positive.
-                   ** Error code if eState==CURSOR_FAULT */
+  int nOvflAlloc;           /* Allocated size of aOverflow[] array */
   Btree *pBtree;            /* The Btree to which this cursor belongs */
-  Pgno *aOverflow;          /* Cache of overflow page locations */
-  void *pKey;               /* Saved key that was cursor last known position */
-  /* All fields above are zeroed when the cursor is allocated.  See
-  ** sqlite3BtreeCursorZero().  Fields that follow must be manually
-  ** initialized. */
-#define BTCURSOR_FIRST_UNINIT pBt   /* Name of first uninitialized field */
   BtShared *pBt;            /* The BtShared this cursor points to */
   BtCursor *pNext;          /* Forms a linked list of all cursors */
+  Pgno *aOverflow;          /* Cache of overflow page locations */
   CellInfo info;            /* A parse of the cell we are pointing at */
   i64 nKey;                 /* Size of pKey, or last integer key */
+  void *pKey;               /* Saved key that was cursor last known position */
   Pgno pgnoRoot;            /* The root page of this tree */
+  int skipNext;    /* Prev() is noop if negative. Next() is noop if positive.
+                   ** Error code if eState==CURSOR_FAULT */
+  /* All fields above are zeroed when the cursor is allocated.  See
+  ** sqlite3BtreeCursorZero().  Fields that follow must be manually
+  ** initialized. */
   i8 iPage;                 /* Index of current page in apPage */
   u8 curIntKey;             /* Value of apPage[0]->intKey */
   u16 ix;                   /* Current index for apPage[iPage] */
@@ -61136,8 +59969,8 @@
 **   Do nothing else with this cursor.  Any attempt to use the cursor
 **   should return the error code stored in BtCursor.skipNext
 */
-#define CURSOR_VALID             0
-#define CURSOR_INVALID           1
+#define CURSOR_INVALID           0
+#define CURSOR_VALID             1
 #define CURSOR_SKIPNEXT          2
 #define CURSOR_REQUIRESEEK       3
 #define CURSOR_FAULT             4
@@ -63801,8 +62634,7 @@
   BtShared *pBt = (BtShared*)pArg;
   assert( pBt->db );
   assert( sqlite3_mutex_held(pBt->db->mutex) );
-  return sqlite3InvokeBusyHandler(&pBt->db->busyHandler,
-                                  sqlite3PagerFile(pBt->pPager));
+  return sqlite3InvokeBusyHandler(&pBt->db->busyHandler);
 }
 
 /*
@@ -63980,7 +62812,7 @@
     }
     pBt->openFlags = (u8)flags;
     pBt->db = db;
-    sqlite3PagerSetBusyHandler(pBt->pPager, btreeInvokeBusyHandler, pBt);
+    sqlite3PagerSetBusyhandler(pBt->pPager, btreeInvokeBusyHandler, pBt);
     p->pBt = pBt;
   
     pBt->pCursor = 0;
@@ -64943,7 +63775,6 @@
     }
   }while( (rc&0xFF)==SQLITE_BUSY && pBt->inTransaction==TRANS_NONE &&
           btreeInvokeBusyHandler(pBt) );
-  sqlite3PagerResetLockTimeout(pBt->pPager);
 
   if( rc==SQLITE_OK ){
     if( p->inTrans==TRANS_NONE ){
@@ -65917,7 +64748,7 @@
 ** of run-time by skipping the initialization of those elements.
 */
 SQLITE_PRIVATE void sqlite3BtreeCursorZero(BtCursor *p){
-  memset(p, 0, offsetof(BtCursor, BTCURSOR_FIRST_UNINIT));
+  memset(p, 0, offsetof(BtCursor, iPage));
 }
 
 /*
@@ -65960,19 +64791,11 @@
 ** Using this cache reduces the number of calls to btreeParseCell().
 */
 #ifndef NDEBUG
-  static int cellInfoEqual(CellInfo *a, CellInfo *b){
-    if( a->nKey!=b->nKey ) return 0;
-    if( a->pPayload!=b->pPayload ) return 0;
-    if( a->nPayload!=b->nPayload ) return 0;
-    if( a->nLocal!=b->nLocal ) return 0;
-    if( a->nSize!=b->nSize ) return 0;
-    return 1;
-  }
   static void assertCellInfo(BtCursor *pCur){
     CellInfo info;
     memset(&info, 0, sizeof(info));
     btreeParseCell(pCur->pPage, pCur->ix, &info);
-    assert( CORRUPT_DB || cellInfoEqual(&info, &pCur->info) );
+    assert( CORRUPT_DB || memcmp(&info, &pCur->info, sizeof(info))==0 );
   }
 #else
   #define assertCellInfo(x)
@@ -66248,15 +65071,14 @@
     */
     if( (pCur->curFlags & BTCF_ValidOvfl)==0 ){
       int nOvfl = (pCur->info.nPayload-pCur->info.nLocal+ovflSize-1)/ovflSize;
-      if( pCur->aOverflow==0
-       || nOvfl*(int)sizeof(Pgno) > sqlite3MallocSize(pCur->aOverflow)
-      ){
+      if( nOvfl>pCur->nOvflAlloc ){
         Pgno *aNew = (Pgno*)sqlite3Realloc(
             pCur->aOverflow, nOvfl*2*sizeof(Pgno)
         );
         if( aNew==0 ){
           return SQLITE_NOMEM_BKPT;
         }else{
+          pCur->nOvflAlloc = nOvfl*2;
           pCur->aOverflow = aNew;
         }
       }
@@ -67770,8 +66592,9 @@
 }
 
 /*
-** Free any overflow pages associated with the given Cell.  Store
-** size information about the cell in pInfo.
+** Free any overflow pages associated with the given Cell.  Write the
+** local Cell size (the number of bytes on the original page, omitting
+** overflow) into *pnSize.
 */
 static int clearCell(
   MemPage *pPage,          /* The page that contains the Cell */
@@ -68975,7 +67798,7 @@
     }
 
     /* Load b.apCell[] with pointers to all cells in pOld.  If pOld
-    ** contains overflow cells, include them in the b.apCell[] array
+    ** constains overflow cells, include them in the b.apCell[] array
     ** in the correct spot.
     **
     ** Note that when there are multiple overflow cells, it is always the
@@ -72460,51 +71283,6 @@
 }
 #endif
 
-#ifdef SQLITE_DEBUG
-/*
-** Check that string value of pMem agrees with its integer or real value.
-**
-** A single int or real value always converts to the same strings.  But
-** many different strings can be converted into the same int or real.
-** If a table contains a numeric value and an index is based on the
-** corresponding string value, then it is important that the string be
-** derived from the numeric value, not the other way around, to ensure
-** that the index and table are consistent.  See ticket
-** https://www.sqlite.org/src/info/343634942dd54ab (2018-01-31) for
-** an example.
-**
-** This routine looks at pMem to verify that if it has both a numeric
-** representation and a string representation then the string rep has
-** been derived from the numeric and not the other way around.  It returns
-** true if everything is ok and false if there is a problem.
-**
-** This routine is for use inside of assert() statements only.
-*/
-SQLITE_PRIVATE int sqlite3VdbeMemConsistentDualRep(Mem *p){
-  char zBuf[100];
-  char *z;
-  int i, j, incr;
-  if( (p->flags & MEM_Str)==0 ) return 1;
-  if( (p->flags & (MEM_Int|MEM_Real))==0 ) return 1;
-  if( p->flags & MEM_Int ){
-    sqlite3_snprintf(sizeof(zBuf),zBuf,"%lld",p->u.i);
-  }else{
-    sqlite3_snprintf(sizeof(zBuf),zBuf,"%!.15g",p->u.r);
-  }
-  z = p->z;
-  i = j = 0;
-  incr = 1;
-  if( p->enc!=SQLITE_UTF8 ){
-    incr = 2;
-    if( p->enc==SQLITE_UTF16BE ) z++;
-  }
-  while( zBuf[j] ){
-    if( zBuf[j++]!=z[i] ) return 0;
-    i += incr;
-  }
-  return 1;
-}
-#endif /* SQLITE_DEBUG */
 
 /*
 ** If pMem is an object with a valid string representation, this routine
@@ -72940,16 +71718,6 @@
 }
 
 /*
-** Return 1 if pMem represents true, and return 0 if pMem represents false.
-** Return the value ifNull if pMem is NULL.  
-*/
-SQLITE_PRIVATE int sqlite3VdbeBooleanValue(Mem *pMem, int ifNull){
-  if( pMem->flags & MEM_Int ) return pMem->u.i!=0;
-  if( pMem->flags & MEM_Null ) return ifNull;
-  return sqlite3VdbeRealValue(pMem)!=0.0;
-}
-
-/*
 ** The MEM structure is already a MEM_Real.  Try to also make it a
 ** MEM_Int if we can.
 */
@@ -73004,18 +71772,6 @@
   return SQLITE_OK;
 }
 
-/* Compare a floating point value to an integer.  Return true if the two
-** values are the same within the precision of the floating point value.
-**
-** For some versions of GCC on 32-bit machines, if you do the more obvious
-** comparison of "r1==(double)i" you sometimes get an answer of false even
-** though the r1 and (double)i values are bit-for-bit the same.
-*/
-static int sqlite3RealSameAsInt(double r1, sqlite3_int64 i){
-  double r2 = (double)i;
-  return memcmp(&r1, &r2, sizeof(r1))==0;
-}
-
 /*
 ** Convert pMem so that it has types MEM_Real or MEM_Int or both.
 ** Invalidate any prior representations.
@@ -73035,7 +71791,7 @@
     }else{
       i64 i = pMem->u.i;
       sqlite3AtoF(pMem->z, &pMem->u.r, pMem->n, pMem->enc);
-      if( rc==1 && sqlite3RealSameAsInt(pMem->u.r, i) ){
+      if( rc==1 && pMem->u.r==(double)i ){
         pMem->u.i = i;
         MemSetTypeFlag(pMem, MEM_Int);
       }else{
@@ -73518,7 +72274,6 @@
   assert(pVal->enc==(enc & ~SQLITE_UTF16_ALIGNED) || pVal->db==0
               || pVal->db->mallocFailed );
   if( pVal->enc==(enc & ~SQLITE_UTF16_ALIGNED) ){
-    assert( sqlite3VdbeMemConsistentDualRep(pVal) );
     return pVal->z;
   }else{
     return 0;
@@ -73541,7 +72296,6 @@
   assert( (enc&3)==(enc&~SQLITE_UTF16_ALIGNED) );
   assert( (pVal->flags & MEM_RowSet)==0 );
   if( (pVal->flags&(MEM_Str|MEM_Term))==(MEM_Str|MEM_Term) && pVal->enc==enc ){
-    assert( sqlite3VdbeMemConsistentDualRep(pVal) );
     return pVal->z;
   }
   if( pVal->flags&MEM_Null ){
@@ -79323,12 +78077,14 @@
 SQLITE_API void sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n){
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   pCtx->isError = SQLITE_ERROR;
+  pCtx->fErrorOrAux = 1;
   sqlite3VdbeMemSetStr(pCtx->pOut, z, n, SQLITE_UTF8, SQLITE_TRANSIENT);
 }
 #ifndef SQLITE_OMIT_UTF16
 SQLITE_API void sqlite3_result_error16(sqlite3_context *pCtx, const void *z, int n){
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   pCtx->isError = SQLITE_ERROR;
+  pCtx->fErrorOrAux = 1;
   sqlite3VdbeMemSetStr(pCtx->pOut, z, n, SQLITE_UTF16NATIVE, SQLITE_TRANSIENT);
 }
 #endif
@@ -79434,7 +78190,8 @@
   return SQLITE_OK;
 }
 SQLITE_API void sqlite3_result_error_code(sqlite3_context *pCtx, int errCode){
-  pCtx->isError = errCode ? errCode : -1;
+  pCtx->isError = errCode;
+  pCtx->fErrorOrAux = 1;
 #ifdef SQLITE_DEBUG
   if( pCtx->pVdbe ) pCtx->pVdbe->rcApp = errCode;
 #endif
@@ -79448,6 +78205,7 @@
 SQLITE_API void sqlite3_result_error_toobig(sqlite3_context *pCtx){
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   pCtx->isError = SQLITE_TOOBIG;
+  pCtx->fErrorOrAux = 1;
   sqlite3VdbeMemSetStr(pCtx->pOut, "string or blob too big", -1, 
                        SQLITE_UTF8, SQLITE_STATIC);
 }
@@ -79457,6 +78215,7 @@
   assert( sqlite3_mutex_held(pCtx->pOut->db->mutex) );
   sqlite3VdbeMemSetNull(pCtx->pOut);
   pCtx->isError = SQLITE_NOMEM_BKPT;
+  pCtx->fErrorOrAux = 1;
   sqlite3OomFault(pCtx->pOut->db);
 }
 
@@ -79863,7 +78622,10 @@
     pAuxData->iAuxArg = iArg;
     pAuxData->pNextAux = pVdbe->pAuxData;
     pVdbe->pAuxData = pAuxData;
-    if( pCtx->isError==0 ) pCtx->isError = -1;
+    if( pCtx->fErrorOrAux==0 ){
+      pCtx->isError = 0;
+      pCtx->fErrorOrAux = 1;
+    }
   }else if( pAuxData->xDeleteAux ){
     pAuxData->xDeleteAux(pAuxData->pAux);
   }
@@ -80619,9 +79381,7 @@
   Vdbe *pVdbe = (Vdbe*)pStmt;
   u32 v;
 #ifdef SQLITE_ENABLE_API_ARMOR
-  if( !pStmt 
-   || (op!=SQLITE_STMTSTATUS_MEMUSED && (op<0||op>=ArraySize(pVdbe->aCounter)))
-  ){
+  if( !pStmt ){
     (void)SQLITE_MISUSE_BKPT;
     return 0;
   }
@@ -81395,11 +80155,6 @@
     pRec->flags |= MEM_Real;
     if( bTryForInt ) sqlite3VdbeIntegerAffinity(pRec);
   }
-  /* TEXT->NUMERIC is many->one.  Hence, it is important to invalidate the
-  ** string representation after computing a numeric equivalent, because the
-  ** string representation might not be the canonical representation for the
-  ** numeric value.  Ticket [343634942dd54ab57b7024] 2018-01-31. */
-  pRec->flags &= ~MEM_Str;
 }
 
 /*
@@ -81868,7 +80623,7 @@
 
     assert( pOp>=aOp && pOp<&aOp[p->nOp]);
 #ifdef VDBE_PROFILE
-    start = sqlite3NProfileCnt ? sqlite3NProfileCnt : sqlite3Hwtime();
+    start = sqlite3Hwtime();
 #endif
     nVmStep++;
 #ifdef SQLITE_ENABLE_STMT_SCANSTATUS
@@ -83392,8 +82147,18 @@
   int v1;    /* Left operand:  0==FALSE, 1==TRUE, 2==UNKNOWN or NULL */
   int v2;    /* Right operand: 0==FALSE, 1==TRUE, 2==UNKNOWN or NULL */
 
-  v1 = sqlite3VdbeBooleanValue(&aMem[pOp->p1], 2);
-  v2 = sqlite3VdbeBooleanValue(&aMem[pOp->p2], 2);
+  pIn1 = &aMem[pOp->p1];
+  if( pIn1->flags & MEM_Null ){
+    v1 = 2;
+  }else{
+    v1 = sqlite3VdbeIntValue(pIn1)!=0;
+  }
+  pIn2 = &aMem[pOp->p2];
+  if( pIn2->flags & MEM_Null ){
+    v2 = 2;
+  }else{
+    v2 = sqlite3VdbeIntValue(pIn2)!=0;
+  }
   if( pOp->opcode==OP_And ){
     static const unsigned char and_logic[] = { 0, 0, 0, 0, 1, 2, 0, 2, 2 };
     v1 = and_logic[v1*3+v2];
@@ -83411,35 +82176,6 @@
   break;
 }
 
-/* Opcode: IsTrue P1 P2 P3 P4 *
-** Synopsis: r[P2] = coalesce(r[P1]==TRUE,P3) ^ P4
-**
-** This opcode implements the IS TRUE, IS FALSE, IS NOT TRUE, and
-** IS NOT FALSE operators.
-**
-** Interpret the value in register P1 as a boolean value.  Store that
-** boolean (a 0 or 1) in register P2.  Or if the value in register P1 is 
-** NULL, then the P3 is stored in register P2.  Invert the answer if P4
-** is 1.
-**
-** The logic is summarized like this:
-**
-** <ul> 
-** <li> If P3==0 and P4==0  then  r[P2] := r[P1] IS TRUE
-** <li> If P3==1 and P4==1  then  r[P2] := r[P1] IS FALSE
-** <li> If P3==0 and P4==1  then  r[P2] := r[P1] IS NOT TRUE
-** <li> If P3==1 and P4==0  then  r[P2] := r[P1] IS NOT FALSE
-** </ul>
-*/
-case OP_IsTrue: {               /* in1, out2 */
-  assert( pOp->p4type==P4_INT32 );
-  assert( pOp->p4.i==0 || pOp->p4.i==1 );
-  assert( pOp->p3==0 || pOp->p3==1 );
-  sqlite3VdbeMemSetInt64(&aMem[pOp->p2],
-      sqlite3VdbeBooleanValue(&aMem[pOp->p1], pOp->p3) ^ pOp->p4.i);
-  break;
-}
-
 /* Opcode: Not P1 P2 * * *
 ** Synopsis: r[P2]= !r[P1]
 **
@@ -83450,10 +82186,10 @@
 case OP_Not: {                /* same as TK_NOT, in1, out2 */
   pIn1 = &aMem[pOp->p1];
   pOut = &aMem[pOp->p2];
+  sqlite3VdbeMemSetNull(pOut);
   if( (pIn1->flags & MEM_Null)==0 ){
-    sqlite3VdbeMemSetInt64(pOut, !sqlite3VdbeBooleanValue(pIn1,0));
-  }else{
-    sqlite3VdbeMemSetNull(pOut);
+    pOut->flags = MEM_Int;
+    pOut->u.i = !sqlite3VdbeIntValue(pIn1);
   }
   break;
 }
@@ -83520,25 +82256,30 @@
 ** is considered true if it is numeric and non-zero.  If the value
 ** in P1 is NULL then take the jump if and only if P3 is non-zero.
 */
-case OP_If:  {               /* jump, in1 */
-  int c;
-  c = sqlite3VdbeBooleanValue(&aMem[pOp->p1], pOp->p3);
-  VdbeBranchTaken(c!=0, 2);
-  if( c ) goto jump_to_p2;
-  break;
-}
-
 /* Opcode: IfNot P1 P2 P3 * *
 **
 ** Jump to P2 if the value in register P1 is False.  The value
 ** is considered false if it has a numeric value of zero.  If the value
 ** in P1 is NULL then take the jump if and only if P3 is non-zero.
 */
+case OP_If:                 /* jump, in1 */
 case OP_IfNot: {            /* jump, in1 */
   int c;
-  c = !sqlite3VdbeBooleanValue(&aMem[pOp->p1], !pOp->p3);
+  pIn1 = &aMem[pOp->p1];
+  if( pIn1->flags & MEM_Null ){
+    c = pOp->p3;
+  }else{
+#ifdef SQLITE_OMIT_FLOATING_POINT
+    c = sqlite3VdbeIntValue(pIn1)!=0;
+#else
+    c = sqlite3VdbeRealValue(pIn1)!=0.0;
+#endif
+    if( pOp->opcode==OP_IfNot ) c = !c;
+  }
   VdbeBranchTaken(c!=0, 2);
-  if( c ) goto jump_to_p2;
+  if( c ){
+    goto jump_to_p2;
+  }
   break;
 }
 
@@ -83599,7 +82340,7 @@
 ** P2 is the column number for the argument to the sqlite_offset() function.
 ** This opcode does not use P2 itself, but the P2 value is used by the
 ** code generator.  The P1, P2, and P3 operands to this opcode are the
-** same as for OP_Column.
+** as as for OP_Column.
 **
 ** This opcode is only available if SQLite is compiled with the
 ** -DSQLITE_ENABLE_OFFSET_SQL_FUNC option.
@@ -85507,10 +84248,6 @@
   pOut = out2Prerelease(p, pOp);
   assert( pOp->p1>=0 && pOp->p1<p->nCursor );
   pC = p->apCsr[pOp->p1];
-  if( !pC->isTable ){
-    rc = SQLITE_CORRUPT_BKPT;
-    goto abort_due_to_error;
-  }
   assert( pC!=0 );
   assert( pC->eCurType==CURTYPE_BTREE );
   assert( pC->uc.pCursor!=0 );
@@ -87447,17 +86184,12 @@
   assert( pOp->p3>0 && pOp->p3<=(p->nMem+1 - p->nCursor) );
   assert( n==0 || (pOp->p2>0 && pOp->p2+n<=(p->nMem+1 - p->nCursor)+1) );
   assert( pOp->p3<pOp->p2 || pOp->p3>=pOp->p2+n );
-  pCtx = sqlite3DbMallocRawNN(db, n*sizeof(sqlite3_value*) +
-               (sizeof(pCtx[0]) + sizeof(Mem) - sizeof(sqlite3_value*)));
+  pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*));
   if( pCtx==0 ) goto no_mem;
   pCtx->pMem = 0;
-  pCtx->pOut = (Mem*)&(pCtx->argv[n]);
-  sqlite3VdbeMemInit(pCtx->pOut, db, MEM_Null);
   pCtx->pFunc = pOp->p4.pFunc;
   pCtx->iOp = (int)(pOp - aOp);
   pCtx->pVdbe = p;
-  pCtx->skipFlag = 0;
-  pCtx->isError = 0;
   pCtx->argc = n;
   pOp->p4type = P4_FUNCCTX;
   pOp->p4.pCtx = pCtx;
@@ -87468,6 +86200,7 @@
   int i;
   sqlite3_context *pCtx;
   Mem *pMem;
+  Mem t;
 
   assert( pOp->p4type==P4_FUNCCTX );
   pCtx = pOp->p4.pCtx;
@@ -87490,28 +86223,26 @@
 #endif
 
   pMem->n++;
-  assert( pCtx->pOut->flags==MEM_Null );
-  assert( pCtx->isError==0 );
-  assert( pCtx->skipFlag==0 );
+  sqlite3VdbeMemInit(&t, db, MEM_Null);
+  pCtx->pOut = &t;
+  pCtx->fErrorOrAux = 0;
+  pCtx->skipFlag = 0;
   (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv); /* IMP: R-24505-23230 */
-  if( pCtx->isError ){
-    if( pCtx->isError>0 ){
-      sqlite3VdbeError(p, "%s", sqlite3_value_text(pCtx->pOut));
+  if( pCtx->fErrorOrAux ){
+    if( pCtx->isError ){
+      sqlite3VdbeError(p, "%s", sqlite3_value_text(&t));
       rc = pCtx->isError;
     }
-    if( pCtx->skipFlag ){
-      assert( pOp[-1].opcode==OP_CollSeq );
-      i = pOp[-1].p1;
-      if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1);
-      pCtx->skipFlag = 0;
-    }
-    sqlite3VdbeMemRelease(pCtx->pOut);
-    pCtx->pOut->flags = MEM_Null;
-    pCtx->isError = 0;
+    sqlite3VdbeMemRelease(&t);
     if( rc ) goto abort_due_to_error;
+  }else{
+    assert( t.flags==MEM_Null );
+  }
+  if( pCtx->skipFlag ){
+    assert( pOp[-1].opcode==OP_CollSeq );
+    i = pOp[-1].p1;
+    if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1);
   }
-  assert( pCtx->pOut->flags==MEM_Null );
-  assert( pCtx->skipFlag==0 );
   break;
 }
 
@@ -87998,8 +86729,7 @@
   }
   rc = pModule->xColumn(pCur->uc.pVCur, &sContext, pOp->p2);
   sqlite3VtabImportErrmsg(p, pVtab);
-  if( sContext.isError>0 ){
-    sqlite3VdbeError(p, "%s", sqlite3_value_text(pDest));
+  if( sContext.isError ){
     rc = sContext.isError;
   }
   sqlite3VdbeChangeEncoding(pDest, encoding);
@@ -88264,7 +86994,6 @@
   pCtx->pFunc = pOp->p4.pFunc;
   pCtx->iOp = (int)(pOp - aOp);
   pCtx->pVdbe = p;
-  pCtx->isError = 0;
   pCtx->argc = n;
   pOp->p4type = P4_FUNCCTX;
   pOp->p4.pCtx = pCtx;
@@ -88299,17 +87028,16 @@
   }
 #endif
   MemSetTypeFlag(pOut, MEM_Null);
-  assert( pCtx->isError==0 );
+  pCtx->fErrorOrAux = 0;
   (*pCtx->pFunc->xSFunc)(pCtx, pCtx->argc, pCtx->argv);/* IMP: R-24505-23230 */
 
   /* If the function returned an error, throw an exception */
-  if( pCtx->isError ){
-    if( pCtx->isError>0 ){
+  if( pCtx->fErrorOrAux ){
+    if( pCtx->isError ){
       sqlite3VdbeError(p, "%s", sqlite3_value_text(pOut));
       rc = pCtx->isError;
     }
     sqlite3VdbeDeleteAuxData(db, &p->pAuxData, pCtx->iOp, pOp->p1);
-    pCtx->isError = 0;
     if( rc ) goto abort_due_to_error;
   }
 
@@ -88351,10 +87079,8 @@
 */
 case OP_Trace:
 case OP_Init: {          /* jump */
-  int i;
-#ifndef SQLITE_OMIT_TRACE
   char *zTrace;
-#endif
+  int i;
 
   /* If the P4 argument is not NULL, then it must be an SQL comment string.
   ** The "--" string is broken up to prevent false-positives with srcck1.c.
@@ -88471,7 +87197,7 @@
 
 #ifdef VDBE_PROFILE
     {
-      u64 endTime = sqlite3NProfileCnt ? sqlite3NProfileCnt : sqlite3Hwtime();
+      u64 endTime = sqlite3Hwtime();
       if( endTime>start ) pOrigOp->cycles += endTime - start;
       pOrigOp->cnt++;
     }
@@ -92858,16 +91584,10 @@
   ** Because no reference was made to outer contexts, the pNC->nRef
   ** fields are not changed in any context.
   */
-  if( cnt==0 && zTab==0 ){
-    assert( pExpr->op==TK_ID );
-    if( ExprHasProperty(pExpr,EP_DblQuoted) ){
-      pExpr->op = TK_STRING;
-      pExpr->pTab = 0;
-      return WRC_Prune;
-    }
-    if( sqlite3ExprIdToTrueFalse(pExpr) ){
-      return WRC_Prune;
-    }
+  if( cnt==0 && zTab==0 && ExprHasProperty(pExpr,EP_DblQuoted) ){
+    pExpr->op = TK_STRING;
+    pExpr->pTab = 0;
+    return WRC_Prune;
   }
 
   /*
@@ -93216,30 +91936,15 @@
       notValid(pParse, pNC, "parameters", NC_IsCheck|NC_PartIdx|NC_IdxExpr);
       break;
     }
-    case TK_IS:
-    case TK_ISNOT: {
-      Expr *pRight;
-      assert( !ExprHasProperty(pExpr, EP_Reduced) );
-      /* Handle special cases of "x IS TRUE", "x IS FALSE", "x IS NOT TRUE",
-      ** and "x IS NOT FALSE". */
-      if( (pRight = pExpr->pRight)->op==TK_ID ){
-        int rc = resolveExprStep(pWalker, pRight);
-        if( rc==WRC_Abort ) return WRC_Abort;
-        if( pRight->op==TK_TRUEFALSE ){
-          pExpr->op2 = pExpr->op;
-          pExpr->op = TK_TRUTH;
-          return WRC_Continue;
-        }
-      }
-      /* Fall thru */
-    }
     case TK_BETWEEN:
     case TK_EQ:
     case TK_NE:
     case TK_LT:
     case TK_LE:
     case TK_GT:
-    case TK_GE: {
+    case TK_GE:
+    case TK_IS:
+    case TK_ISNOT: {
       int nLeft, nRight;
       if( pParse->db->mallocFailed ) break;
       assert( pExpr->pLeft!=0 );
@@ -95715,34 +94420,6 @@
 }
 
 /*
-** If the input expression is an ID with the name "true" or "false"
-** then convert it into an TK_TRUEFALSE term.  Return non-zero if
-** the conversion happened, and zero if the expression is unaltered.
-*/
-SQLITE_PRIVATE int sqlite3ExprIdToTrueFalse(Expr *pExpr){
-  assert( pExpr->op==TK_ID || pExpr->op==TK_STRING );
-  if( sqlite3StrICmp(pExpr->u.zToken, "true")==0
-   || sqlite3StrICmp(pExpr->u.zToken, "false")==0
-  ){
-    pExpr->op = TK_TRUEFALSE;
-    return 1;
-  }
-  return 0;
-}
-
-/*
-** The argument must be a TK_TRUEFALSE Expr node.  Return 1 if it is TRUE
-** and 0 if it is FALSE.
-*/
-SQLITE_PRIVATE int sqlite3ExprTruthValue(const Expr *pExpr){
-  assert( pExpr->op==TK_TRUEFALSE );
-  assert( sqlite3StrICmp(pExpr->u.zToken,"true")==0
-       || sqlite3StrICmp(pExpr->u.zToken,"false")==0 );
-  return pExpr->u.zToken[4]==0;
-}
-
-
-/*
 ** These routines are Walker callbacks used to check expressions to
 ** see if they are "constant" for some definition of constant.  The
 ** Walker.eCode value determines the type of "constant" we are looking
@@ -95789,12 +94466,6 @@
         return WRC_Abort;
       }
     case TK_ID:
-      /* Convert "true" or "false" in a DEFAULT clause into the
-      ** appropriate TK_TRUEFALSE operator */
-      if( sqlite3ExprIdToTrueFalse(pExpr) ){
-        return WRC_Prune;
-      }
-      /* Fall thru */
     case TK_COLUMN:
     case TK_AGG_FUNCTION:
     case TK_AGG_COLUMN:
@@ -97559,10 +96230,6 @@
       codeInteger(pParse, pExpr, 0, target);
       return target;
     }
-    case TK_TRUEFALSE: {
-      sqlite3VdbeAddOp2(v, OP_Integer, sqlite3ExprTruthValue(pExpr), target);
-      return target;
-    }
 #ifndef SQLITE_OMIT_FLOATING_POINT
     case TK_FLOAT: {
       assert( !ExprHasProperty(pExpr, EP_IntValue) );
@@ -97718,18 +96385,6 @@
       sqlite3VdbeAddOp2(v, op, r1, inReg);
       break;
     }
-    case TK_TRUTH: {
-      int isTrue;    /* IS TRUE or IS NOT TRUE */
-      int bNormal;   /* IS TRUE or IS FALSE */
-      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
-      testcase( regFree1==0 );
-      isTrue = sqlite3ExprTruthValue(pExpr->pRight);
-      bNormal = pExpr->op2==TK_IS;
-      testcase( isTrue && bNormal);
-      testcase( !isTrue && bNormal);
-      sqlite3VdbeAddOp4Int(v, OP_IsTrue, r1, inReg, !isTrue, isTrue ^ bNormal);
-      break;
-    }
     case TK_ISNULL:
     case TK_NOTNULL: {
       int addr;
@@ -98505,23 +97160,6 @@
       sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);
       break;
     }
-    case TK_TRUTH: {
-      int isNot;      /* IS NOT TRUE or IS NOT FALSE */
-      int isTrue;     /* IS TRUE or IS NOT TRUE */
-      testcase( jumpIfNull==0 );
-      isNot = pExpr->op2==TK_ISNOT;
-      isTrue = sqlite3ExprTruthValue(pExpr->pRight);
-      testcase( isTrue && isNot );
-      testcase( !isTrue && isNot );
-      if( isTrue ^ isNot ){
-        sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest,
-                          isNot ? SQLITE_JUMPIFNULL : 0);
-      }else{
-        sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest,
-                           isNot ? SQLITE_JUMPIFNULL : 0);
-      }
-      break;
-    }
     case TK_IS:
     case TK_ISNOT:
       testcase( op==TK_IS );
@@ -98676,26 +97314,6 @@
       sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);
       break;
     }
-    case TK_TRUTH: {
-      int isNot;   /* IS NOT TRUE or IS NOT FALSE */
-      int isTrue;  /* IS TRUE or IS NOT TRUE */
-      testcase( jumpIfNull==0 );
-      isNot = pExpr->op2==TK_ISNOT;
-      isTrue = sqlite3ExprTruthValue(pExpr->pRight);
-      testcase( isTrue && isNot );
-      testcase( !isTrue && isNot );
-      if( isTrue ^ isNot ){
-        /* IS TRUE and IS NOT FALSE */
-        sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest,
-                           isNot ? 0 : SQLITE_JUMPIFNULL);
-
-      }else{
-        /* IS FALSE and IS NOT TRUE */
-        sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest,
-                          isNot ? 0 : SQLITE_JUMPIFNULL);
-      }
-      break;
-    }
     case TK_IS:
     case TK_ISNOT:
       testcase( pExpr->op==TK_IS );
@@ -98984,80 +97602,6 @@
 }
 
 /*
-** This is the Expr node callback for sqlite3ExprImpliesNotNullRow().
-** If the expression node requires that the table at pWalker->iCur
-** have a non-NULL column, then set pWalker->eCode to 1 and abort.
-*/
-static int impliesNotNullRow(Walker *pWalker, Expr *pExpr){
-  /* This routine is only called for WHERE clause expressions and so it
-  ** cannot have any TK_AGG_COLUMN entries because those are only found
-  ** in HAVING clauses.  We can get a TK_AGG_FUNCTION in a WHERE clause,
-  ** but that is an illegal construct and the query will be rejected at
-  ** a later stage of processing, so the TK_AGG_FUNCTION case does not
-  ** need to be considered here. */
-  assert( pExpr->op!=TK_AGG_COLUMN );
-  testcase( pExpr->op==TK_AGG_FUNCTION );
-
-  if( ExprHasProperty(pExpr, EP_FromJoin) ) return WRC_Prune;
-  switch( pExpr->op ){
-    case TK_ISNULL:
-    case TK_IS:
-    case TK_OR:
-    case TK_CASE:
-    case TK_IN:
-    case TK_FUNCTION:
-      testcase( pExpr->op==TK_ISNULL );
-      testcase( pExpr->op==TK_IS );
-      testcase( pExpr->op==TK_OR );
-      testcase( pExpr->op==TK_CASE );
-      testcase( pExpr->op==TK_IN );
-      testcase( pExpr->op==TK_FUNCTION );
-      return WRC_Prune;
-    case TK_COLUMN:
-      if( pWalker->u.iCur==pExpr->iTable ){
-        pWalker->eCode = 1;
-        return WRC_Abort;
-      }
-      return WRC_Prune;
-    default:
-      return WRC_Continue;
-  }
-}
-
-/*
-** Return true (non-zero) if expression p can only be true if at least
-** one column of table iTab is non-null.  In other words, return true
-** if expression p will always be NULL or false if every column of iTab
-** is NULL.
-**
-** False negatives are acceptable.  In other words, it is ok to return
-** zero even if expression p will never be true of every column of iTab
-** is NULL.  A false negative is merely a missed optimization opportunity.
-**
-** False positives are not allowed, however.  A false positive may result
-** in an incorrect answer.
-**
-** Terms of p that are marked with EP_FromJoin (and hence that come from
-** the ON or USING clauses of LEFT JOINS) are excluded from the analysis.
-**
-** This routine is used to check if a LEFT JOIN can be converted into
-** an ordinary JOIN.  The p argument is the WHERE clause.  If the WHERE
-** clause requires that some column of the right table of the LEFT JOIN
-** be non-NULL, then the LEFT JOIN can be safely converted into an
-** ordinary join.
-*/
-SQLITE_PRIVATE int sqlite3ExprImpliesNonNullRow(Expr *p, int iTab){
-  Walker w;
-  w.xExprCallback = impliesNotNullRow;
-  w.xSelectCallback = 0;
-  w.xSelectCallback2 = 0;
-  w.eCode = 0;
-  w.u.iCur = iTab;
-  sqlite3WalkExpr(&w, p);
-  return w.eCode;
-}
-
-/*
 ** An instance of the following structure is used by the tree walker
 ** to determine if an expression can be evaluated by reference to the
 ** index only, without having to do a search for the corresponding
@@ -101301,7 +99845,7 @@
     /* Do not gather statistics on views or virtual tables */
     return;
   }
-  if( sqlite3_strlike("sqlite\\_%", pTab->zName, '\\')==0 ){
+  if( sqlite3_strlike("sqlite_%", pTab->zName, 0)==0 ){
     /* Do not gather statistics on system tables */
     return;
   }
@@ -102280,10 +100824,6 @@
 **
 ** If the optional "KEY z" syntax is omitted, an SQL NULL is passed as the
 ** third argument.
-**
-** If the db->init.reopenMemdb flags is set, then instead of attaching a
-** new database, close the database on db->init.iDb and reopen it as an
-** empty MemDB.
 */
 static void attachFunc(
   sqlite3_context *context,
@@ -102304,85 +100844,65 @@
   sqlite3_vfs *pVfs;
 
   UNUSED_PARAMETER(NotUsed);
+
   zFile = (const char *)sqlite3_value_text(argv[0]);
   zName = (const char *)sqlite3_value_text(argv[1]);
   if( zFile==0 ) zFile = "";
   if( zName==0 ) zName = "";
 
-#ifdef SQLITE_ENABLE_DESERIALIZE
-# define REOPEN_AS_MEMDB(db)  (db->init.reopenMemdb)
-#else
-# define REOPEN_AS_MEMDB(db)  (0)
-#endif
-
-  if( REOPEN_AS_MEMDB(db) ){
-    /* This is not a real ATTACH.  Instead, this routine is being called
-    ** from sqlite3_deserialize() to close database db->init.iDb and
-    ** reopen it as a MemDB */
-    pVfs = sqlite3_vfs_find("memdb");
-    if( pVfs==0 ) return;
-    pNew = &db->aDb[db->init.iDb];
-    if( pNew->pBt ) sqlite3BtreeClose(pNew->pBt);
-    pNew->pBt = 0;
-    pNew->pSchema = 0;
-    rc = sqlite3BtreeOpen(pVfs, "x", db, &pNew->pBt, 0, SQLITE_OPEN_MAIN_DB);
-  }else{
-    /* This is a real ATTACH
-    **
-    ** Check for the following errors:
-    **
-    **     * Too many attached databases,
-    **     * Transaction currently open
-    **     * Specified database name already being used.
-    */
-    if( db->nDb>=db->aLimit[SQLITE_LIMIT_ATTACHED]+2 ){
-      zErrDyn = sqlite3MPrintf(db, "too many attached databases - max %d", 
-        db->aLimit[SQLITE_LIMIT_ATTACHED]
-      );
+  /* Check for the following errors:
+  **
+  **     * Too many attached databases,
+  **     * Transaction currently open
+  **     * Specified database name already being used.
+  */
+  if( db->nDb>=db->aLimit[SQLITE_LIMIT_ATTACHED]+2 ){
+    zErrDyn = sqlite3MPrintf(db, "too many attached databases - max %d", 
+      db->aLimit[SQLITE_LIMIT_ATTACHED]
+    );
+    goto attach_error;
+  }
+  for(i=0; i<db->nDb; i++){
+    char *z = db->aDb[i].zDbSName;
+    assert( z && zName );
+    if( sqlite3StrICmp(z, zName)==0 ){
+      zErrDyn = sqlite3MPrintf(db, "database %s is already in use", zName);
       goto attach_error;
     }
-    for(i=0; i<db->nDb; i++){
-      char *z = db->aDb[i].zDbSName;
-      assert( z && zName );
-      if( sqlite3StrICmp(z, zName)==0 ){
-        zErrDyn = sqlite3MPrintf(db, "database %s is already in use", zName);
-        goto attach_error;
-      }
-    }
-  
-    /* Allocate the new entry in the db->aDb[] array and initialize the schema
-    ** hash tables.
-    */
-    if( db->aDb==db->aDbStatic ){
-      aNew = sqlite3DbMallocRawNN(db, sizeof(db->aDb[0])*3 );
-      if( aNew==0 ) return;
-      memcpy(aNew, db->aDb, sizeof(db->aDb[0])*2);
-    }else{
-      aNew = sqlite3DbRealloc(db, db->aDb, sizeof(db->aDb[0])*(db->nDb+1) );
-      if( aNew==0 ) return;
-    }
-    db->aDb = aNew;
-    pNew = &db->aDb[db->nDb];
-    memset(pNew, 0, sizeof(*pNew));
-  
-    /* Open the database file. If the btree is successfully opened, use
-    ** it to obtain the database schema. At this point the schema may
-    ** or may not be initialized.
-    */
-    flags = db->openFlags;
-    rc = sqlite3ParseUri(db->pVfs->zName, zFile, &flags, &pVfs, &zPath, &zErr);
-    if( rc!=SQLITE_OK ){
-      if( rc==SQLITE_NOMEM ) sqlite3OomFault(db);
-      sqlite3_result_error(context, zErr, -1);
-      sqlite3_free(zErr);
-      return;
-    }
-    assert( pVfs );
-    flags |= SQLITE_OPEN_MAIN_DB;
-    rc = sqlite3BtreeOpen(pVfs, zPath, db, &pNew->pBt, 0, flags);
-    sqlite3_free( zPath );
-    db->nDb++;
   }
+
+  /* Allocate the new entry in the db->aDb[] array and initialize the schema
+  ** hash tables.
+  */
+  if( db->aDb==db->aDbStatic ){
+    aNew = sqlite3DbMallocRawNN(db, sizeof(db->aDb[0])*3 );
+    if( aNew==0 ) return;
+    memcpy(aNew, db->aDb, sizeof(db->aDb[0])*2);
+  }else{
+    aNew = sqlite3DbRealloc(db, db->aDb, sizeof(db->aDb[0])*(db->nDb+1) );
+    if( aNew==0 ) return;
+  }
+  db->aDb = aNew;
+  pNew = &db->aDb[db->nDb];
+  memset(pNew, 0, sizeof(*pNew));
+
+  /* Open the database file. If the btree is successfully opened, use
+  ** it to obtain the database schema. At this point the schema may
+  ** or may not be initialized.
+  */
+  flags = db->openFlags;
+  rc = sqlite3ParseUri(db->pVfs->zName, zFile, &flags, &pVfs, &zPath, &zErr);
+  if( rc!=SQLITE_OK ){
+    if( rc==SQLITE_NOMEM ) sqlite3OomFault(db);
+    sqlite3_result_error(context, zErr, -1);
+    sqlite3_free(zErr);
+    return;
+  }
+  assert( pVfs );
+  flags |= SQLITE_OPEN_MAIN_DB;
+  rc = sqlite3BtreeOpen(pVfs, zPath, db, &pNew->pBt, 0, flags);
+  sqlite3_free( zPath );
+  db->nDb++;
   db->skipBtreeMutex = 0;
   if( rc==SQLITE_CONSTRAINT ){
     rc = SQLITE_ERROR;
@@ -102409,7 +100929,7 @@
     sqlite3BtreeLeave(pNew->pBt);
   }
   pNew->safety_level = SQLITE_DEFAULT_SYNCHRONOUS+1;
-  if( !REOPEN_AS_MEMDB(db) ) pNew->zDbSName = sqlite3DbStrDup(db, zName);
+  pNew->zDbSName = sqlite3DbStrDup(db, zName);
   if( rc==SQLITE_OK && pNew->zDbSName==0 ){
     rc = SQLITE_NOMEM_BKPT;
   }
@@ -102449,15 +100969,13 @@
 
   /* If the file was opened successfully, read the schema for the new database.
   ** If this fails, or if opening the file failed, then close the file and 
-  ** remove the entry from the db->aDb[] array. i.e. put everything back the
-  ** way we found it.
+  ** remove the entry from the db->aDb[] array. i.e. put everything back the way
+  ** we found it.
   */
   if( rc==SQLITE_OK ){
     sqlite3BtreeEnterAll(db);
-    db->init.iDb = 0;
     rc = sqlite3Init(db, &zErrDyn);
     sqlite3BtreeLeaveAll(db);
-    assert( zErrDyn==0 || rc!=SQLITE_OK );
   }
 #ifdef SQLITE_USER_AUTHENTICATION
   if( rc==SQLITE_OK ){
@@ -102469,23 +100987,21 @@
   }
 #endif
   if( rc ){
-    if( !REOPEN_AS_MEMDB(db) ){
-      int iDb = db->nDb - 1;
-      assert( iDb>=2 );
-      if( db->aDb[iDb].pBt ){
-        sqlite3BtreeClose(db->aDb[iDb].pBt);
-        db->aDb[iDb].pBt = 0;
-        db->aDb[iDb].pSchema = 0;
-      }
-      sqlite3ResetAllSchemasOfConnection(db);
-      db->nDb = iDb;
-      if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){
-        sqlite3OomFault(db);
-        sqlite3DbFree(db, zErrDyn);
-        zErrDyn = sqlite3MPrintf(db, "out of memory");
-      }else if( zErrDyn==0 ){
-        zErrDyn = sqlite3MPrintf(db, "unable to open database: %s", zFile);
-      }
+    int iDb = db->nDb - 1;
+    assert( iDb>=2 );
+    if( db->aDb[iDb].pBt ){
+      sqlite3BtreeClose(db->aDb[iDb].pBt);
+      db->aDb[iDb].pBt = 0;
+      db->aDb[iDb].pSchema = 0;
+    }
+    sqlite3ResetAllSchemasOfConnection(db);
+    db->nDb = iDb;
+    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){
+      sqlite3OomFault(db);
+      sqlite3DbFree(db, zErrDyn);
+      zErrDyn = sqlite3MPrintf(db, "out of memory");
+    }else if( zErrDyn==0 ){
+      zErrDyn = sqlite3MPrintf(db, "unable to open database: %s", zFile);
     }
     goto attach_error;
   }
@@ -102757,14 +101273,6 @@
     if( sqlite3FixExpr(pFix, pSelect->pLimit) ){
       return 1;
     }
-    if( pSelect->pWith ){
-      int i;
-      for(i=0; i<pSelect->pWith->nCte; i++){
-        if( sqlite3FixSelect(pFix, pSelect->pWith->a[i].pSelect) ){
-          return 1;
-        }
-      }
-    }
     pSelect = pSelect->pPrior;
   }
   return 0;
@@ -104228,24 +102736,10 @@
 */
 SQLITE_PRIVATE void sqlite3AddNotNull(Parse *pParse, int onError){
   Table *p;
-  Column *pCol;
   p = pParse->pNewTable;
   if( p==0 || NEVER(p->nCol<1) ) return;
-  pCol = &p->aCol[p->nCol-1];
-  pCol->notNull = (u8)onError;
+  p->aCol[p->nCol-1].notNull = (u8)onError;
   p->tabFlags |= TF_HasNotNull;
-
-  /* Set the uniqNotNull flag on any UNIQUE or PK indexes already created
-  ** on this column.  */
-  if( pCol->colFlags & COLFLAG_UNIQUE ){
-    Index *pIdx;
-    for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){
-      assert( pIdx->nKeyCol==1 && pIdx->onError!=OE_None );
-      if( pIdx->aiColumn[0]==p->nCol-1 ){
-        pIdx->uniqNotNull = 1;
-      }
-    }
-  }
 }
 
 /*
@@ -104362,7 +102856,7 @@
           pCol->zName);
     }else{
       /* A copy of pExpr is used instead of the original, as pExpr contains
-      ** tokens that point to volatile memory.
+      ** tokens that point to volatile memory.	
       */
       Expr x;
       sqlite3ExprDelete(db, pCol->pDflt);
@@ -104980,6 +103474,8 @@
   p = pParse->pNewTable;
   if( p==0 ) return;
 
+  assert( !db->init.busy || !pSelect );
+
   /* If the db->init.busy is 1 it means we are reading the SQL off the
   ** "sqlite_master" or "sqlite_temp_master" table on the disk.
   ** So do not write to the disk again.  Extract the root page number
@@ -104990,10 +103486,6 @@
   ** table itself.  So mark it read-only.
   */
   if( db->init.busy ){
-    if( pSelect ){
-      sqlite3ErrorMsg(pParse, "");
-      return;
-    }
     p->tnum = db->init.newTnum;
     if( p->tnum==1 ) p->tabFlags |= TF_Readonly;
   }
@@ -105284,7 +103776,7 @@
   int nErr = 0;     /* Number of errors encountered */
   int n;            /* Temporarily holds the number of cursors assigned */
   sqlite3 *db = pParse->db;  /* Database connection for malloc errors */
-#ifndef SQLITE_OMIT_VIRTUALTABLE
+#ifndef SQLITE_OMIT_VIRTUALTABLE	
   int rc;
 #endif
 #ifndef SQLITE_OMIT_AUTHORIZATION
@@ -106211,9 +104703,7 @@
   */
   if( pList==0 ){
     Token prevCol;
-    Column *pCol = &pTab->aCol[pTab->nCol-1];
-    pCol->colFlags |= COLFLAG_UNIQUE;
-    sqlite3TokenInit(&prevCol, pCol->zName);
+    sqlite3TokenInit(&prevCol, pTab->aCol[pTab->nCol-1].zName);
     pList = sqlite3ExprListAppend(pParse, 0,
               sqlite3ExprAlloc(db, TK_ID, &prevCol, 0));
     if( pList==0 ) goto exit_create_index;
@@ -109058,8 +107548,6 @@
 ** iteration of the aggregate loop.
 */
 static void sqlite3SkipAccumulatorLoad(sqlite3_context *context){
-  assert( context->isError<=0 );
-  context->isError = -1;
   context->skipFlag = 1;
 }
 
@@ -109126,6 +107614,8 @@
   int argc,
   sqlite3_value **argv
 ){
+  int len;
+
   assert( argc==1 );
   UNUSED_PARAMETER(argc);
   switch( sqlite3_value_type(argv[0]) ){
@@ -109137,17 +107627,13 @@
     }
     case SQLITE_TEXT: {
       const unsigned char *z = sqlite3_value_text(argv[0]);
-      const unsigned char *z0;
-      unsigned char c;
       if( z==0 ) return;
-      z0 = z;
-      while( (c = *z)!=0 ){
-        z++;
-        if( c>=0xc0 ){
-          while( (*z & 0xc0)==0x80 ){ z++; z0++; }
-        }
+      len = 0;
+      while( *z ){
+        len++;
+        SQLITE_SKIP_UTF8(z);
       }
-      sqlite3_result_int(context, (int)(z-z0));
+      sqlite3_result_int(context, len);
       break;
     }
     default: {
@@ -110222,8 +108708,6 @@
   i64 nOut;                /* Maximum size of zOut */
   int loopLimit;           /* Last zStr[] that might match zPattern[] */
   int i, j;                /* Loop counters */
-  unsigned cntExpand;      /* Number zOut expansions */
-  sqlite3 *db = sqlite3_context_db_handle(context);
 
   assert( argc==3 );
   UNUSED_PARAMETER(argc);
@@ -110255,40 +108739,33 @@
     return;
   }
   loopLimit = nStr - nPattern;  
-  cntExpand = 0;
   for(i=j=0; i<=loopLimit; i++){
     if( zStr[i]!=zPattern[0] || memcmp(&zStr[i], zPattern, nPattern) ){
       zOut[j++] = zStr[i];
     }else{
-      if( nRep>nPattern ){
-        nOut += nRep - nPattern;
-        testcase( nOut-1==db->aLimit[SQLITE_LIMIT_LENGTH] );
-        testcase( nOut-2==db->aLimit[SQLITE_LIMIT_LENGTH] );
-        if( nOut-1>db->aLimit[SQLITE_LIMIT_LENGTH] ){
-          sqlite3_result_error_toobig(context);
-          sqlite3_free(zOut);
-          return;
-        }
-        cntExpand++;
-        if( (cntExpand&(cntExpand-1))==0 ){
-          /* Grow the size of the output buffer only on substitutions
-          ** whose index is a power of two: 1, 2, 4, 8, 16, 32, ... */
-          u8 *zOld;
-          zOld = zOut;
-          zOut = sqlite3_realloc64(zOut, (int)nOut + (nOut - nStr - 1));
-          if( zOut==0 ){
-            sqlite3_result_error_nomem(context);
-            sqlite3_free(zOld);
-            return;
-          }
-        }
+      u8 *zOld;
+      sqlite3 *db = sqlite3_context_db_handle(context);
+      nOut += nRep - nPattern;
+      testcase( nOut-1==db->aLimit[SQLITE_LIMIT_LENGTH] );
+      testcase( nOut-2==db->aLimit[SQLITE_LIMIT_LENGTH] );
+      if( nOut-1>db->aLimit[SQLITE_LIMIT_LENGTH] ){
+        sqlite3_result_error_toobig(context);
+        sqlite3_free(zOut);
+        return;
+      }
+      zOld = zOut;
+      zOut = sqlite3_realloc64(zOut, (int)nOut);
+      if( zOut==0 ){
+        sqlite3_result_error_nomem(context);
+        sqlite3_free(zOld);
+        return;
       }
       memcpy(&zOut[j], zRep, nRep);
       j += nRep;
       i += nPattern-1;
     }
   }
-  assert( j+nStr-i+1<=nOut );
+  assert( j+nStr-i+1==nOut );
   memcpy(&zOut[j], &zStr[i], nStr-i);
   j += nStr - i;
   assert( j<=nOut );
@@ -112570,12 +111047,11 @@
 ** first use of table pTab.  On 2nd and subsequent uses, the original
 ** AutoincInfo structure is used.
 **
-** Four consecutive registers are allocated:
+** Three memory locations are allocated:
 **
-**   (1)  The name of the pTab table.
-**   (2)  The maximum ROWID of pTab.
-**   (3)  The rowid in sqlite_sequence of pTab
-**   (4)  The original value of the max ROWID in pTab, or NULL if none
+**   (1)  Register to hold the name of the pTab table.
+**   (2)  Register to hold the maximum ROWID of pTab.
+**   (3)  Register to hold the rowid in sqlite_sequence of pTab
 **
 ** The 2nd register is the one that is returned.  That is all the
 ** insert routine needs to know about.
@@ -112603,7 +111079,7 @@
       pInfo->iDb = iDb;
       pToplevel->nMem++;                  /* Register to hold name of table */
       pInfo->regCtr = ++pToplevel->nMem;  /* Max rowid register */
-      pToplevel->nMem +=2;       /* Rowid in sqlite_sequence + orig max val */
+      pToplevel->nMem++;                  /* Rowid in sqlite_sequence */
     }
     memId = pInfo->regCtr;
   }
@@ -112631,17 +111107,15 @@
     static const int iLn = VDBE_OFFSET_LINENO(2);
     static const VdbeOpList autoInc[] = {
       /* 0  */ {OP_Null,    0,  0, 0},
-      /* 1  */ {OP_Rewind,  0, 10, 0},
+      /* 1  */ {OP_Rewind,  0,  9, 0},
       /* 2  */ {OP_Column,  0,  0, 0},
-      /* 3  */ {OP_Ne,      0,  9, 0},
+      /* 3  */ {OP_Ne,      0,  7, 0},
       /* 4  */ {OP_Rowid,   0,  0, 0},
       /* 5  */ {OP_Column,  0,  1, 0},
-      /* 6  */ {OP_AddImm,  0,  0, 0},
-      /* 7  */ {OP_Copy,    0,  0, 0},
-      /* 8  */ {OP_Goto,    0, 11, 0},
-      /* 9  */ {OP_Next,    0,  2, 0},
-      /* 10 */ {OP_Integer, 0,  0, 0},
-      /* 11 */ {OP_Close,   0,  0, 0} 
+      /* 6  */ {OP_Goto,    0,  9, 0},
+      /* 7  */ {OP_Next,    0,  2, 0},
+      /* 8  */ {OP_Integer, 0,  0, 0},
+      /* 9  */ {OP_Close,   0,  0, 0} 
     };
     VdbeOp *aOp;
     pDb = &db->aDb[p->iDb];
@@ -112652,17 +111126,14 @@
     aOp = sqlite3VdbeAddOpList(v, ArraySize(autoInc), autoInc, iLn);
     if( aOp==0 ) break;
     aOp[0].p2 = memId;
-    aOp[0].p3 = memId+2;
+    aOp[0].p3 = memId+1;
     aOp[2].p3 = memId;
     aOp[3].p1 = memId-1;
     aOp[3].p3 = memId;
     aOp[3].p5 = SQLITE_JUMPIFNULL;
     aOp[4].p2 = memId+1;
     aOp[5].p3 = memId;
-    aOp[6].p1 = memId;
-    aOp[7].p2 = memId+2;
-    aOp[7].p1 = memId;
-    aOp[10].p2 = memId;
+    aOp[8].p2 = memId;
   }
 }
 
@@ -112709,8 +111180,6 @@
 
     iRec = sqlite3GetTempReg(pParse);
     assert( sqlite3SchemaMutexHeld(db, 0, pDb->pSchema) );
-    sqlite3VdbeAddOp3(v, OP_Le, memId+2, sqlite3VdbeCurrentAddr(v)+7, memId);
-    VdbeCoverage(v);
     sqlite3OpenTable(pParse, 0, p->iDb, pDb->pSchema->pSeqTab, OP_OpenWrite);
     aOp = sqlite3VdbeAddOpList(v, ArraySize(autoIncEnd), autoIncEnd, iLn);
     if( aOp==0 ) break;
@@ -115359,8 +113828,8 @@
 #define sqlite3_value_pointer          sqlite3_api->value_pointer
 /* Version 3.22.0 and later */
 #define sqlite3_vtab_nochange          sqlite3_api->vtab_nochange
-#define sqlite3_value_nochange         sqlite3_api->value_nochange
-#define sqlite3_vtab_collation         sqlite3_api->vtab_collation
+#define sqlite3_value_nochange         sqltie3_api->value_nochange
+#define sqlite3_vtab_collation         sqltie3_api->vtab_collation
 #endif /* !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION) */
 
 #if !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION)
@@ -119344,7 +117813,7 @@
     char *z;
     if( zObj==0 ) zObj = "?";
     z = sqlite3MPrintf(db, "malformed database schema (%s)", zObj);
-    if( zExtra && zExtra[0] ) z = sqlite3MPrintf(db, "%z - %s", z, zExtra);
+    if( zExtra ) z = sqlite3MPrintf(db, "%z - %s", z, zExtra);
     sqlite3DbFree(db, *pData->pzErrMsg);
     *pData->pzErrMsg = z;
   }
@@ -119585,7 +118054,7 @@
   }
   if( pDb->pSchema->file_format>SQLITE_MAX_FILE_FORMAT ){
     sqlite3SetString(pzErrMsg, db, "unsupported file format");
-    rc = SQLITE_ERROR;
+    rc = SQLITE_CORRUPT_BKPT; // Android Change from "rc = SQLITE_ERROR;";
     goto initone_error_out;
   }
 
@@ -120238,7 +118707,8 @@
 /***/ int sqlite3SelectTrace = 0;
 # define SELECTTRACE(K,P,S,X)  \
   if(sqlite3SelectTrace&(K))   \
-    sqlite3DebugPrintf("%s/%p: ",(S)->zSelName,(S)),\
+    sqlite3DebugPrintf("%*s%s.%p: ",(P)->nSelectIndent*2-2,"",\
+        (S)->zSelName,(S)),\
     sqlite3DebugPrintf X
 #else
 # define SELECTTRACE(K,P,S,X)
@@ -120599,29 +119069,6 @@
   } 
 }
 
-/* Undo the work of setJoinExpr().  In the expression tree p, convert every
-** term that is marked with EP_FromJoin and iRightJoinTable==iTable into
-** an ordinary term that omits the EP_FromJoin mark.
-**
-** This happens when a LEFT JOIN is simplified into an ordinary JOIN.
-*/
-static void unsetJoinExpr(Expr *p, int iTable){
-  while( p ){
-    if( ExprHasProperty(p, EP_FromJoin)
-     && (iTable<0 || p->iRightJoinTable==iTable) ){
-      ExprClearProperty(p, EP_FromJoin);
-    }
-    if( p->op==TK_FUNCTION && p->x.pList ){
-      int i;
-      for(i=0; i<p->x.pList->nExpr; i++){
-        unsetJoinExpr(p->x.pList->a[i].pExpr, iTable);
-      }
-    }
-    unsetJoinExpr(p->pLeft, iTable);
-    p = p->pRight;
-  } 
-}
-
 /*
 ** This routine processes the join information for a SELECT statement.
 ** ON and USING clauses are converted into extra terms of the WHERE clause.
@@ -121505,15 +119952,12 @@
     iSortTab = iTab;
     bSeq = 1;
   }
-  for(i=0, iCol=nKey+bSeq-1; i<nSortData; i++){
-    if( aOutEx[i].u.x.iOrderByCol==0 ) iCol++;
-  }
-  for(i=nSortData-1; i>=0; i--){
+  for(i=0, iCol=nKey+bSeq; i<nSortData; i++){
     int iRead;
     if( aOutEx[i].u.x.iOrderByCol ){
       iRead = aOutEx[i].u.x.iOrderByCol-1;
     }else{
-      iRead = iCol--;
+      iRead = iCol++;
     }
     sqlite3VdbeAddOp3(v, OP_Column, iSortTab, iRead, regRow+i);
     VdbeComment((v, "%s", aOutEx[i].zName ? aOutEx[i].zName : aOutEx[i].zSpan));
@@ -123990,6 +122434,7 @@
         pOrderBy->a[i].u.x.iOrderByCol = 0;
       }
       assert( pParent->pOrderBy==0 );
+      assert( pSub->pPrior==0 );
       pParent->pOrderBy = pOrderBy;
       pSub->pOrderBy = 0;
     }
@@ -124073,22 +122518,12 @@
 **   (3) The inner query has a LIMIT clause (since the changes to the WHERE
 **       close would change the meaning of the LIMIT).
 **
-**   (4) The inner query is the right operand of a LEFT JOIN and the
-**       expression to be pushed down does not come from the ON clause
-**       on that LEFT JOIN.
+**   (4) The inner query is the right operand of a LEFT JOIN.  (The caller
+**       enforces this restriction since this routine does not have enough
+**       information to know.)
 **
 **   (5) The WHERE clause expression originates in the ON or USING clause
-**       of a LEFT JOIN where iCursor is not the right-hand table of that
-**       left join.  An example:
-**
-**           SELECT *
-**           FROM (SELECT 1 AS a1 UNION ALL SELECT 2) AS aa
-**           JOIN (SELECT 1 AS b2 UNION ALL SELECT 2) AS bb ON (a1=b2)
-**           LEFT JOIN (SELECT 8 AS c3 UNION ALL SELECT 9) AS cc ON (b2=2);
-**
-**       The correct answer is three rows:  (1,1,NULL),(2,2,8),(2,2,9).
-**       But if the (b2=2) term were to be pushed down into the bb subquery,
-**       then the (1,1,NULL) row would be suppressed.
+**       of a LEFT JOIN.
 **
 ** Return 0 if no changes are made and non-zero if one or more WHERE clause
 ** terms are duplicated into the subquery.
@@ -124097,8 +122532,7 @@
   Parse *pParse,        /* Parse context (for malloc() and error reporting) */
   Select *pSubq,        /* The subquery whose WHERE clause is to be augmented */
   Expr *pWhere,         /* The WHERE clause of the outer query */
-  int iCursor,          /* Cursor number of the subquery */
-  int isLeftJoin        /* True if pSubq is the right term of a LEFT JOIN */
+  int iCursor           /* Cursor number of the subquery */
 ){
   Expr *pNew;
   int nChng = 0;
@@ -124122,25 +122556,15 @@
     return 0; /* restriction (3) */
   }
   while( pWhere->op==TK_AND ){
-    nChng += pushDownWhereTerms(pParse, pSubq, pWhere->pRight,
-                                iCursor, isLeftJoin);
+    nChng += pushDownWhereTerms(pParse, pSubq, pWhere->pRight, iCursor);
     pWhere = pWhere->pLeft;
   }
-  if( isLeftJoin
-   && (ExprHasProperty(pWhere,EP_FromJoin)==0
-         || pWhere->iRightJoinTable!=iCursor)
-  ){
-    return 0; /* restriction (4) */
-  }
-  if( ExprHasProperty(pWhere,EP_FromJoin) && pWhere->iRightJoinTable!=iCursor ){
-    return 0; /* restriction (5) */
-  }
+  if( ExprHasProperty(pWhere,EP_FromJoin) ) return 0; /* restriction (5) */
   if( sqlite3ExprIsTableConstant(pWhere, iCursor) ){
     nChng++;
     while( pSubq ){
       SubstContext x;
       pNew = sqlite3ExprDup(pParse->db, pWhere, 0);
-      unsetJoinExpr(pNew, -1);
       x.pParse = pParse;
       x.iTable = iCursor;
       x.iNewTable = iCursor;
@@ -125173,6 +123597,14 @@
 #endif
 
 /*
+** Context object for havingToWhereExprCb().
+*/
+struct HavingToWhereCtx {
+  Expr **ppWhere;
+  ExprList *pGroupBy;
+};
+
+/*
 ** sqlite3WalkExpr() callback used by havingToWhere().
 **
 ** If the node passed to the callback is a TK_AND node, return 
@@ -125185,16 +123617,15 @@
 */
 static int havingToWhereExprCb(Walker *pWalker, Expr *pExpr){
   if( pExpr->op!=TK_AND ){
-    Select *pS = pWalker->u.pSelect;
-    if( sqlite3ExprIsConstantOrGroupBy(pWalker->pParse, pExpr, pS->pGroupBy) ){
+    struct HavingToWhereCtx *p = pWalker->u.pHavingCtx;
+    if( sqlite3ExprIsConstantOrGroupBy(pWalker->pParse, pExpr, p->pGroupBy) ){
       sqlite3 *db = pWalker->pParse->db;
       Expr *pNew = sqlite3ExprAlloc(db, TK_INTEGER, &sqlite3IntTokens[1], 0);
       if( pNew ){
-        Expr *pWhere = pS->pWhere;
+        Expr *pWhere = *(p->ppWhere);
         SWAP(Expr, *pNew, *pExpr);
         pNew = sqlite3ExprAnd(db, pWhere, pNew);
-        pS->pWhere = pNew;
-        pWalker->eCode = 1;
+        *(p->ppWhere) = pNew;
       }
     }
     return WRC_Prune;
@@ -125217,19 +123648,23 @@
 ** entirely of constants and expressions that are also GROUP BY terms that
 ** use the "BINARY" collation sequence.
 */
-static void havingToWhere(Parse *pParse, Select *p){
+static void havingToWhere(
+  Parse *pParse,
+  ExprList *pGroupBy,
+  Expr *pHaving, 
+  Expr **ppWhere
+){
+  struct HavingToWhereCtx sCtx;
   Walker sWalker;
+
+  sCtx.ppWhere = ppWhere;
+  sCtx.pGroupBy = pGroupBy;
+
   memset(&sWalker, 0, sizeof(sWalker));
   sWalker.pParse = pParse;
   sWalker.xExprCallback = havingToWhereExprCb;
-  sWalker.u.pSelect = p;
-  sqlite3WalkExpr(&sWalker, p->pHaving);
-#if SELECTTRACE_ENABLED
-  if( sWalker.eCode && (sqlite3SelectTrace & 0x100)!=0 ){
-    SELECTTRACE(0x100,pParse,p,("Move HAVING terms into WHERE:\n"));
-    sqlite3TreeViewSelect(0, p, 0);
-  }
-#endif
+  sWalker.u.pHavingCtx = &sCtx;
+  sqlite3WalkExpr(&sWalker, pHaving);
 }
 
 /*
@@ -125390,6 +123825,7 @@
   if( sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0) ) return 1;
   memset(&sAggInfo, 0, sizeof(sAggInfo));
 #if SELECTTRACE_ENABLED
+  pParse->nSelectIndent++;
   SELECTTRACE(1,pParse,p, ("begin processing:\n"));
   if( sqlite3SelectTrace & 0x100 ){
     sqlite3TreeViewSelect(0, p, 0);
@@ -125435,29 +123871,13 @@
     generateColumnNames(pParse, p);
   }
 
-  /* Try to various optimizations (flattening subqueries, and strength
-  ** reduction of join operators) in the FROM clause up into the main query
+  /* Try to flatten subqueries in the FROM clause up into the main query
   */
 #if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)
   for(i=0; !p->pPrior && i<pTabList->nSrc; i++){
     struct SrcList_item *pItem = &pTabList->a[i];
     Select *pSub = pItem->pSelect;
     Table *pTab = pItem->pTab;
-
-    /* Convert LEFT JOIN into JOIN if there are terms of the right table
-    ** of the LEFT JOIN used in the WHERE clause.
-    */
-    if( (pItem->fg.jointype & JT_LEFT)!=0
-     && sqlite3ExprImpliesNonNullRow(p->pWhere, pItem->iCursor)
-     && OptimizationEnabled(db, SQLITE_SimplifyJoin)
-    ){
-      SELECTTRACE(0x100,pParse,p,
-                ("LEFT-JOIN simplifies to JOIN on term %d\n",i));
-      pItem->fg.jointype &= ~(JT_LEFT|JT_OUTER);
-      unsetJoinExpr(p->pWhere, pItem->iCursor);
-    }
-
-    /* No futher action if this term of the FROM clause is no a subquery */
     if( pSub==0 ) continue;
 
     /* Catch mismatch in the declared columns of a view and the number of
@@ -125526,6 +123946,7 @@
     explainSetInteger(pParse->iSelectId, iRestoreSelectId);
 #if SELECTTRACE_ENABLED
     SELECTTRACE(1,pParse,p,("end compound-select processing\n"));
+    pParse->nSelectIndent--;
 #endif
     return rc;
   }
@@ -125598,9 +124019,8 @@
     /* Make copies of constant WHERE-clause terms in the outer query down
     ** inside the subquery.  This can help the subquery to run more efficiently.
     */
-    if( OptimizationEnabled(db, SQLITE_PushDown)
-     && pushDownWhereTerms(pParse, pSub, p->pWhere, pItem->iCursor,
-                           (pItem->fg.jointype & JT_OUTER)!=0)
+    if( (pItem->fg.jointype & JT_OUTER)==0
+     && pushDownWhereTerms(pParse, pSub, p->pWhere, pItem->iCursor)
     ){
 #if SELECTTRACE_ENABLED
       if( sqlite3SelectTrace & 0x100 ){
@@ -125608,8 +124028,6 @@
         sqlite3TreeViewSelect(0, p, 0);
       }
 #endif
-    }else{
-      SELECTTRACE(0x100,pParse,p,("Push-down not possible\n"));
     }
 
     zSavedAuthContext = pParse->zAuthContext;
@@ -125812,7 +124230,6 @@
     wctrlFlags |= p->selFlags & SF_FixedLimit;
 
     /* Begin the database scan. */
-    SELECTTRACE(1,pParse,p,("WhereBegin\n"));
     pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy,
                                p->pEList, wctrlFlags, p->nSelectRow);
     if( pWInfo==0 ) goto select_end;
@@ -125914,9 +124331,7 @@
     if( pHaving ){
       if( pGroupBy ){
         assert( pWhere==p->pWhere );
-        assert( pHaving==p->pHaving );
-        assert( pGroupBy==p->pGroupBy );
-        havingToWhere(pParse, p);
+        havingToWhere(pParse, pGroupBy, pHaving, &p->pWhere);
         pWhere = p->pWhere;
       }
       sqlite3ExprAnalyzeAggregates(&sNC, pHaving);
@@ -126003,7 +124418,6 @@
       ** in the right order to begin with.
       */
       sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);
-      SELECTTRACE(1,pParse,p,("WhereBegin\n"));
       pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, 0,
           WHERE_GROUPBY | (orderByGrp ? WHERE_SORTBYGROUP : 0), 0
       );
@@ -126259,7 +124673,6 @@
         assert( minMaxFlag==WHERE_ORDERBY_NORMAL || pMinMaxOrderBy!=0 );
         assert( pMinMaxOrderBy==0 || pMinMaxOrderBy->nExpr==1 );
 
-        SELECTTRACE(1,pParse,p,("WhereBegin\n"));
         pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy,
                                    0, minMaxFlag, 0);
         if( pWInfo==0 ){
@@ -126315,6 +124728,7 @@
   sqlite3DbFree(db, sAggInfo.aFunc);
 #if SELECTTRACE_ENABLED
   SELECTTRACE(1,pParse,p,("end processing\n"));
+  pParse->nSelectIndent--;
 #endif
   return rc;
 }
@@ -128610,8 +127024,8 @@
   while( SQLITE_ROW==(rc = sqlite3_step(pStmt)) ){
     const char *zSubSql = (const char*)sqlite3_column_text(pStmt,0);
     assert( sqlite3_strnicmp(zSql,"SELECT",6)==0 );
-    assert( sqlite3_strnicmp(zSubSql,"SELECT",6)!=0 || CORRUPT_DB );
-    if( zSubSql && zSubSql[0]!='S' ){
+    if( zSubSql ){
+      assert( zSubSql[0]!='S' );
       rc = execSql(db, pzErrMsg, zSubSql);
       if( rc!=SQLITE_OK ) break;
     }
@@ -132149,15 +130563,7 @@
       if( sqlite3ExprIsVector(pX->pRight) ){
         r1 = rTemp = sqlite3GetTempReg(pParse);
         codeExprOrVector(pParse, pX->pRight, r1, 1);
-        testcase( pX->op==TK_GT );
-        testcase( pX->op==TK_GE );
-        testcase( pX->op==TK_LT );
-        testcase( pX->op==TK_LE );
-        op = aMoveOp[((pX->op - TK_GT - 1) & 0x3) | 0x1];
-        assert( pX->op!=TK_GT || op==OP_SeekGE );
-        assert( pX->op!=TK_GE || op==OP_SeekGE );
-        assert( pX->op!=TK_LT || op==OP_SeekLE );
-        assert( pX->op!=TK_LE || op==OP_SeekLE );
+        op = aMoveOp[(pX->op - TK_GT) | 0x0001];
       }else{
         r1 = sqlite3ExprCodeTemp(pParse, pX->pRight, &rTemp);
         disableTerm(pLevel, pStart);
@@ -132881,7 +131287,7 @@
         continue;
       }
 
-      if( (pTerm->wtFlags & TERM_LIKECOND)!=0 ){
+      if( pTerm->wtFlags & TERM_LIKECOND ){
         /* If the TERM_LIKECOND flag is set, that means that the range search
         ** is sufficient to guarantee that the LIKE operator is true, so we
         ** can skip the call to the like(A,B) function.  But this only works
@@ -132891,9 +131297,8 @@
         continue;
 #else
         u32 x = pLevel->iLikeRepCntr;
-        if( x>0 ){
-          skipLikeAddr = sqlite3VdbeAddOp1(v, (x&1)?OP_IfNot:OP_If,(int)(x>>1));
-        }
+        assert( x>0 );
+        skipLikeAddr = sqlite3VdbeAddOp1(v, (x&1)?OP_IfNot:OP_If, (int)(x>>1));
         VdbeCoverage(v);
 #endif
       }
@@ -132933,12 +131338,6 @@
                     WO_EQ|WO_IN|WO_IS, 0);
     if( pAlt==0 ) continue;
     if( pAlt->wtFlags & (TERM_CODED) ) continue;
-    if( (pAlt->eOperator & WO_IN) 
-     && (pAlt->pExpr->flags & EP_xIsSelect)
-     && (pAlt->pExpr->x.pSelect->pEList->nExpr>1)
-    ){
-      continue;
-    }
     testcase( pAlt->eOperator & WO_EQ );
     testcase( pAlt->eOperator & WO_IS );
     testcase( pAlt->eOperator & WO_IN );
@@ -133853,9 +132252,6 @@
       for(i=0; i<pSrc->nSrc; i++){
         mask |= exprSelectUsage(pMaskSet, pSrc->a[i].pSelect);
         mask |= sqlite3WhereExprUsage(pMaskSet, pSrc->a[i].pOn);
-        if( pSrc->a[i].fg.isTabFunc ){
-          mask |= sqlite3WhereExprListUsage(pMaskSet, pSrc->a[i].u1.pFuncArg);
-        }
       }
     }
     pS = pS->pPrior;
@@ -134268,7 +132664,7 @@
       exprAnalyze(pSrc, pWC, idxNew);
     }
     pTerm = &pWC->a[idxTerm];
-    pTerm->wtFlags |= TERM_CODED|TERM_VIRTUAL;  /* Disable the original */
+    pTerm->wtFlags = TERM_CODED|TERM_VIRTUAL;  /* Disable the original */
     pTerm->eOperator = 0;
   }
 
@@ -136993,12 +135389,10 @@
       if( iCol==XN_ROWID 
        || (iCol>=0 && nInMul==0 && saved_nEq==pProbe->nKeyCol-1)
       ){
-        if( iCol==XN_ROWID || pProbe->uniqNotNull 
-         || (pProbe->nKeyCol==1 && pProbe->onError && eOp==WO_EQ) 
-        ){
-          pNew->wsFlags |= WHERE_ONEROW;
-        }else{
+        if( iCol>=0 && pProbe->uniqNotNull==0 ){
           pNew->wsFlags |= WHERE_UNQ_WANTED;
+        }else{
+          pNew->wsFlags |= WHERE_ONEROW;
         }
       }
     }else if( eOp & WO_ISNULL ){
@@ -139145,7 +137539,6 @@
   */
   for(ii=0; ii<sWLB.pWC->nTerm; ii++){
     WhereTerm *pT = &sWLB.pWC->a[ii];
-    if( pT->wtFlags & TERM_VIRTUAL ) continue;
     if( pT->prereqAll==0 && (nTabList==0 || exprIsDeterministic(pT->pExpr)) ){
       sqlite3ExprIfFalse(pParse, pT->pExpr, pWInfo->iBreak, SQLITE_JUMPIFNULL);
       pT->wtFlags |= TERM_CODED;
@@ -141604,8 +139997,7 @@
 #endif
   do{
     i = yy_shift_ofst[stateno];
-    assert( i>=0 );
-    assert( i+YYNTOKEN<=(int)sizeof(yy_lookahead)/sizeof(yy_lookahead[0]) );
+    assert( i>=0 && i+YYNTOKEN<=sizeof(yy_lookahead)/sizeof(yy_lookahead[0]) );
     assert( iLookAhead!=YYNOCODE );
     assert( iLookAhead < YYNTOKEN );
     i += iLookAhead;
@@ -142319,10 +140711,6 @@
       case 34: /* ccons ::= DEFAULT scanpt ID|INDEXED */
 {
   Expr *p = tokenExpr(pParse, TK_STRING, yymsp[0].minor.yy0);
-  if( p ){
-    sqlite3ExprIdToTrueFalse(p);
-    testcase( p->op==TK_TRUEFALSE && sqlite3ExprTruthValue(p) );
-  }
   sqlite3AddDefaultValue(pParse,p,yymsp[0].minor.yy0.z,yymsp[0].minor.yy0.z+yymsp[0].minor.yy0.n);
 }
         break;
@@ -142516,7 +140904,8 @@
   if( yymsp[-8].minor.yy387!=0 ){
     const char *z = s.z+6;
     int i;
-    sqlite3_snprintf(sizeof(yymsp[-8].minor.yy387->zSelName), yymsp[-8].minor.yy387->zSelName,"#%d",++pParse->nSelect);
+    sqlite3_snprintf(sizeof(yymsp[-8].minor.yy387->zSelName), yymsp[-8].minor.yy387->zSelName, "#%d",
+                     ++pParse->nSelect);
     while( z[0]==' ' ) z++;
     if( z[0]=='/' && z[1]=='*' ){
       z += 2;
@@ -145215,11 +143604,6 @@
       sqlite3GlobalConfig.isPCacheInit = 1;
       rc = sqlite3OsInit();
     }
-#ifdef SQLITE_ENABLE_DESERIALIZE
-    if( rc==SQLITE_OK ){
-      rc = sqlite3MemdbInit();
-    }
-#endif
     if( rc==SQLITE_OK ){
       sqlite3PCacheBufferSetup( sqlite3GlobalConfig.pPage, 
           sqlite3GlobalConfig.szPage, sqlite3GlobalConfig.nPage);
@@ -145252,7 +143636,7 @@
 #ifndef NDEBUG
 #ifndef SQLITE_OMIT_FLOATING_POINT
   /* This section of code's only "output" is via assert() statements. */
-  if( rc==SQLITE_OK ){
+  if ( rc==SQLITE_OK ){
     u64 x = (((u64)1)<<63)-1;
     double y;
     assert(sizeof(x)==8);
@@ -146419,8 +144803,6 @@
     /* SQLITE_FORMAT      */ 0,
     /* SQLITE_RANGE       */ "column index out of range",
     /* SQLITE_NOTADB      */ "file is not a database",
-    /* SQLITE_NOTICE      */ "notification message",
-    /* SQLITE_WARNING     */ "warning message",
   };
   const char *zErr = "unknown error";
   switch( rc ){
@@ -146428,14 +144810,6 @@
       zErr = "abort due to ROLLBACK";
       break;
     }
-    case SQLITE_ROW: {
-      zErr = "another row available";
-      break;
-    }
-    case SQLITE_DONE: {
-      zErr = "no more rows available";
-      break;
-    }
     default: {
       rc &= 0xff;
       if( ALWAYS(rc>=0) && rc<ArraySize(aMsg) && aMsg[rc]!=0 ){
@@ -146452,40 +144826,21 @@
 ** again until a timeout value is reached.  The timeout value is
 ** an integer number of milliseconds passed in as the first
 ** argument.
-**
-** Return non-zero to retry the lock.  Return zero to stop trying
-** and cause SQLite to return SQLITE_BUSY.
 */
 static int sqliteDefaultBusyCallback(
-  void *ptr,               /* Database connection */
-  int count,               /* Number of times table has been busy */
-  sqlite3_file *pFile      /* The file on which the lock occurred */
+ void *ptr,               /* Database connection */
+ int count                /* Number of times table has been busy */
 ){
 #if SQLITE_OS_WIN || HAVE_USLEEP
-  /* This case is for systems that have support for sleeping for fractions of
-  ** a second.  Examples:  All windows systems, unix systems with usleep() */
   static const u8 delays[] =
      { 1, 2, 5, 10, 15, 20, 25, 25,  25,  50,  50, 100 };
   static const u8 totals[] =
      { 0, 1, 3,  8, 18, 33, 53, 78, 103, 128, 178, 228 };
 # define NDELAY ArraySize(delays)
   sqlite3 *db = (sqlite3 *)ptr;
-  int tmout = db->busyTimeout;
+  int timeout = db->busyTimeout;
   int delay, prior;
 
-#ifdef SQLITE_ENABLE_SETLK_TIMEOUT
-  if( sqlite3OsFileControl(pFile,SQLITE_FCNTL_LOCK_TIMEOUT,&tmout)==SQLITE_OK ){
-    if( count ){
-      tmout = 0;
-      sqlite3OsFileControl(pFile, SQLITE_FCNTL_LOCK_TIMEOUT, &tmout);
-      return 0;
-    }else{
-      return 1;
-    }
-  }
-#else
-  UNUSED_PARAMETER(pFile);
-#endif
   assert( count>=0 );
   if( count < NDELAY ){
     delay = delays[count];
@@ -146494,19 +144849,16 @@
     delay = delays[NDELAY-1];
     prior = totals[NDELAY-1] + delay*(count-(NDELAY-1));
   }
-  if( prior + delay > tmout ){
-    delay = tmout - prior;
+  if( prior + delay > timeout ){
+    delay = timeout - prior;
     if( delay<=0 ) return 0;
   }
   sqlite3OsSleep(db->pVfs, delay*1000);
   return 1;
 #else
-  /* This case for unix systems that lack usleep() support.  Sleeping
-  ** must be done in increments of whole seconds */
   sqlite3 *db = (sqlite3 *)ptr;
-  int tmout = ((sqlite3 *)ptr)->busyTimeout;
-  UNUSED_PARAMETER(pFile);
-  if( (count+1)*1000 > tmout ){
+  int timeout = ((sqlite3 *)ptr)->busyTimeout;
+  if( (count+1)*1000 > timeout ){
     return 0;
   }
   sqlite3OsSleep(db->pVfs, 1000000);
@@ -146517,25 +144869,14 @@
 /*
 ** Invoke the given busy handler.
 **
-** This routine is called when an operation failed to acquire a
-** lock on VFS file pFile.
-**
+** This routine is called when an operation failed with a lock.
 ** If this routine returns non-zero, the lock is retried.  If it
 ** returns 0, the operation aborts with an SQLITE_BUSY error.
 */
-SQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler *p, sqlite3_file *pFile){
+SQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler *p){
   int rc;
-  if( p->xBusyHandler==0 || p->nBusy<0 ) return 0;
-  if( p->bExtraFileArg ){
-    /* Add an extra parameter with the pFile pointer to the end of the
-    ** callback argument list */
-    int (*xTra)(void*,int,sqlite3_file*);
-    xTra = (int(*)(void*,int,sqlite3_file*))p->xBusyHandler;
-    rc = xTra(p->pBusyArg, p->nBusy, pFile);
-  }else{
-    /* Legacy style busy handler callback */
-    rc = p->xBusyHandler(p->pBusyArg, p->nBusy);
-  }
+  if( NEVER(p==0) || p->xFunc==0 || p->nBusy<0 ) return 0;
+  rc = p->xFunc(p->pArg, p->nBusy);
   if( rc==0 ){
     p->nBusy = -1;
   }else{
@@ -146557,10 +144898,9 @@
   if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
 #endif
   sqlite3_mutex_enter(db->mutex);
-  db->busyHandler.xBusyHandler = xBusy;
-  db->busyHandler.pBusyArg = pArg;
+  db->busyHandler.xFunc = xBusy;
+  db->busyHandler.pArg = pArg;
   db->busyHandler.nBusy = 0;
-  db->busyHandler.bExtraFileArg = 0;
   db->busyTimeout = 0;
   sqlite3_mutex_leave(db->mutex);
   return SQLITE_OK;
@@ -146608,10 +144948,8 @@
   if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;
 #endif
   if( ms>0 ){
-    sqlite3_busy_handler(db, (int(*)(void*,int))sqliteDefaultBusyCallback,
-                             (void*)db);
+    sqlite3_busy_handler(db, sqliteDefaultBusyCallback, (void*)db);
     db->busyTimeout = ms;
-    db->busyHandler.bExtraFileArg = 1;
   }else{
     sqlite3_busy_handler(db, 0, 0);
   }
@@ -148604,8 +146942,10 @@
     }else if( op==SQLITE_FCNTL_JOURNAL_POINTER ){
       *(sqlite3_file**)pArg = sqlite3PagerJrnlFile(pPager);
       rc = SQLITE_OK;
-    }else{
+    }else if( fd->pMethods ){
       rc = sqlite3OsFileControl(fd, op, pArg);
+    }else{
+      rc = SQLITE_NOTFOUND;
     }
     sqlite3BtreeLeave(pBtree);
   }
@@ -154429,13 +152769,25 @@
   ** module with sqlite.
   */
   if( SQLITE_OK==rc 
+#ifndef ANDROID    /* fts3_tokenizer disabled for security reasons */
    && SQLITE_OK==(rc = sqlite3Fts3InitHashTable(db, pHash, "fts3_tokenizer"))
+#endif
    && SQLITE_OK==(rc = sqlite3_overload_function(db, "snippet", -1))
    && SQLITE_OK==(rc = sqlite3_overload_function(db, "offsets", 1))
    && SQLITE_OK==(rc = sqlite3_overload_function(db, "matchinfo", 1))
    && SQLITE_OK==(rc = sqlite3_overload_function(db, "matchinfo", 2))
    && SQLITE_OK==(rc = sqlite3_overload_function(db, "optimize", 1))
   ){
+#ifdef SQLITE_ENABLE_FTS3_BACKWARDS
+    rc = sqlite3_create_module_v2(
+        db, "fts1", &fts3Module, (void *)pHash, 0
+        );
+    if(rc) return rc;
+    rc = sqlite3_create_module_v2(
+        db, "fts2", &fts3Module, (void *)pHash, 0
+        );
+    if(rc) return rc;
+#endif
     rc = sqlite3_create_module_v2(
         db, "fts3", &fts3Module, (void *)pHash, hashDestroy
     );
@@ -162456,7 +160808,6 @@
     sqlite3_bind_blob(pStmt, 2, z, n, SQLITE_STATIC);
     sqlite3_step(pStmt);
     rc = sqlite3_reset(pStmt);
-    sqlite3_bind_null(pStmt, 2);
   }
   return rc;
 }
@@ -162513,7 +160864,6 @@
     sqlite3_bind_blob(pStmt, 6, zRoot, nRoot, SQLITE_STATIC);
     sqlite3_step(pStmt);
     rc = sqlite3_reset(pStmt);
-    sqlite3_bind_null(pStmt, 6);
   }
   return rc;
 }
@@ -163993,7 +162343,6 @@
   sqlite3_bind_blob(pStmt, 2, pBlob, nBlob, SQLITE_STATIC);
   sqlite3_step(pStmt);
   *pRC = sqlite3_reset(pStmt);
-  sqlite3_bind_null(pStmt, 2);
   sqlite3_free(a);
 }
 
@@ -165182,7 +163531,6 @@
       sqlite3_bind_int(pChomp, 4, iIdx);
       sqlite3_step(pChomp);
       rc = sqlite3_reset(pChomp);
-      sqlite3_bind_null(pChomp, 2);
     }
   }
 
@@ -165262,7 +163610,6 @@
     sqlite3_bind_blob(pReplace, 2, pHint->a, pHint->n, SQLITE_STATIC);
     sqlite3_step(pReplace);
     rc = sqlite3_reset(pReplace);
-    sqlite3_bind_null(pReplace, 2);
   }
 
   return rc;
@@ -166077,6 +164424,7 @@
 ){
   Fts3Table *p = (Fts3Table *)pVtab;
   int rc = SQLITE_OK;             /* Return Code */
+  int isRemove = 0;               /* True for an UPDATE or DELETE */
   u32 *aSzIns = 0;                /* Sizes of inserted documents */
   u32 *aSzDel = 0;                /* Sizes of deleted documents */
   int nChng = 0;                  /* Net change in number of documents */
@@ -166174,6 +164522,7 @@
   if( sqlite3_value_type(apVal[0])!=SQLITE_NULL ){
     assert( sqlite3_value_type(apVal[0])==SQLITE_INTEGER );
     rc = fts3DeleteByRowid(p, apVal[0], &nChng, aSzDel);
+    isRemove = 1;
   }
   
   /* If this is an INSERT or UPDATE operation, insert the new record. */
@@ -166185,7 +164534,7 @@
         rc = FTS_CORRUPT_VTAB;
       }
     }
-    if( rc==SQLITE_OK ){
+    if( rc==SQLITE_OK && (!isRemove || *pRowid!=p->iPrevDocid ) ){
       rc = fts3PendingTermsDocid(p, 0, iLangid, *pRowid);
     }
     if( rc==SQLITE_OK ){
@@ -169493,7 +167842,6 @@
     sqlite3_step(p);
     pNode->isDirty = 0;
     rc = sqlite3_reset(p);
-    sqlite3_bind_null(p, 2);
     if( pNode->iNode==0 && rc==SQLITE_OK ){
       pNode->iNode = sqlite3_last_insert_rowid(pRtree->db);
       nodeHashInsert(pRtree, pNode);
@@ -176181,7 +174529,7 @@
         int iCid = sqlite3_column_int(pXInfo, 1);
         int bDesc = sqlite3_column_int(pXInfo, 3);
         const char *zCollate = (const char*)sqlite3_column_text(pXInfo, 4);
-        zCols = rbuMPrintf(p, "%z%sc%d %s COLLATE %Q", zCols, zComma, 
+        zCols = rbuMPrintf(p, "%z%sc%d %s COLLATE %s", zCols, zComma, 
             iCid, pIter->azTblType[iCid], zCollate
         );
         zPk = rbuMPrintf(p, "%z%sc%d%s", zPk, zComma, iCid, bDesc?" DESC":"");
@@ -176242,7 +174590,7 @@
         ** "PRIMARY KEY" to the imposter table column declaration. */
         zPk = "PRIMARY KEY ";
       }
-      zSql = rbuMPrintf(p, "%z%s\"%w\" %s %sCOLLATE %Q%s", 
+      zSql = rbuMPrintf(p, "%z%s\"%w\" %s %sCOLLATE %s%s", 
           zSql, zComma, zCol, pIter->azTblType[iCol], zPk, zColl,
           (pIter->abNotNull[iCol] ? " NOT NULL" : "")
       );
@@ -179676,7 +178024,7 @@
   */
   fd = sqlite3PagerFile(pPager);
   x[0] = pCsr->iPageno;
-  if( sqlite3OsFileControl(fd, 230440, &x)==SQLITE_OK ){
+  if( fd->pMethods!=0 && sqlite3OsFileControl(fd, 230440, &x)==SQLITE_OK ){
     pCsr->iOffset = x[0];
     pCsr->szPage = (int)x[1];
   }
@@ -180606,8 +178954,8 @@
 ** statement.
 **
 ** For a DELETE change, all fields within the record except those associated
-** with PRIMARY KEY columns are omitted. The PRIMARY KEY fields contain the
-** values identifying the row to delete.
+** with PRIMARY KEY columns are set to "undefined". The PRIMARY KEY fields
+** contain the values identifying the row to delete.
 **
 ** For an UPDATE change, all fields except those associated with PRIMARY KEY
 ** columns and columns that are modified by the UPDATE are set to "undefined".
@@ -180890,7 +179238,7 @@
 static int sessionSerialLen(u8 *a){
   int e = *a;
   int n;
-  if( e==0 || e==0xFF ) return 1;
+  if( e==0 ) return 1;
   if( e==SQLITE_NULL ) return 1;
   if( e==SQLITE_INTEGER || e==SQLITE_FLOAT ) return 9;
   return sessionVarintGet(&a[1], &n) + 1 + n;
@@ -180970,7 +179318,7 @@
       int n1 = sessionSerialLen(a1);
       int n2 = sessionSerialLen(a2);
 
-      if( n1!=n2 || memcmp(a1, a2, n1) ){
+      if( pTab->abPK[iCol] && (n1!=n2 || memcmp(a1, a2, n1)) ){
         return 0;
       }
       a1 += n1;
@@ -181213,7 +179561,7 @@
         }else{
           z = sqlite3_value_blob(pVal);
         }
-        if( n>0 && memcmp(a, z, n) ) return 0;
+        if( memcmp(a, z, n) ) return 0;
         a += n;
       }
     }
@@ -181489,7 +179837,7 @@
   int iHash; 
   int bNull = 0; 
   int rc = SQLITE_OK;
-  SessionStat1Ctx stat1 = {0};
+  SessionStat1Ctx stat1;
 
   if( pSession->rc ) return;
 
@@ -182557,7 +180905,6 @@
         "SELECT tbl, ?2, stat FROM %Q.sqlite_stat1 WHERE tbl IS ?1 AND "
         "idx IS (CASE WHEN ?2=X'' THEN NULL ELSE ?2 END)", zDb
     );
-    if( zSql==0 ) rc = SQLITE_NOMEM;
   }else{
     int i;
     const char *zSep = "";
@@ -183095,16 +181442,13 @@
     if( abPK && abPK[i]==0 ) continue;
     rc = sessionInputBuffer(pIn, 9);
     if( rc==SQLITE_OK ){
-      if( pIn->iNext>=pIn->nData ){
-        rc = SQLITE_CORRUPT_BKPT;
-      }else{
-        eType = pIn->aData[pIn->iNext++];
-        assert( apOut[i]==0 );
-        if( eType ){
-          apOut[i] = sqlite3ValueNew(0);
-          if( !apOut[i] ) rc = SQLITE_NOMEM;
-        }
-      }
+      eType = pIn->aData[pIn->iNext++];
+    }
+
+    assert( apOut[i]==0 );
+    if( eType ){
+      apOut[i] = sqlite3ValueNew(0);
+      if( !apOut[i] ) rc = SQLITE_NOMEM;
     }
 
     if( rc==SQLITE_OK ){
@@ -183114,14 +181458,10 @@
         pIn->iNext += sessionVarintGet(aVal, &nByte);
         rc = sessionInputBuffer(pIn, nByte);
         if( rc==SQLITE_OK ){
-          if( nByte<0 || nByte>pIn->nData-pIn->iNext ){
-            rc = SQLITE_CORRUPT_BKPT;
-          }else{
-            u8 enc = (eType==SQLITE_TEXT ? SQLITE_UTF8 : 0);
-            rc = sessionValueSetStr(apOut[i],&pIn->aData[pIn->iNext],nByte,enc);
-            pIn->iNext += nByte;
-          }
+          u8 enc = (eType==SQLITE_TEXT ? SQLITE_UTF8 : 0);
+          rc = sessionValueSetStr(apOut[i],&pIn->aData[pIn->iNext],nByte,enc);
         }
+        pIn->iNext += nByte;
       }
       if( eType==SQLITE_INTEGER || eType==SQLITE_FLOAT ){
         sqlite3_int64 v = sessionGetI64(aVal);
@@ -183161,19 +181501,8 @@
   rc = sessionInputBuffer(pIn, 9);
   if( rc==SQLITE_OK ){
     nRead += sessionVarintGet(&pIn->aData[pIn->iNext + nRead], &nCol);
-    /* The hard upper limit for the number of columns in an SQLite
-    ** database table is, according to sqliteLimit.h, 32676. So 
-    ** consider any table-header that purports to have more than 65536 
-    ** columns to be corrupt. This is convenient because otherwise, 
-    ** if the (nCol>65536) condition below were omitted, a sufficiently 
-    ** large value for nCol may cause nRead to wrap around and become 
-    ** negative. Leading to a crash. */
-    if( nCol<0 || nCol>65536 ){
-      rc = SQLITE_CORRUPT_BKPT;
-    }else{
-      rc = sessionInputBuffer(pIn, nRead+nCol+100);
-      nRead += nCol;
-    }
+    rc = sessionInputBuffer(pIn, nRead+nCol+100);
+    nRead += nCol;
   }
 
   while( rc==SQLITE_OK ){
@@ -183250,15 +181579,11 @@
     int nByte;
     int nVarint;
     nVarint = sessionVarintGet(&p->in.aData[p->in.iNext], &p->nCol);
-    if( p->nCol>0 ){
-      nCopy -= nVarint;
-      p->in.iNext += nVarint;
-      nByte = p->nCol * sizeof(sqlite3_value*) * 2 + nCopy;
-      p->tblhdr.nBuf = 0;
-      sessionBufferGrow(&p->tblhdr, nByte, &rc);
-    }else{
-      rc = SQLITE_CORRUPT_BKPT;
-    }
+    nCopy -= nVarint;
+    p->in.iNext += nVarint;
+    nByte = p->nCol * sizeof(sqlite3_value*) * 2 + nCopy;
+    p->tblhdr.nBuf = 0;
+    sessionBufferGrow(&p->tblhdr, nByte, &rc);
   }
 
   if( rc==SQLITE_OK ){
@@ -183293,8 +181618,7 @@
 static int sessionChangesetNext(
   sqlite3_changeset_iter *p,      /* Changeset iterator */
   u8 **paRec,                     /* If non-NULL, store record pointer here */
-  int *pnRec,                     /* If non-NULL, store size of record here */
-  int *pbNew                      /* If non-NULL, true if new table */
+  int *pnRec                      /* If non-NULL, store size of record here */
 ){
   int i;
   u8 op;
@@ -183329,7 +181653,6 @@
 
   op = p->in.aData[p->in.iNext++];
   while( op=='T' || op=='P' ){
-    if( pbNew ) *pbNew = 1;
     p->bPatchset = (op=='P');
     if( sessionChangesetReadTblhdr(p) ) return p->rc;
     if( (p->rc = sessionInputBuffer(&p->in, 2)) ) return p->rc;
@@ -183338,13 +181661,6 @@
     op = p->in.aData[p->in.iNext++];
   }
 
-  if( p->zTab==0 ){
-    /* The first record in the changeset is not a table header. Must be a
-    ** corrupt changeset. */
-    assert( p->in.iNext==1 );
-    return (p->rc = SQLITE_CORRUPT_BKPT);
-  }
-
   p->op = op;
   p->bIndirect = p->in.aData[p->in.iNext++];
   if( p->op!=SQLITE_UPDATE && p->op!=SQLITE_DELETE && p->op!=SQLITE_INSERT ){
@@ -183387,9 +181703,9 @@
       ** new.* to old.*, to accommodate the code that reads these arrays.  */
       for(i=0; i<p->nCol; i++){
         assert( p->apValue[i]==0 );
+        assert( p->abPK[i]==0 || p->apValue[i+p->nCol] );
         if( p->abPK[i] ){
           p->apValue[i] = p->apValue[i+p->nCol];
-          if( p->apValue[i]==0 ) return (p->rc = SQLITE_CORRUPT_BKPT);
           p->apValue[i+p->nCol] = 0;
         }
       }
@@ -183408,7 +181724,7 @@
 ** callback by changeset_apply().
 */
 SQLITE_API int sqlite3changeset_next(sqlite3_changeset_iter *p){
-  return sessionChangesetNext(p, 0, 0, 0);
+  return sessionChangesetNext(p, 0, 0);
 }
 
 /*
@@ -183787,8 +182103,6 @@
   int bStat1;                     /* True if table is sqlite_stat1 */
   int bDeferConstraints;          /* True to defer constraints */
   SessionBuffer constraints;      /* Deferred constraints are stored here */
-  SessionBuffer rebase;           /* Rebase information (if any) here */
-  int bRebaseStarted;             /* If table header is already in rebase */
 };
 
 /*
@@ -184055,6 +182369,7 @@
         "AND (?4 OR stat IS ?3)"
     );
   }
+  assert( rc==SQLITE_OK );
   return rc;
 }
 
@@ -184115,13 +182430,7 @@
     if( !abPK || abPK[i] ){
       sqlite3_value *pVal;
       (void)xValue(pIter, i, &pVal);
-      if( pVal==0 ){
-        /* The value in the changeset was "undefined". This indicates a
-        ** corrupt changeset blob.  */
-        rc = SQLITE_CORRUPT_BKPT;
-      }else{
-        rc = sessionBindValue(pStmt, i+1, pVal);
-      }
+      rc = sessionBindValue(pStmt, i+1, pVal);
     }
   }
   return rc;
@@ -184170,54 +182479,6 @@
 }
 
 /*
-** This function is called from within sqlite3changset_apply_v2() when
-** a conflict is encountered and resolved using conflict resolution
-** mode eType (either SQLITE_CHANGESET_OMIT or SQLITE_CHANGESET_REPLACE)..
-** It adds a conflict resolution record to the buffer in 
-** SessionApplyCtx.rebase, which will eventually be returned to the caller
-** of apply_v2() as the "rebase" buffer.
-**
-** Return SQLITE_OK if successful, or an SQLite error code otherwise.
-*/
-static int sessionRebaseAdd(
-  SessionApplyCtx *p,             /* Apply context */
-  int eType,                      /* Conflict resolution (OMIT or REPLACE) */
-  sqlite3_changeset_iter *pIter   /* Iterator pointing at current change */
-){
-  int rc = SQLITE_OK;
-  int i;
-  int eOp = pIter->op;
-  if( p->bRebaseStarted==0 ){
-    /* Append a table-header to the rebase buffer */
-    const char *zTab = pIter->zTab;
-    sessionAppendByte(&p->rebase, 'T', &rc);
-    sessionAppendVarint(&p->rebase, p->nCol, &rc);
-    sessionAppendBlob(&p->rebase, p->abPK, p->nCol, &rc);
-    sessionAppendBlob(&p->rebase, (u8*)zTab, (int)strlen(zTab)+1, &rc);
-    p->bRebaseStarted = 1;
-  }
-
-  assert( eType==SQLITE_CHANGESET_REPLACE||eType==SQLITE_CHANGESET_OMIT );
-  assert( eOp==SQLITE_DELETE || eOp==SQLITE_INSERT || eOp==SQLITE_UPDATE );
-
-  sessionAppendByte(&p->rebase, 
-      (eOp==SQLITE_DELETE ? SQLITE_DELETE : SQLITE_INSERT), &rc
-  );
-  sessionAppendByte(&p->rebase, (eType==SQLITE_CHANGESET_REPLACE), &rc);
-  for(i=0; i<p->nCol; i++){
-    sqlite3_value *pVal = 0;
-    if( eOp==SQLITE_DELETE || (eOp==SQLITE_UPDATE && p->abPK[i]) ){
-      sqlite3changeset_old(pIter, i, &pVal);
-    }else{
-      sqlite3changeset_new(pIter, i, &pVal);
-    }
-    sessionAppendValue(&p->rebase, pVal, &rc);
-  }
-
-  return rc;
-}
-
-/*
 ** Invoke the conflict handler for the change that the changeset iterator
 ** currently points to.
 **
@@ -184292,7 +182553,7 @@
       u8 *aBlob = &pIter->in.aData[pIter->in.iCurrent];
       int nBlob = pIter->in.iNext - pIter->in.iCurrent;
       sessionAppendBlob(&p->constraints, aBlob, nBlob, &rc);
-      return SQLITE_OK;
+      res = SQLITE_CHANGESET_OMIT;
     }else{
       /* No other row with the new.* primary key. */
       res = xConflict(pCtx, eType+1, pIter);
@@ -184318,9 +182579,6 @@
         rc = SQLITE_MISUSE;
         break;
     }
-    if( rc==SQLITE_OK ){
-      rc = sessionRebaseAdd(p, res, pIter);
-    }
   }
 
   return rc;
@@ -184496,42 +182754,42 @@
   int rc;
 
   rc = sessionApplyOneOp(pIter, pApply, xConflict, pCtx, &bReplace, &bRetry);
-  if( rc==SQLITE_OK ){
-    /* If the bRetry flag is set, the change has not been applied due to an
-    ** SQLITE_CHANGESET_DATA problem (i.e. this is an UPDATE or DELETE and
-    ** a row with the correct PK is present in the db, but one or more other
-    ** fields do not contain the expected values) and the conflict handler 
-    ** returned SQLITE_CHANGESET_REPLACE. In this case retry the operation,
-    ** but pass NULL as the final argument so that sessionApplyOneOp() ignores
-    ** the SQLITE_CHANGESET_DATA problem.  */
-    if( bRetry ){
-      assert( pIter->op==SQLITE_UPDATE || pIter->op==SQLITE_DELETE );
+  assert( rc==SQLITE_OK || (bRetry==0 && bReplace==0) );
+
+  /* If the bRetry flag is set, the change has not been applied due to an
+  ** SQLITE_CHANGESET_DATA problem (i.e. this is an UPDATE or DELETE and
+  ** a row with the correct PK is present in the db, but one or more other
+  ** fields do not contain the expected values) and the conflict handler 
+  ** returned SQLITE_CHANGESET_REPLACE. In this case retry the operation,
+  ** but pass NULL as the final argument so that sessionApplyOneOp() ignores
+  ** the SQLITE_CHANGESET_DATA problem.  */
+  if( bRetry ){
+    assert( pIter->op==SQLITE_UPDATE || pIter->op==SQLITE_DELETE );
+    rc = sessionApplyOneOp(pIter, pApply, xConflict, pCtx, 0, 0);
+  }
+
+  /* If the bReplace flag is set, the change is an INSERT that has not
+  ** been performed because the database already contains a row with the
+  ** specified primary key and the conflict handler returned
+  ** SQLITE_CHANGESET_REPLACE. In this case remove the conflicting row
+  ** before reattempting the INSERT.  */
+  else if( bReplace ){
+    assert( pIter->op==SQLITE_INSERT );
+    rc = sqlite3_exec(db, "SAVEPOINT replace_op", 0, 0, 0);
+    if( rc==SQLITE_OK ){
+      rc = sessionBindRow(pIter, 
+          sqlite3changeset_new, pApply->nCol, pApply->abPK, pApply->pDelete);
+      sqlite3_bind_int(pApply->pDelete, pApply->nCol+1, 1);
+    }
+    if( rc==SQLITE_OK ){
+      sqlite3_step(pApply->pDelete);
+      rc = sqlite3_reset(pApply->pDelete);
+    }
+    if( rc==SQLITE_OK ){
       rc = sessionApplyOneOp(pIter, pApply, xConflict, pCtx, 0, 0);
     }
-
-    /* If the bReplace flag is set, the change is an INSERT that has not
-    ** been performed because the database already contains a row with the
-    ** specified primary key and the conflict handler returned
-    ** SQLITE_CHANGESET_REPLACE. In this case remove the conflicting row
-    ** before reattempting the INSERT.  */
-    else if( bReplace ){
-      assert( pIter->op==SQLITE_INSERT );
-      rc = sqlite3_exec(db, "SAVEPOINT replace_op", 0, 0, 0);
-      if( rc==SQLITE_OK ){
-        rc = sessionBindRow(pIter, 
-            sqlite3changeset_new, pApply->nCol, pApply->abPK, pApply->pDelete);
-        sqlite3_bind_int(pApply->pDelete, pApply->nCol+1, 1);
-      }
-      if( rc==SQLITE_OK ){
-        sqlite3_step(pApply->pDelete);
-        rc = sqlite3_reset(pApply->pDelete);
-      }
-      if( rc==SQLITE_OK ){
-        rc = sessionApplyOneOp(pIter, pApply, xConflict, pCtx, 0, 0);
-      }
-      if( rc==SQLITE_OK ){
-        rc = sqlite3_exec(db, "RELEASE replace_op", 0, 0, 0);
-      }
+    if( rc==SQLITE_OK ){
+      rc = sqlite3_exec(db, "RELEASE replace_op", 0, 0, 0);
     }
   }
 
@@ -184607,8 +182865,7 @@
     int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */
     sqlite3_changeset_iter *p     /* Handle describing change and conflict */
   ),
-  void *pCtx,                     /* First argument passed to xConflict */
-  void **ppRebase, int *pnRebase  /* OUT: Rebase information */
+  void *pCtx                      /* First argument passed to xConflict */
 ){
   int schemaMismatch = 0;
   int rc;                         /* Return code */
@@ -184646,18 +182903,9 @@
       sqlite3_finalize(sApply.pUpdate); 
       sqlite3_finalize(sApply.pInsert);
       sqlite3_finalize(sApply.pSelect);
+      memset(&sApply, 0, sizeof(sApply));
       sApply.db = db;
-      sApply.pDelete = 0;
-      sApply.pUpdate = 0;
-      sApply.pInsert = 0;
-      sApply.pSelect = 0;
-      sApply.nCol = 0;
-      sApply.azCol = 0;
-      sApply.abPK = 0;
-      sApply.bStat1 = 0;
       sApply.bDeferConstraints = 1;
-      sApply.bRebaseStarted = 0;
-      memset(&sApply.constraints, 0, sizeof(SessionBuffer));
 
       /* If an xFilter() callback was specified, invoke it now. If the 
       ** xFilter callback returns zero, skip this table. If it returns
@@ -184767,53 +183015,17 @@
     sqlite3_exec(db, "RELEASE changeset_apply", 0, 0, 0);
   }
 
-  if( rc==SQLITE_OK && bPatchset==0 && ppRebase && pnRebase ){
-    *ppRebase = (void*)sApply.rebase.aBuf;
-    *pnRebase = sApply.rebase.nBuf;
-    sApply.rebase.aBuf = 0;
-  }
   sqlite3_finalize(sApply.pInsert);
   sqlite3_finalize(sApply.pDelete);
   sqlite3_finalize(sApply.pUpdate);
   sqlite3_finalize(sApply.pSelect);
   sqlite3_free((char*)sApply.azCol);  /* cast works around VC++ bug */
   sqlite3_free((char*)sApply.constraints.aBuf);
-  sqlite3_free((char*)sApply.rebase.aBuf);
   sqlite3_mutex_leave(sqlite3_db_mutex(db));
   return rc;
 }
 
 /*
-** Apply the changeset passed via pChangeset/nChangeset to the main 
-** database attached to handle "db".
-*/
-SQLITE_API int sqlite3changeset_apply_v2(
-  sqlite3 *db,                    /* Apply change to "main" db of this handle */
-  int nChangeset,                 /* Size of changeset in bytes */
-  void *pChangeset,               /* Changeset blob */
-  int(*xFilter)(
-    void *pCtx,                   /* Copy of sixth arg to _apply() */
-    const char *zTab              /* Table name */
-  ),
-  int(*xConflict)(
-    void *pCtx,                   /* Copy of sixth arg to _apply() */
-    int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */
-    sqlite3_changeset_iter *p     /* Handle describing change and conflict */
-  ),
-  void *pCtx,                     /* First argument passed to xConflict */
-  void **ppRebase, int *pnRebase
-){
-  sqlite3_changeset_iter *pIter;  /* Iterator to skip through changeset */  
-  int rc = sqlite3changeset_start(&pIter, nChangeset, pChangeset);
-  if( rc==SQLITE_OK ){
-    rc = sessionChangesetApply(
-        db, pIter, xFilter, xConflict, pCtx, ppRebase, pnRebase
-    );
-  }
-  return rc;
-}
-
-/*
 ** Apply the changeset passed via pChangeset/nChangeset to the main database
 ** attached to handle "db". Invoke the supplied conflict handler callback
 ** to resolve any conflicts encountered while applying the change.
@@ -184833,9 +183045,12 @@
   ),
   void *pCtx                      /* First argument passed to xConflict */
 ){
-  return sqlite3changeset_apply_v2(
-      db, nChangeset, pChangeset, xFilter, xConflict, pCtx, 0, 0
-  );
+  sqlite3_changeset_iter *pIter;  /* Iterator to skip through changeset */  
+  int rc = sqlite3changeset_start(&pIter, nChangeset, pChangeset);
+  if( rc==SQLITE_OK ){
+    rc = sessionChangesetApply(db, pIter, xFilter, xConflict, pCtx);
+  }
+  return rc;
 }
 
 /*
@@ -184843,7 +183058,7 @@
 ** attached to handle "db". Invoke the supplied conflict handler callback
 ** to resolve any conflicts encountered while applying the change.
 */
-SQLITE_API int sqlite3changeset_apply_v2_strm(
+SQLITE_API int sqlite3changeset_apply_strm(
   sqlite3 *db,                    /* Apply change to "main" db of this handle */
   int (*xInput)(void *pIn, void *pData, int *pnData), /* Input function */
   void *pIn,                                          /* First arg for xInput */
@@ -184856,37 +183071,15 @@
     int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */
     sqlite3_changeset_iter *p     /* Handle describing change and conflict */
   ),
-  void *pCtx,                     /* First argument passed to xConflict */
-  void **ppRebase, int *pnRebase
+  void *pCtx                      /* First argument passed to xConflict */
 ){
   sqlite3_changeset_iter *pIter;  /* Iterator to skip through changeset */  
   int rc = sqlite3changeset_start_strm(&pIter, xInput, pIn);
   if( rc==SQLITE_OK ){
-    rc = sessionChangesetApply(
-        db, pIter, xFilter, xConflict, pCtx, ppRebase, pnRebase
-    );
+    rc = sessionChangesetApply(db, pIter, xFilter, xConflict, pCtx);
   }
   return rc;
 }
-SQLITE_API int sqlite3changeset_apply_strm(
-  sqlite3 *db,                    /* Apply change to "main" db of this handle */
-  int (*xInput)(void *pIn, void *pData, int *pnData), /* Input function */
-  void *pIn,                                          /* First arg for xInput */
-  int(*xFilter)(
-    void *pCtx,                   /* Copy of sixth arg to _apply() */
-    const char *zTab              /* Table name */
-  ),
-  int(*xConflict)(
-    void *pCtx,                   /* Copy of sixth arg to _apply() */
-    int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */
-    sqlite3_changeset_iter *p     /* Handle describing change and conflict */
-  ),
-  void *pCtx                      /* First argument passed to xConflict */
-){
-  return sqlite3changeset_apply_v2_strm(
-      db, xInput, pIn, xFilter, xConflict, pCtx, 0, 0
-  );
-}
 
 /*
 ** sqlite3_changegroup handle.
@@ -184904,7 +183097,6 @@
 */
 static int sessionChangeMerge(
   SessionTable *pTab,             /* Table structure */
-  int bRebase,                    /* True for a rebase hash-table */
   int bPatchset,                  /* True for patchsets */
   SessionChange *pExist,          /* Existing change */
   int op2,                        /* Second change operation */
@@ -184914,7 +183106,6 @@
   SessionChange **ppNew           /* OUT: Merged change */
 ){
   SessionChange *pNew = 0;
-  int rc = SQLITE_OK;
 
   if( !pExist ){
     pNew = (SessionChange *)sqlite3_malloc(sizeof(SessionChange) + nRec);
@@ -184924,66 +183115,9 @@
     memset(pNew, 0, sizeof(SessionChange));
     pNew->op = op2;
     pNew->bIndirect = bIndirect;
+    pNew->nRecord = nRec;
     pNew->aRecord = (u8*)&pNew[1];
-    if( bIndirect==0 || bRebase==0 ){
-      pNew->nRecord = nRec;
-      memcpy(pNew->aRecord, aRec, nRec);
-    }else{
-      int i;
-      u8 *pIn = aRec;
-      u8 *pOut = pNew->aRecord;
-      for(i=0; i<pTab->nCol; i++){
-        int nIn = sessionSerialLen(pIn);
-        if( *pIn==0 ){
-          *pOut++ = 0;
-        }else if( pTab->abPK[i]==0 ){
-          *pOut++ = 0xFF;
-        }else{
-          memcpy(pOut, pIn, nIn);
-          pOut += nIn;
-        }
-        pIn += nIn;
-      }
-      pNew->nRecord = pOut - pNew->aRecord;
-    }
-  }else if( bRebase ){
-    if( pExist->op==SQLITE_DELETE && pExist->bIndirect ){
-      *ppNew = pExist;
-    }else{
-      int nByte = nRec + pExist->nRecord + sizeof(SessionChange);
-      pNew = (SessionChange*)sqlite3_malloc(nByte);
-      if( pNew==0 ){
-        rc = SQLITE_NOMEM;
-      }else{
-        int i;
-        u8 *a1 = pExist->aRecord;
-        u8 *a2 = aRec;
-        u8 *pOut;
-
-        memset(pNew, 0, nByte);
-        pNew->bIndirect = bIndirect || pExist->bIndirect;
-        pNew->op = op2;
-        pOut = pNew->aRecord = (u8*)&pNew[1];
-
-        for(i=0; i<pTab->nCol; i++){
-          int n1 = sessionSerialLen(a1);
-          int n2 = sessionSerialLen(a2);
-          if( *a1==0xFF || (pTab->abPK[i]==0 && bIndirect) ){
-            *pOut++ = 0xFF;
-          }else if( *a2==0 ){
-            memcpy(pOut, a1, n1);
-            pOut += n1;
-          }else{
-            memcpy(pOut, a2, n2);
-            pOut += n2;
-          }
-          a1 += n1;
-          a2 += n2;
-        }
-        pNew->nRecord = pOut - pNew->aRecord;
-      }
-      sqlite3_free(pExist);
-    }
+    memcpy(pNew->aRecord, aRec, nRec);
   }else{
     int op1 = pExist->op;
 
@@ -185077,7 +183211,7 @@
   }
 
   *ppNew = pNew;
-  return rc;
+  return SQLITE_OK;
 }
 
 /*
@@ -185086,15 +183220,15 @@
 */
 static int sessionChangesetToHash(
   sqlite3_changeset_iter *pIter,   /* Iterator to read from */
-  sqlite3_changegroup *pGrp,       /* Changegroup object to add changeset to */
-  int bRebase                      /* True if hash table is for rebasing */
+  sqlite3_changegroup *pGrp        /* Changegroup object to add changeset to */
 ){
   u8 *aRec;
   int nRec;
   int rc = SQLITE_OK;
   SessionTable *pTab = 0;
 
-  while( SQLITE_ROW==sessionChangesetNext(pIter, &aRec, &nRec, 0) ){
+
+  while( SQLITE_ROW==sessionChangesetNext(pIter, &aRec, &nRec) ){
     const char *zNew;
     int nCol;
     int op;
@@ -185174,7 +183308,7 @@
       }
     }
 
-    rc = sessionChangeMerge(pTab, bRebase, 
+    rc = sessionChangeMerge(pTab, 
         pIter->bPatchset, pExist, op, bIndirect, aRec, nRec, &pChange
     );
     if( rc ) break;
@@ -185282,7 +183416,7 @@
 
   rc = sqlite3changeset_start(&pIter, nData, pData);
   if( rc==SQLITE_OK ){
-    rc = sessionChangesetToHash(pIter, pGrp, 0);
+    rc = sessionChangesetToHash(pIter, pGrp);
   }
   sqlite3changeset_finalize(pIter);
   return rc;
@@ -185313,7 +183447,7 @@
 
   rc = sqlite3changeset_start_strm(&pIter, xInput, pIn);
   if( rc==SQLITE_OK ){
-    rc = sessionChangesetToHash(pIter, pGrp, 0);
+    rc = sessionChangesetToHash(pIter, pGrp);
   }
   sqlite3changeset_finalize(pIter);
   return rc;
@@ -185398,349 +183532,6 @@
   return rc;
 }
 
-/*
-** Changeset rebaser handle.
-*/
-struct sqlite3_rebaser {
-  sqlite3_changegroup grp;        /* Hash table */
-};
-
-/*
-** Buffers a1 and a2 must both contain a sessions module record nCol
-** fields in size. This function appends an nCol sessions module 
-** record to buffer pBuf that is a copy of a1, except that for
-** each field that is undefined in a1[], swap in the field from a2[].
-*/
-static void sessionAppendRecordMerge(
-  SessionBuffer *pBuf,            /* Buffer to append to */
-  int nCol,                       /* Number of columns in each record */
-  u8 *a1, int n1,                 /* Record 1 */
-  u8 *a2, int n2,                 /* Record 2 */
-  int *pRc                        /* IN/OUT: error code */
-){
-  sessionBufferGrow(pBuf, n1+n2, pRc);
-  if( *pRc==SQLITE_OK ){
-    int i;
-    u8 *pOut = &pBuf->aBuf[pBuf->nBuf];
-    for(i=0; i<nCol; i++){
-      int nn1 = sessionSerialLen(a1);
-      int nn2 = sessionSerialLen(a2);
-      if( *a1==0 || *a1==0xFF ){
-        memcpy(pOut, a2, nn2);
-        pOut += nn2;
-      }else{
-        memcpy(pOut, a1, nn1);
-        pOut += nn1;
-      }
-      a1 += nn1;
-      a2 += nn2;
-    }
-
-    pBuf->nBuf = pOut-pBuf->aBuf;
-    assert( pBuf->nBuf<=pBuf->nAlloc );
-  }
-}
-
-/*
-** This function is called when rebasing a local UPDATE change against one 
-** or more remote UPDATE changes. The aRec/nRec buffer contains the current
-** old.* and new.* records for the change. The rebase buffer (a single
-** record) is in aChange/nChange. The rebased change is appended to buffer
-** pBuf.
-**
-** Rebasing the UPDATE involves: 
-**
-**   * Removing any changes to fields for which the corresponding field
-**     in the rebase buffer is set to "replaced" (type 0xFF). If this
-**     means the UPDATE change updates no fields, nothing is appended
-**     to the output buffer.
-**
-**   * For each field modified by the local change for which the 
-**     corresponding field in the rebase buffer is not "undefined" (0x00)
-**     or "replaced" (0xFF), the old.* value is replaced by the value
-**     in the rebase buffer.
-*/
-static void sessionAppendPartialUpdate(
-  SessionBuffer *pBuf,            /* Append record here */
-  sqlite3_changeset_iter *pIter,  /* Iterator pointed at local change */
-  u8 *aRec, int nRec,             /* Local change */
-  u8 *aChange, int nChange,       /* Record to rebase against */
-  int *pRc                        /* IN/OUT: Return Code */
-){
-  sessionBufferGrow(pBuf, 2+nRec+nChange, pRc);
-  if( *pRc==SQLITE_OK ){
-    int bData = 0;
-    u8 *pOut = &pBuf->aBuf[pBuf->nBuf];
-    int i;
-    u8 *a1 = aRec;
-    u8 *a2 = aChange;
-
-    *pOut++ = SQLITE_UPDATE;
-    *pOut++ = pIter->bIndirect;
-    for(i=0; i<pIter->nCol; i++){
-      int n1 = sessionSerialLen(a1);
-      int n2 = sessionSerialLen(a2);
-      if( pIter->abPK[i] || a2[0]==0 ){
-        if( !pIter->abPK[i] ) bData = 1;
-        memcpy(pOut, a1, n1);
-        pOut += n1;
-      }else if( a2[0]!=0xFF ){
-        bData = 1;
-        memcpy(pOut, a2, n2);
-        pOut += n2;
-      }else{
-        *pOut++ = '\0';
-      }
-      a1 += n1;
-      a2 += n2;
-    }
-    if( bData ){
-      a2 = aChange;
-      for(i=0; i<pIter->nCol; i++){
-        int n1 = sessionSerialLen(a1);
-        int n2 = sessionSerialLen(a2);
-        if( pIter->abPK[i] || a2[0]!=0xFF ){
-          memcpy(pOut, a1, n1);
-          pOut += n1;
-        }else{
-          *pOut++ = '\0';
-        }
-        a1 += n1;
-        a2 += n2;
-      }
-      pBuf->nBuf = (pOut - pBuf->aBuf);
-    }
-  }
-}
-
-/*
-** pIter is configured to iterate through a changeset. This function rebases 
-** that changeset according to the current configuration of the rebaser 
-** object passed as the first argument. If no error occurs and argument xOutput
-** is not NULL, then the changeset is returned to the caller by invoking
-** xOutput zero or more times and SQLITE_OK returned. Or, if xOutput is NULL,
-** then (*ppOut) is set to point to a buffer containing the rebased changeset
-** before this function returns. In this case (*pnOut) is set to the size of
-** the buffer in bytes.  It is the responsibility of the caller to eventually
-** free the (*ppOut) buffer using sqlite3_free(). 
-**
-** If an error occurs, an SQLite error code is returned. If ppOut and
-** pnOut are not NULL, then the two output parameters are set to 0 before
-** returning.
-*/
-static int sessionRebase(
-  sqlite3_rebaser *p,             /* Rebaser hash table */
-  sqlite3_changeset_iter *pIter,  /* Input data */
-  int (*xOutput)(void *pOut, const void *pData, int nData),
-  void *pOut,                     /* Context for xOutput callback */
-  int *pnOut,                     /* OUT: Number of bytes in output changeset */
-  void **ppOut                    /* OUT: Inverse of pChangeset */
-){
-  int rc = SQLITE_OK;
-  u8 *aRec = 0;
-  int nRec = 0;
-  int bNew = 0;
-  SessionTable *pTab = 0;
-  SessionBuffer sOut = {0,0,0};
-
-  while( SQLITE_ROW==sessionChangesetNext(pIter, &aRec, &nRec, &bNew) ){
-    SessionChange *pChange = 0;
-    int bDone = 0;
-
-    if( bNew ){
-      const char *zTab = pIter->zTab;
-      for(pTab=p->grp.pList; pTab; pTab=pTab->pNext){
-        if( 0==sqlite3_stricmp(pTab->zName, zTab) ) break;
-      }
-      bNew = 0;
-
-      /* A patchset may not be rebased */
-      if( pIter->bPatchset ){
-        rc = SQLITE_ERROR;
-      }
-
-      /* Append a table header to the output for this new table */
-      sessionAppendByte(&sOut, pIter->bPatchset ? 'P' : 'T', &rc);
-      sessionAppendVarint(&sOut, pIter->nCol, &rc);
-      sessionAppendBlob(&sOut, pIter->abPK, pIter->nCol, &rc);
-      sessionAppendBlob(&sOut,(u8*)pIter->zTab,(int)strlen(pIter->zTab)+1,&rc);
-    }
-
-    if( pTab && rc==SQLITE_OK ){
-      int iHash = sessionChangeHash(pTab, 0, aRec, pTab->nChange);
-
-      for(pChange=pTab->apChange[iHash]; pChange; pChange=pChange->pNext){
-        if( sessionChangeEqual(pTab, 0, aRec, 0, pChange->aRecord) ){
-          break;
-        }
-      }
-    }
-
-    if( pChange ){
-      assert( pChange->op==SQLITE_DELETE || pChange->op==SQLITE_INSERT );
-      switch( pIter->op ){
-        case SQLITE_INSERT:
-          if( pChange->op==SQLITE_INSERT ){
-            bDone = 1;
-            if( pChange->bIndirect==0 ){
-              sessionAppendByte(&sOut, SQLITE_UPDATE, &rc);
-              sessionAppendByte(&sOut, pIter->bIndirect, &rc);
-              sessionAppendBlob(&sOut, pChange->aRecord, pChange->nRecord, &rc);
-              sessionAppendBlob(&sOut, aRec, nRec, &rc);
-            }
-          }
-          break;
-
-        case SQLITE_UPDATE:
-          bDone = 1;
-          if( pChange->op==SQLITE_DELETE ){
-            if( pChange->bIndirect==0 ){
-              u8 *pCsr = aRec;
-              sessionSkipRecord(&pCsr, pIter->nCol);
-              sessionAppendByte(&sOut, SQLITE_INSERT, &rc);
-              sessionAppendByte(&sOut, pIter->bIndirect, &rc);
-              sessionAppendRecordMerge(&sOut, pIter->nCol,
-                  pCsr, nRec-(pCsr-aRec), 
-                  pChange->aRecord, pChange->nRecord, &rc
-              );
-            }
-          }else{
-            sessionAppendPartialUpdate(&sOut, pIter,
-                aRec, nRec, pChange->aRecord, pChange->nRecord, &rc
-            );
-          }
-          break;
-
-        default:
-          assert( pIter->op==SQLITE_DELETE );
-          bDone = 1;
-          if( pChange->op==SQLITE_INSERT ){
-            sessionAppendByte(&sOut, SQLITE_DELETE, &rc);
-            sessionAppendByte(&sOut, pIter->bIndirect, &rc);
-            sessionAppendRecordMerge(&sOut, pIter->nCol,
-                pChange->aRecord, pChange->nRecord, aRec, nRec, &rc
-            );
-          }
-          break;
-      }
-    }
-
-    if( bDone==0 ){
-      sessionAppendByte(&sOut, pIter->op, &rc);
-      sessionAppendByte(&sOut, pIter->bIndirect, &rc);
-      sessionAppendBlob(&sOut, aRec, nRec, &rc);
-    }
-    if( rc==SQLITE_OK && xOutput && sOut.nBuf>SESSIONS_STRM_CHUNK_SIZE ){
-      rc = xOutput(pOut, sOut.aBuf, sOut.nBuf);
-      sOut.nBuf = 0;
-    }
-    if( rc ) break;
-  }
-
-  if( rc!=SQLITE_OK ){
-    sqlite3_free(sOut.aBuf);
-    memset(&sOut, 0, sizeof(sOut));
-  }
-
-  if( rc==SQLITE_OK ){
-    if( xOutput ){
-      if( sOut.nBuf>0 ){
-        rc = xOutput(pOut, sOut.aBuf, sOut.nBuf);
-      }
-    }else{
-      *ppOut = (void*)sOut.aBuf;
-      *pnOut = sOut.nBuf;
-      sOut.aBuf = 0;
-    }
-  }
-  sqlite3_free(sOut.aBuf);
-  return rc;
-}
-
-/* 
-** Create a new rebaser object.
-*/
-SQLITE_API int sqlite3rebaser_create(sqlite3_rebaser **ppNew){
-  int rc = SQLITE_OK;
-  sqlite3_rebaser *pNew;
-
-  pNew = sqlite3_malloc(sizeof(sqlite3_rebaser));
-  if( pNew==0 ){
-    rc = SQLITE_NOMEM;
-  }else{
-    memset(pNew, 0, sizeof(sqlite3_rebaser));
-  }
-  *ppNew = pNew;
-  return rc;
-}
-
-/* 
-** Call this one or more times to configure a rebaser.
-*/
-SQLITE_API int sqlite3rebaser_configure(
-  sqlite3_rebaser *p, 
-  int nRebase, const void *pRebase
-){
-  sqlite3_changeset_iter *pIter = 0;   /* Iterator opened on pData/nData */
-  int rc;                              /* Return code */
-  rc = sqlite3changeset_start(&pIter, nRebase, (void*)pRebase);
-  if( rc==SQLITE_OK ){
-    rc = sessionChangesetToHash(pIter, &p->grp, 1);
-  }
-  sqlite3changeset_finalize(pIter);
-  return rc;
-}
-
-/* 
-** Rebase a changeset according to current rebaser configuration 
-*/
-SQLITE_API int sqlite3rebaser_rebase(
-  sqlite3_rebaser *p,
-  int nIn, const void *pIn, 
-  int *pnOut, void **ppOut 
-){
-  sqlite3_changeset_iter *pIter = 0;   /* Iterator to skip through input */  
-  int rc = sqlite3changeset_start(&pIter, nIn, (void*)pIn);
-
-  if( rc==SQLITE_OK ){
-    rc = sessionRebase(p, pIter, 0, 0, pnOut, ppOut);
-    sqlite3changeset_finalize(pIter);
-  }
-
-  return rc;
-}
-
-/* 
-** Rebase a changeset according to current rebaser configuration 
-*/
-SQLITE_API int sqlite3rebaser_rebase_strm(
-  sqlite3_rebaser *p,
-  int (*xInput)(void *pIn, void *pData, int *pnData),
-  void *pIn,
-  int (*xOutput)(void *pOut, const void *pData, int nData),
-  void *pOut
-){
-  sqlite3_changeset_iter *pIter = 0;   /* Iterator to skip through input */  
-  int rc = sqlite3changeset_start_strm(&pIter, xInput, pIn);
-
-  if( rc==SQLITE_OK ){
-    rc = sessionRebase(p, pIter, xOutput, pOut, 0, 0);
-    sqlite3changeset_finalize(pIter);
-  }
-
-  return rc;
-}
-
-/* 
-** Destroy a rebaser object 
-*/
-SQLITE_API void sqlite3rebaser_delete(sqlite3_rebaser *p){
-  if( p ){
-    sessionDeleteTable(p->grp.pList);
-    sqlite3_free(p);
-  }
-}
-
 #endif /* SQLITE_ENABLE_SESSION && SQLITE_ENABLE_PREUPDATE_HOOK */
 
 /************** End of sqlite3session.c **************************************/
@@ -190276,8 +188067,7 @@
 #endif
   do{
     i = fts5yy_shift_ofst[stateno];
-    assert( i>=0 );
-    assert( i+fts5YYNFTS5TOKEN<=(int)sizeof(fts5yy_lookahead)/sizeof(fts5yy_lookahead[0]) );
+    assert( i>=0 && i+fts5YYNFTS5TOKEN<=sizeof(fts5yy_lookahead)/sizeof(fts5yy_lookahead[0]) );
     assert( iLookAhead!=fts5YYNOCODE );
     assert( iLookAhead < fts5YYNFTS5TOKEN );
     i += iLookAhead;
@@ -194719,7 +192509,7 @@
       ** no token characters at all. (e.g ... MATCH '""'). */
       sCtx.pPhrase = sqlite3Fts5MallocZero(&pParse->rc, sizeof(Fts5ExprPhrase));
     }else if( sCtx.pPhrase->nTerm ){
-      sCtx.pPhrase->aTerm[sCtx.pPhrase->nTerm-1].bPrefix = (u8)bPrefix;
+      sCtx.pPhrase->aTerm[sCtx.pPhrase->nTerm-1].bPrefix = bPrefix;
     }
     pParse->apPhrase[pParse->nPhrase-1] = sCtx.pPhrase;
   }
@@ -197182,7 +194972,6 @@
   sqlite3_bind_blob(p->pWriter, 2, pData, nData, SQLITE_STATIC);
   sqlite3_step(p->pWriter);
   p->rc = sqlite3_reset(p->pWriter);
-  sqlite3_bind_null(p->pWriter, 2);
 }
 
 /*
@@ -198811,7 +196600,6 @@
     bDlidx = (val & 0x0001);
   }
   p->rc = sqlite3_reset(pIdxSelect);
-  sqlite3_bind_null(pIdxSelect, 2);
 
   if( iPg<pSeg->pgnoFirst ){
     iPg = pSeg->pgnoFirst;
@@ -200024,7 +197812,6 @@
           sqlite3_bind_blob(pIdxSelect, 2, aBlob, 2, SQLITE_STATIC);
           assert( sqlite3_step(pIdxSelect)!=SQLITE_ROW );
           p->rc = sqlite3_reset(pIdxSelect);
-          sqlite3_bind_null(pIdxSelect, 2);
         }
       }
 #endif
@@ -200151,7 +197938,6 @@
     sqlite3_bind_int64(p->pIdxWriter, 3, bFlag + ((i64)pWriter->iBtPage<<1));
     sqlite3_step(p->pIdxWriter);
     p->rc = sqlite3_reset(p->pIdxWriter);
-    sqlite3_bind_null(p->pIdxWriter, 2);
   }
   pWriter->iBtPage = 0;
 }
@@ -205559,7 +203345,7 @@
 ){
   assert( nArg==0 );
   UNUSED_PARAM2(nArg, apUnused);
-  sqlite3_result_text(pCtx, "fts5: 2018-04-02 11:04:16 736b53f57f70b23172c30880186dce7ad9baa3b74e3838cae5847cffb98f5cd2", -1, SQLITE_TRANSIENT);
+  sqlite3_result_text(pCtx, "fts5: 2018-01-22 18:45:57 0c55d179733b46d8d0ba4d88e01a25e10677046ee3da1d5b1581e86726f2171d", -1, SQLITE_TRANSIENT);
 }
 
 static int fts5Init(sqlite3 *db){
@@ -206135,7 +203921,6 @@
       sqlite3_bind_blob(pReplace, 2, pBuf->p, pBuf->n, SQLITE_STATIC);
       sqlite3_step(pReplace);
       rc = sqlite3_reset(pReplace);
-      sqlite3_bind_null(pReplace, 2);
     }
   }
   return rc;
@@ -206796,7 +204581,6 @@
     }
     sqlite3_step(pReplace);
     rc = sqlite3_reset(pReplace);
-    sqlite3_bind_null(pReplace, 1);
   }
   if( rc==SQLITE_OK && pVal ){
     int iNew = p->pConfig->iCookie + 1;
@@ -209829,9 +207613,9 @@
 #endif /* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_STMTVTAB) */
 
 /************** End of stmt.c ************************************************/
-#if __LINE__!=209832
+#if __LINE__!=207604
 #undef SQLITE_SOURCE_ID
-#define SQLITE_SOURCE_ID      "2018-04-02 11:04:16 736b53f57f70b23172c30880186dce7ad9baa3b74e3838cae5847cffb98falt2"
+#define SQLITE_SOURCE_ID      "2018-01-22 18:45:57 0c55d179733b46d8d0ba4d88e01a25e10677046ee3da1d5b1581e86726f2alt2"
 #endif
 /* Return the source-id for this library */
 SQLITE_API const char *sqlite3_sourceid(void){ return SQLITE_SOURCE_ID; }
diff -r -u -d orig/sqlite3ext.h ./sqlite3ext.h
--- orig/sqlite3ext.h	2018-04-02 13:20:53.000000000 +0200
+++ ./sqlite3ext.h	2018-04-05 23:09:10.679182744 +0200
@@ -563,8 +563,8 @@
 #define sqlite3_value_pointer          sqlite3_api->value_pointer
 /* Version 3.22.0 and later */
 #define sqlite3_vtab_nochange          sqlite3_api->vtab_nochange
-#define sqlite3_value_nochange         sqlite3_api->value_nochange
-#define sqlite3_vtab_collation         sqlite3_api->vtab_collation
+#define sqlite3_value_nochange         sqltie3_api->value_nochange
+#define sqlite3_vtab_collation         sqltie3_api->vtab_collation
 #endif /* !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION) */
 
 #if !defined(SQLITE_CORE) && !defined(SQLITE_OMIT_LOAD_EXTENSION)
diff -r -u -d orig/sqlite3.h ./sqlite3.h
--- orig/sqlite3.h	2018-04-02 13:20:53.000000000 +0200
+++ ./sqlite3.h	2018-04-05 23:08:54.416000367 +0200
@@ -123,9 +123,9 @@
 ** [sqlite3_libversion_number()], [sqlite3_sourceid()],
 ** [sqlite_version()] and [sqlite_source_id()].
 */
-#define SQLITE_VERSION        "3.23.0"
-#define SQLITE_VERSION_NUMBER 3023000
-#define SQLITE_SOURCE_ID      "2018-04-02 11:04:16 736b53f57f70b23172c30880186dce7ad9baa3b74e3838cae5847cffb98f5cd2"
+#define SQLITE_VERSION        "3.22.0"
+#define SQLITE_VERSION_NUMBER 3022000
+#define SQLITE_SOURCE_ID      "2018-01-22 18:45:57 0c55d179733b46d8d0ba4d88e01a25e10677046ee3da1d5b1581e86726f2171d"
 
 /*
 ** CAPI3REF: Run-Time Library Version Numbers
@@ -1064,12 +1064,6 @@
 ** so that all subsequent write operations are independent.
 ** ^SQLite will never invoke SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE without
 ** a prior successful call to [SQLITE_FCNTL_BEGIN_ATOMIC_WRITE].
-**
-** <li>[[SQLITE_FCNTL_LOCK_TIMEOUT]]
-** The [SQLITE_FCNTL_LOCK_TIMEOUT] opcode causes attempts to obtain
-** a file lock using the xLock or xShmLock methods of the VFS to wait
-** for up to M milliseconds before failing, where M is the single 
-** unsigned integer parameter.
 ** </ul>
 */
 #define SQLITE_FCNTL_LOCKSTATE               1
@@ -1104,7 +1098,6 @@
 #define SQLITE_FCNTL_BEGIN_ATOMIC_WRITE     31
 #define SQLITE_FCNTL_COMMIT_ATOMIC_WRITE    32
 #define SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE  33
-#define SQLITE_FCNTL_LOCK_TIMEOUT           34
 
 /* deprecated names */
 #define SQLITE_GET_LOCKPROXYFILE      SQLITE_FCNTL_GET_LOCKPROXYFILE
@@ -2061,13 +2054,11 @@
 ** connections at all to the database. If so, it performs a checkpoint 
 ** operation before closing the connection. This option may be used to
 ** override this behaviour. The first parameter passed to this operation
-** is an integer - positive to disable checkpoints-on-close, or zero (the
-** default) to enable them, and negative to leave the setting unchanged.
-** The second parameter is a pointer to an integer
+** is an integer - non-zero to disable checkpoints-on-close, or zero (the
+** default) to enable them. The second parameter is a pointer to an integer
 ** into which is written 0 or 1 to indicate whether checkpoints-on-close
 ** have been disabled - 0 if they are not disabled, 1 if they are.
 ** </dd>
-**
 ** <dt>SQLITE_DBCONFIG_ENABLE_QPSG</dt>
 ** <dd>^(The SQLITE_DBCONFIG_ENABLE_QPSG option activates or deactivates
 ** the [query planner stability guarantee] (QPSG).  When the QPSG is active,
@@ -2077,20 +2068,13 @@
 ** slower.  But the QPSG has the advantage of more predictable behavior.  With
 ** the QPSG active, SQLite will always use the same query plan in the field as
 ** was used during testing in the lab.
-** The first argument to this setting is an integer which is 0 to disable 
-** the QPSG, positive to enable QPSG, or negative to leave the setting
-** unchanged. The second parameter is a pointer to an integer into which
-** is written 0 or 1 to indicate whether the QPSG is disabled or enabled
-** following this call.
 ** </dd>
-**
 ** <dt>SQLITE_DBCONFIG_TRIGGER_EQP</dt>
 ** <dd> By default, the output of EXPLAIN QUERY PLAN commands does not 
 ** include output for any operations performed by trigger programs. This
 ** option is used to set or clear (the default) a flag that governs this
 ** behavior. The first parameter passed to this operation is an integer -
-** positive to enable output for trigger programs, or zero to disable it,
-** or negative to leave the setting unchanged.
+** non-zero to enable output for trigger programs, or zero to disable it.
 ** The second parameter is a pointer to an integer into which is written 
 ** 0 or 1 to indicate whether output-for-triggers has been disabled - 0 if 
 ** it is not disabled, 1 if it is.  
@@ -2512,16 +2496,16 @@
 **
 ** These routines are work-alikes of the "printf()" family of functions
 ** from the standard C library.
-** These routines understand most of the common formatting options from
-** the standard library printf() 
-** plus some additional non-standard formats ([%q], [%Q], [%w], and [%z]).
-** See the [built-in printf()] documentation for details.
+** These routines understand most of the common K&R formatting options,
+** plus some additional non-standard formats, detailed below.
+** Note that some of the more obscure formatting options from recent
+** C-library standards are omitted from this implementation.
 **
 ** ^The sqlite3_mprintf() and sqlite3_vmprintf() routines write their
-** results into memory obtained from [sqlite3_malloc64()].
+** results into memory obtained from [sqlite3_malloc()].
 ** The strings returned by these two routines should be
 ** released by [sqlite3_free()].  ^Both routines return a
-** NULL pointer if [sqlite3_malloc64()] is unable to allocate enough
+** NULL pointer if [sqlite3_malloc()] is unable to allocate enough
 ** memory to hold the resulting string.
 **
 ** ^(The sqlite3_snprintf() routine is similar to "snprintf()" from
@@ -2545,7 +2529,71 @@
 **
 ** ^The sqlite3_vsnprintf() routine is a varargs version of sqlite3_snprintf().
 **
-** See also:  [built-in printf()], [printf() SQL function]
+** These routines all implement some additional formatting
+** options that are useful for constructing SQL statements.
+** All of the usual printf() formatting options apply.  In addition, there
+** is are "%q", "%Q", "%w" and "%z" options.
+**
+** ^(The %q option works like %s in that it substitutes a nul-terminated
+** string from the argument list.  But %q also doubles every '\'' character.
+** %q is designed for use inside a string literal.)^  By doubling each '\''
+** character it escapes that character and allows it to be inserted into
+** the string.
+**
+** For example, assume the string variable zText contains text as follows:
+**
+** <blockquote><pre>
+**  char *zText = "It's a happy day!";
+** </pre></blockquote>
+**
+** One can use this text in an SQL statement as follows:
+**
+** <blockquote><pre>
+**  char *zSQL = sqlite3_mprintf("INSERT INTO table VALUES('%q')", zText);
+**  sqlite3_exec(db, zSQL, 0, 0, 0);
+**  sqlite3_free(zSQL);
+** </pre></blockquote>
+**
+** Because the %q format string is used, the '\'' character in zText
+** is escaped and the SQL generated is as follows:
+**
+** <blockquote><pre>
+**  INSERT INTO table1 VALUES('It''s a happy day!')
+** </pre></blockquote>
+**
+** This is correct.  Had we used %s instead of %q, the generated SQL
+** would have looked like this:
+**
+** <blockquote><pre>
+**  INSERT INTO table1 VALUES('It's a happy day!');
+** </pre></blockquote>
+**
+** This second example is an SQL syntax error.  As a general rule you should
+** always use %q instead of %s when inserting text into a string literal.
+**
+** ^(The %Q option works like %q except it also adds single quotes around
+** the outside of the total string.  Additionally, if the parameter in the
+** argument list is a NULL pointer, %Q substitutes the text "NULL" (without
+** single quotes).)^  So, for example, one could say:
+**
+** <blockquote><pre>
+**  char *zSQL = sqlite3_mprintf("INSERT INTO table VALUES(%Q)", zText);
+**  sqlite3_exec(db, zSQL, 0, 0, 0);
+**  sqlite3_free(zSQL);
+** </pre></blockquote>
+**
+** The code above will render a correct SQL statement in the zSQL
+** variable even if the zText variable is a NULL pointer.
+**
+** ^(The "%w" formatting option is like "%q" except that it expects to
+** be contained within double-quotes instead of single quotes, and it
+** escapes the double-quote character instead of the single-quote
+** character.)^  The "%w" formatting option is intended for safely inserting
+** table and column names into a constructed SQL statement.
+**
+** ^(The "%z" formatting option works like "%s" but with the
+** addition that after the string has been read and copied into
+** the result, [sqlite3_free()] is called on the input string.)^
 */
 SQLITE_API char *sqlite3_mprintf(const char*,...);
 SQLITE_API char *sqlite3_vmprintf(const char*, va_list);
@@ -3611,13 +3659,13 @@
 ** or [GLOB] operator or if the parameter is compared to an indexed column
 ** and the [SQLITE_ENABLE_STAT3] compile-time option is enabled.
 ** </li>
-** </ol>
 **
 ** <p>^sqlite3_prepare_v3() differs from sqlite3_prepare_v2() only in having
 ** the extra prepFlags parameter, which is a bit array consisting of zero or
 ** more of the [SQLITE_PREPARE_PERSISTENT|SQLITE_PREPARE_*] flags.  ^The
 ** sqlite3_prepare_v2() interface works exactly the same as
 ** sqlite3_prepare_v3() with a zero prepFlags parameter.
+** </ol>
 */
 SQLITE_API int sqlite3_prepare(
   sqlite3 *db,            /* Database handle */
@@ -7246,15 +7294,6 @@
 ** highwater mark associated with SQLITE_DBSTATUS_CACHE_WRITE is always 0.
 ** </dd>
 **
-** [[SQLITE_DBSTATUS_CACHE_SPILL]] ^(<dt>SQLITE_DBSTATUS_CACHE_SPILL</dt>
-** <dd>This parameter returns the number of dirty cache entries that have
-** been written to disk in the middle of a transaction due to the page
-** cache overflowing. Transactions are more efficient if they are written
-** to disk all at once. When pages spill mid-transaction, that introduces
-** additional overhead. This parameter can be used help identify
-** inefficiencies that can be resolve by increasing the cache size.
-** </dd>
-**
 ** [[SQLITE_DBSTATUS_DEFERRED_FKS]] ^(<dt>SQLITE_DBSTATUS_DEFERRED_FKS</dt>
 ** <dd>This parameter returns zero for the current value if and only if
 ** all foreign key constraints (deferred or immediate) have been
@@ -7274,8 +7313,7 @@
 #define SQLITE_DBSTATUS_CACHE_WRITE          9
 #define SQLITE_DBSTATUS_DEFERRED_FKS        10
 #define SQLITE_DBSTATUS_CACHE_USED_SHARED   11
-#define SQLITE_DBSTATUS_CACHE_SPILL         12
-#define SQLITE_DBSTATUS_MAX                 12   /* Largest defined DBSTATUS */
+#define SQLITE_DBSTATUS_MAX                 11   /* Largest defined DBSTATUS */
 
 
 /*
@@ -8756,128 +8794,6 @@
 SQLITE_API SQLITE_EXPERIMENTAL int sqlite3_snapshot_recover(sqlite3 *db, const char *zDb);
 
 /*
-** CAPI3REF: Serialize a database
-**
-** The sqlite3_serialize(D,S,P,F) interface returns a pointer to memory
-** that is a serialization of the S database on [database connection] D.
-** If P is not a NULL pointer, then the size of the database in bytes
-** is written into *P.
-**
-** For an ordinary on-disk database file, the serialization is just a
-** copy of the disk file.  For an in-memory database or a "TEMP" database,
-** the serialization is the same sequence of bytes which would be written
-** to disk if that database where backed up to disk.
-**
-** The usual case is that sqlite3_serialize() copies the serialization of
-** the database into memory obtained from [sqlite3_malloc64()] and returns
-** a pointer to that memory.  The caller is responsible for freeing the
-** returned value to avoid a memory leak.  However, if the F argument
-** contains the SQLITE_SERIALIZE_NOCOPY bit, then no memory allocations
-** are made, and the sqlite3_serialize() function will return a pointer
-** to the contiguous memory representation of the database that SQLite
-** is currently using for that database, or NULL if the no such contiguous
-** memory representation of the database exists.  A contiguous memory
-** representation of the database will usually only exist if there has
-** been a prior call to [sqlite3_deserialize(D,S,...)] with the same
-** values of D and S.
-** The size of the database is written into *P even if the 
-** SQLITE_SERIALIZE_NOCOPY bit is set but no contigious copy
-** of the database exists.
-**
-** A call to sqlite3_serialize(D,S,P,F) might return NULL even if the
-** SQLITE_SERIALIZE_NOCOPY bit is omitted from argument F if a memory
-** allocation error occurs.
-**
-** This interface is only available if SQLite is compiled with the
-** [SQLITE_ENABLE_DESERIALIZE] option.
-*/
-SQLITE_API unsigned char *sqlite3_serialize(
-  sqlite3 *db,           /* The database connection */
-  const char *zSchema,   /* Which DB to serialize. ex: "main", "temp", ... */
-  sqlite3_int64 *piSize, /* Write size of the DB here, if not NULL */
-  unsigned int mFlags    /* Zero or more SQLITE_SERIALIZE_* flags */
-);
-
-/*
-** CAPI3REF: Flags for sqlite3_serialize
-**
-** Zero or more of the following constants can be OR-ed together for
-** the F argument to [sqlite3_serialize(D,S,P,F)].
-**
-** SQLITE_SERIALIZE_NOCOPY means that [sqlite3_serialize()] will return
-** a pointer to contiguous in-memory database that it is currently using,
-** without making a copy of the database.  If SQLite is not currently using
-** a contiguous in-memory database, then this option causes
-** [sqlite3_serialize()] to return a NULL pointer.  SQLite will only be
-** using a contiguous in-memory database if it has been initialized by a
-** prior call to [sqlite3_deserialize()].
-*/
-#define SQLITE_SERIALIZE_NOCOPY 0x001   /* Do no memory allocations */
-
-/*
-** CAPI3REF: Deserialize a database
-**
-** The sqlite3_deserialize(D,S,P,N,M,F) interface causes the 
-** [database connection] D to disconnect from database S and then
-** reopen S as an in-memory database based on the serialization contained
-** in P.  The serialized database P is N bytes in size.  M is the size of
-** the buffer P, which might be larger than N.  If M is larger than N, and
-** the SQLITE_DESERIALIZE_READONLY bit is not set in F, then SQLite is
-** permitted to add content to the in-memory database as long as the total
-** size does not exceed M bytes.
-**
-** If the SQLITE_DESERIALIZE_FREEONCLOSE bit is set in F, then SQLite will
-** invoke sqlite3_free() on the serialization buffer when the database
-** connection closes.  If the SQLITE_DESERIALIZE_RESIZEABLE bit is set, then
-** SQLite will try to increase the buffer size using sqlite3_realloc64()
-** if writes on the database cause it to grow larger than M bytes.
-**
-** The sqlite3_deserialize() interface will fail with SQLITE_BUSY if the
-** database is currently in a read transaction or is involved in a backup
-** operation.
-**
-** If sqlite3_deserialize(D,S,P,N,M,F) fails for any reason and if the 
-** SQLITE_DESERIALIZE_FREEONCLOSE bit is set in argument F, then
-** [sqlite3_free()] is invoked on argument P prior to returning.
-**
-** This interface is only available if SQLite is compiled with the
-** [SQLITE_ENABLE_DESERIALIZE] option.
-*/
-SQLITE_API int sqlite3_deserialize(
-  sqlite3 *db,            /* The database connection */
-  const char *zSchema,    /* Which DB to reopen with the deserialization */
-  unsigned char *pData,   /* The serialized database content */
-  sqlite3_int64 szDb,     /* Number bytes in the deserialization */
-  sqlite3_int64 szBuf,    /* Total size of buffer pData[] */
-  unsigned mFlags         /* Zero or more SQLITE_DESERIALIZE_* flags */
-);
-
-/*
-** CAPI3REF: Flags for sqlite3_deserialize()
-**
-** The following are allowed values for 6th argument (the F argument) to
-** the [sqlite3_deserialize(D,S,P,N,M,F)] interface.
-**
-** The SQLITE_DESERIALIZE_FREEONCLOSE means that the database serialization
-** in the P argument is held in memory obtained from [sqlite3_malloc64()]
-** and that SQLite should take ownership of this memory and automatically
-** free it when it has finished using it.  Without this flag, the caller
-** is resposible for freeing any dynamically allocated memory.
-**
-** The SQLITE_DESERIALIZE_RESIZEABLE flag means that SQLite is allowed to
-** grow the size of the database using calls to [sqlite3_realloc64()].  This
-** flag should only be used if SQLITE_DESERIALIZE_FREEONCLOSE is also used.
-** Without this flag, the deserialized database cannot increase in size beyond
-** the number of bytes specified by the M parameter.
-**
-** The SQLITE_DESERIALIZE_READONLY flag means that the deserialized database
-** should be treated as read-only.
-*/
-#define SQLITE_DESERIALIZE_FREEONCLOSE 1 /* Call sqlite3_free() on close */
-#define SQLITE_DESERIALIZE_RESIZEABLE  2 /* Resize using sqlite3_realloc64() */
-#define SQLITE_DESERIALIZE_READONLY    4 /* Database is read-only */
-
-/*
 ** Undo the hack that converts floating point types to integer for
 ** builds on processors without floating point support.
 */
@@ -9024,23 +8940,16 @@
 
 /*
 ** CAPI3REF: Session Object Handle
-**
-** An instance of this object is a [session] that can be used to
-** record changes to a database.
 */
 typedef struct sqlite3_session sqlite3_session;
 
 /*
 ** CAPI3REF: Changeset Iterator Handle
-**
-** An instance of this object acts as a cursor for iterating
-** over the elements of a [changeset] or [patchset].
 */
 typedef struct sqlite3_changeset_iter sqlite3_changeset_iter;
 
 /*
 ** CAPI3REF: Create A New Session Object
-** CONSTRUCTOR: sqlite3_session
 **
 ** Create a new session object attached to database handle db. If successful,
 ** a pointer to the new object is written to *ppSession and SQLITE_OK is
@@ -9077,7 +8986,6 @@
 
 /*
 ** CAPI3REF: Delete A Session Object
-** DESTRUCTOR: sqlite3_session
 **
 ** Delete a session object previously allocated using 
 ** [sqlite3session_create()]. Once a session object has been deleted, the
@@ -9093,7 +9001,6 @@
 
 /*
 ** CAPI3REF: Enable Or Disable A Session Object
-** METHOD: sqlite3_session
 **
 ** Enable or disable the recording of changes by a session object. When
 ** enabled, a session object records changes made to the database. When
@@ -9113,7 +9020,6 @@
 
 /*
 ** CAPI3REF: Set Or Clear the Indirect Change Flag
-** METHOD: sqlite3_session
 **
 ** Each change recorded by a session object is marked as either direct or
 ** indirect. A change is marked as indirect if either:
@@ -9143,7 +9049,6 @@
 
 /*
 ** CAPI3REF: Attach A Table To A Session Object
-** METHOD: sqlite3_session
 **
 ** If argument zTab is not NULL, then it is the name of a table to attach
 ** to the session object passed as the first argument. All subsequent changes 
@@ -9206,7 +9111,6 @@
 
 /*
 ** CAPI3REF: Set a table filter on a Session Object.
-** METHOD: sqlite3_session
 **
 ** The second argument (xFilter) is the "filter callback". For changes to rows 
 ** in tables that are not attached to the Session object, the filter is called
@@ -9225,7 +9129,6 @@
 
 /*
 ** CAPI3REF: Generate A Changeset From A Session Object
-** METHOD: sqlite3_session
 **
 ** Obtain a changeset containing changes to the tables attached to the 
 ** session object passed as the first argument. If successful, 
@@ -9335,8 +9238,7 @@
 );
 
 /*
-** CAPI3REF: Load The Difference Between Tables Into A Session
-** METHOD: sqlite3_session
+** CAPI3REF: Load The Difference Between Tables Into A Session 
 **
 ** If it is not already attached to the session object passed as the first
 ** argument, this function attaches table zTbl in the same manner as the
@@ -9401,7 +9303,6 @@
 
 /*
 ** CAPI3REF: Generate A Patchset From A Session Object
-** METHOD: sqlite3_session
 **
 ** The differences between a patchset and a changeset are that:
 **
@@ -9453,7 +9354,6 @@
 
 /*
 ** CAPI3REF: Create An Iterator To Traverse A Changeset 
-** CONSTRUCTOR: sqlite3_changeset_iter
 **
 ** Create an iterator used to iterate through the contents of a changeset.
 ** If successful, *pp is set to point to the iterator handle and SQLITE_OK
@@ -9494,7 +9394,6 @@
 
 /*
 ** CAPI3REF: Advance A Changeset Iterator
-** METHOD: sqlite3_changeset_iter
 **
 ** This function may only be used with iterators created by function
 ** [sqlite3changeset_start()]. If it is called on an iterator passed to
@@ -9519,7 +9418,6 @@
 
 /*
 ** CAPI3REF: Obtain The Current Operation From A Changeset Iterator
-** METHOD: sqlite3_changeset_iter
 **
 ** The pIter argument passed to this function may either be an iterator
 ** passed to a conflict-handler by [sqlite3changeset_apply()], or an iterator
@@ -9554,7 +9452,6 @@
 
 /*
 ** CAPI3REF: Obtain The Primary Key Definition Of A Table
-** METHOD: sqlite3_changeset_iter
 **
 ** For each modified table, a changeset includes the following:
 **
@@ -9586,7 +9483,6 @@
 
 /*
 ** CAPI3REF: Obtain old.* Values From A Changeset Iterator
-** METHOD: sqlite3_changeset_iter
 **
 ** The pIter argument passed to this function may either be an iterator
 ** passed to a conflict-handler by [sqlite3changeset_apply()], or an iterator
@@ -9617,7 +9513,6 @@
 
 /*
 ** CAPI3REF: Obtain new.* Values From A Changeset Iterator
-** METHOD: sqlite3_changeset_iter
 **
 ** The pIter argument passed to this function may either be an iterator
 ** passed to a conflict-handler by [sqlite3changeset_apply()], or an iterator
@@ -9651,7 +9546,6 @@
 
 /*
 ** CAPI3REF: Obtain Conflicting Row Values From A Changeset Iterator
-** METHOD: sqlite3_changeset_iter
 **
 ** This function should only be used with iterator objects passed to a
 ** conflict-handler callback by [sqlite3changeset_apply()] with either
@@ -9679,7 +9573,6 @@
 
 /*
 ** CAPI3REF: Determine The Number Of Foreign Key Constraint Violations
-** METHOD: sqlite3_changeset_iter
 **
 ** This function may only be called with an iterator passed to an
 ** SQLITE_CHANGESET_FOREIGN_KEY conflict handler callback. In this case
@@ -9696,7 +9589,6 @@
 
 /*
 ** CAPI3REF: Finalize A Changeset Iterator
-** METHOD: sqlite3_changeset_iter
 **
 ** This function is used to finalize an iterator allocated with
 ** [sqlite3changeset_start()].
@@ -9713,7 +9605,6 @@
 ** to that error is returned by this function. Otherwise, SQLITE_OK is
 ** returned. This is to allow the following pattern (pseudo-code):
 **
-** <pre>
 **   sqlite3changeset_start();
 **   while( SQLITE_ROW==sqlite3changeset_next() ){
 **     // Do something with change.
@@ -9722,7 +9613,6 @@
 **   if( rc!=SQLITE_OK ){
 **     // An error has occurred 
 **   }
-** </pre>
 */
 SQLITE_API int sqlite3changeset_finalize(sqlite3_changeset_iter *pIter);
 
@@ -9770,7 +9660,6 @@
 ** sqlite3_changegroup object. Calling it produces similar results as the
 ** following code fragment:
 **
-** <pre>
 **   sqlite3_changegroup *pGrp;
 **   rc = sqlite3_changegroup_new(&pGrp);
 **   if( rc==SQLITE_OK ) rc = sqlite3changegroup_add(pGrp, nA, pA);
@@ -9781,7 +9670,6 @@
 **     *ppOut = 0;
 **     *pnOut = 0;
 **   }
-** </pre>
 **
 ** Refer to the sqlite3_changegroup documentation below for details.
 */
@@ -9797,15 +9685,11 @@
 
 /*
 ** CAPI3REF: Changegroup Handle
-**
-** A changegroup is an object used to combine two or more 
-** [changesets] or [patchsets]
 */
 typedef struct sqlite3_changegroup sqlite3_changegroup;
 
 /*
 ** CAPI3REF: Create A New Changegroup Object
-** CONSTRUCTOR: sqlite3_changegroup
 **
 ** An sqlite3_changegroup object is used to combine two or more changesets
 ** (or patchsets) into a single changeset (or patchset). A single changegroup
@@ -9843,7 +9727,6 @@
 
 /*
 ** CAPI3REF: Add A Changeset To A Changegroup
-** METHOD: sqlite3_changegroup
 **
 ** Add all changes within the changeset (or patchset) in buffer pData (size
 ** nData bytes) to the changegroup. 
@@ -9921,7 +9804,6 @@
 
 /*
 ** CAPI3REF: Obtain A Composite Changeset From A Changegroup
-** METHOD: sqlite3_changegroup
 **
 ** Obtain a buffer containing a changeset (or patchset) representing the
 ** current contents of the changegroup. If the inputs to the changegroup
@@ -9952,25 +9834,25 @@
 
 /*
 ** CAPI3REF: Delete A Changegroup Object
-** DESTRUCTOR: sqlite3_changegroup
 */
 SQLITE_API void sqlite3changegroup_delete(sqlite3_changegroup*);
 
 /*
 ** CAPI3REF: Apply A Changeset To A Database
 **
-** Apply a changeset or patchset to a database. These functions attempt to
-** update the "main" database attached to handle db with the changes found in
-** the changeset passed via the second and third arguments. 
+** Apply a changeset to a database. This function attempts to update the
+** "main" database attached to handle db with the changes found in the
+** changeset passed via the second and third arguments.
 **
-** The fourth argument (xFilter) passed to these functions is the "filter
+** The fourth argument (xFilter) passed to this function is the "filter
 ** callback". If it is not NULL, then for each table affected by at least one
 ** change in the changeset, the filter callback is invoked with
 ** the table name as the second argument, and a copy of the context pointer
-** passed as the sixth argument as the first. If the "filter callback"
-** returns zero, then no attempt is made to apply any changes to the table.
-** Otherwise, if the return value is non-zero or the xFilter argument to
-** is NULL, all changes related to the table are attempted.
+** passed as the sixth argument to this function as the first. If the "filter
+** callback" returns zero, then no attempt is made to apply any changes to 
+** the table. Otherwise, if the return value is non-zero or the xFilter
+** argument to this function is NULL, all changes related to the table are
+** attempted.
 **
 ** For each table that is not excluded by the filter callback, this function 
 ** tests that the target database contains a compatible table. A table is 
@@ -10015,7 +9897,7 @@
 **
 ** <dl>
 ** <dt>DELETE Changes<dd>
-**   For each DELETE change, the function checks if the target database 
+**   For each DELETE change, this function checks if the target database 
 **   contains a row with the same primary key value (or values) as the 
 **   original row values stored in the changeset. If it does, and the values 
 **   stored in all non-primary key columns also match the values stored in 
@@ -10060,7 +9942,7 @@
 **   [SQLITE_CHANGESET_REPLACE].
 **
 ** <dt>UPDATE Changes<dd>
-**   For each UPDATE change, the function checks if the target database 
+**   For each UPDATE change, this function checks if the target database 
 **   contains a row with the same primary key value (or values) as the 
 **   original row values stored in the changeset. If it does, and the values 
 **   stored in all modified non-primary key columns also match the values
@@ -10091,21 +9973,11 @@
 ** This can be used to further customize the applications conflict
 ** resolution strategy.
 **
-** All changes made by these functions are enclosed in a savepoint transaction.
+** All changes made by this function are enclosed in a savepoint transaction.
 ** If any other error (aside from a constraint failure when attempting to
 ** write to the target database) occurs, then the savepoint transaction is
 ** rolled back, restoring the target database to its original state, and an 
 ** SQLite error code returned.
-**
-** If the output parameters (ppRebase) and (pnRebase) are non-NULL and
-** the input is a changeset (not a patchset), then sqlite3changeset_apply_v2()
-** may set (*ppRebase) to point to a "rebase" that may be used with the 
-** sqlite3_rebaser APIs buffer before returning. In this case (*pnRebase)
-** is set to the size of the buffer in bytes. It is the responsibility of the
-** caller to eventually free any such buffer using sqlite3_free(). The buffer
-** is only allocated and populated if one or more conflicts were encountered
-** while applying the patchset. See comments surrounding the sqlite3_rebaser
-** APIs for further details.
 */
 SQLITE_API int sqlite3changeset_apply(
   sqlite3 *db,                    /* Apply change to "main" db of this handle */
@@ -10122,22 +9994,6 @@
   ),
   void *pCtx                      /* First argument passed to xConflict */
 );
-SQLITE_API int sqlite3changeset_apply_v2(
-  sqlite3 *db,                    /* Apply change to "main" db of this handle */
-  int nChangeset,                 /* Size of changeset in bytes */
-  void *pChangeset,               /* Changeset blob */
-  int(*xFilter)(
-    void *pCtx,                   /* Copy of sixth arg to _apply() */
-    const char *zTab              /* Table name */
-  ),
-  int(*xConflict)(
-    void *pCtx,                   /* Copy of sixth arg to _apply() */
-    int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */
-    sqlite3_changeset_iter *p     /* Handle describing change and conflict */
-  ),
-  void *pCtx,                     /* First argument passed to xConflict */
-  void **ppRebase, int *pnRebase
-);
 
 /* 
 ** CAPI3REF: Constants Passed To The Conflict Handler
@@ -10235,161 +10091,6 @@
 #define SQLITE_CHANGESET_REPLACE    1
 #define SQLITE_CHANGESET_ABORT      2
 
-/* 
-** CAPI3REF: Rebasing changesets
-** EXPERIMENTAL
-**
-** Suppose there is a site hosting a database in state S0. And that
-** modifications are made that move that database to state S1 and a
-** changeset recorded (the "local" changeset). Then, a changeset based
-** on S0 is received from another site (the "remote" changeset) and 
-** applied to the database. The database is then in state 
-** (S1+"remote"), where the exact state depends on any conflict
-** resolution decisions (OMIT or REPLACE) made while applying "remote".
-** Rebasing a changeset is to update it to take those conflict 
-** resolution decisions into account, so that the same conflicts
-** do not have to be resolved elsewhere in the network. 
-**
-** For example, if both the local and remote changesets contain an
-** INSERT of the same key on "CREATE TABLE t1(a PRIMARY KEY, b)":
-**
-**   local:  INSERT INTO t1 VALUES(1, 'v1');
-**   remote: INSERT INTO t1 VALUES(1, 'v2');
-**
-** and the conflict resolution is REPLACE, then the INSERT change is
-** removed from the local changeset (it was overridden). Or, if the
-** conflict resolution was "OMIT", then the local changeset is modified
-** to instead contain:
-**
-**           UPDATE t1 SET b = 'v2' WHERE a=1;
-**
-** Changes within the local changeset are rebased as follows:
-**
-** <dl>
-** <dt>Local INSERT<dd>
-**   This may only conflict with a remote INSERT. If the conflict 
-**   resolution was OMIT, then add an UPDATE change to the rebased
-**   changeset. Or, if the conflict resolution was REPLACE, add
-**   nothing to the rebased changeset.
-**
-** <dt>Local DELETE<dd>
-**   This may conflict with a remote UPDATE or DELETE. In both cases the
-**   only possible resolution is OMIT. If the remote operation was a
-**   DELETE, then add no change to the rebased changeset. If the remote
-**   operation was an UPDATE, then the old.* fields of change are updated
-**   to reflect the new.* values in the UPDATE.
-**
-** <dt>Local UPDATE<dd>
-**   This may conflict with a remote UPDATE or DELETE. If it conflicts
-**   with a DELETE, and the conflict resolution was OMIT, then the update
-**   is changed into an INSERT. Any undefined values in the new.* record
-**   from the update change are filled in using the old.* values from
-**   the conflicting DELETE. Or, if the conflict resolution was REPLACE,
-**   the UPDATE change is simply omitted from the rebased changeset.
-**
-**   If conflict is with a remote UPDATE and the resolution is OMIT, then
-**   the old.* values are rebased using the new.* values in the remote
-**   change. Or, if the resolution is REPLACE, then the change is copied
-**   into the rebased changeset with updates to columns also updated by
-**   the conflicting remote UPDATE removed. If this means no columns would 
-**   be updated, the change is omitted.
-** </dl>
-**
-** A local change may be rebased against multiple remote changes 
-** simultaneously. If a single key is modified by multiple remote 
-** changesets, they are combined as follows before the local changeset
-** is rebased:
-**
-** <ul>
-**    <li> If there has been one or more REPLACE resolutions on a
-**         key, it is rebased according to a REPLACE.
-**
-**    <li> If there have been no REPLACE resolutions on a key, then
-**         the local changeset is rebased according to the most recent
-**         of the OMIT resolutions.
-** </ul>
-**
-** Note that conflict resolutions from multiple remote changesets are 
-** combined on a per-field basis, not per-row. This means that in the 
-** case of multiple remote UPDATE operations, some fields of a single 
-** local change may be rebased for REPLACE while others are rebased for 
-** OMIT.
-**
-** In order to rebase a local changeset, the remote changeset must first
-** be applied to the local database using sqlite3changeset_apply_v2() and
-** the buffer of rebase information captured. Then:
-**
-** <ol>
-**   <li> An sqlite3_rebaser object is created by calling 
-**        sqlite3rebaser_create().
-**   <li> The new object is configured with the rebase buffer obtained from
-**        sqlite3changeset_apply_v2() by calling sqlite3rebaser_configure().
-**        If the local changeset is to be rebased against multiple remote
-**        changesets, then sqlite3rebaser_configure() should be called
-**        multiple times, in the same order that the multiple
-**        sqlite3changeset_apply_v2() calls were made.
-**   <li> Each local changeset is rebased by calling sqlite3rebaser_rebase().
-**   <li> The sqlite3_rebaser object is deleted by calling
-**        sqlite3rebaser_delete().
-** </ol>
-*/
-typedef struct sqlite3_rebaser sqlite3_rebaser;
-
-/*
-** CAPI3REF: Create a changeset rebaser object.
-** EXPERIMENTAL
-**
-** Allocate a new changeset rebaser object. If successful, set (*ppNew) to
-** point to the new object and return SQLITE_OK. Otherwise, if an error
-** occurs, return an SQLite error code (e.g. SQLITE_NOMEM) and set (*ppNew) 
-** to NULL. 
-*/
-SQLITE_API int sqlite3rebaser_create(sqlite3_rebaser **ppNew);
-
-/*
-** CAPI3REF: Configure a changeset rebaser object.
-** EXPERIMENTAL
-**
-** Configure the changeset rebaser object to rebase changesets according
-** to the conflict resolutions described by buffer pRebase (size nRebase
-** bytes), which must have been obtained from a previous call to
-** sqlite3changeset_apply_v2().
-*/
-SQLITE_API int sqlite3rebaser_configure(
-  sqlite3_rebaser*, 
-  int nRebase, const void *pRebase
-); 
-
-/*
-** CAPI3REF: Rebase a changeset
-** EXPERIMENTAL
-**
-** Argument pIn must point to a buffer containing a changeset nIn bytes
-** in size. This function allocates and populates a buffer with a copy
-** of the changeset rebased rebased according to the configuration of the
-** rebaser object passed as the first argument. If successful, (*ppOut)
-** is set to point to the new buffer containing the rebased changset and 
-** (*pnOut) to its size in bytes and SQLITE_OK returned. It is the
-** responsibility of the caller to eventually free the new buffer using
-** sqlite3_free(). Otherwise, if an error occurs, (*ppOut) and (*pnOut)
-** are set to zero and an SQLite error code returned.
-*/
-SQLITE_API int sqlite3rebaser_rebase(
-  sqlite3_rebaser*,
-  int nIn, const void *pIn, 
-  int *pnOut, void **ppOut 
-);
-
-/*
-** CAPI3REF: Delete a changeset rebaser object.
-** EXPERIMENTAL
-**
-** Delete the changeset rebaser object and all associated resources. There
-** should be one call to this function for each successful invocation
-** of sqlite3rebaser_create().
-*/
-SQLITE_API void sqlite3rebaser_delete(sqlite3_rebaser *p); 
-
 /*
 ** CAPI3REF: Streaming Versions of API functions.
 **
@@ -10494,22 +10195,6 @@
   ),
   void *pCtx                      /* First argument passed to xConflict */
 );
-SQLITE_API int sqlite3changeset_apply_v2_strm(
-  sqlite3 *db,                    /* Apply change to "main" db of this handle */
-  int (*xInput)(void *pIn, void *pData, int *pnData), /* Input function */
-  void *pIn,                                          /* First arg for xInput */
-  int(*xFilter)(
-    void *pCtx,                   /* Copy of sixth arg to _apply() */
-    const char *zTab              /* Table name */
-  ),
-  int(*xConflict)(
-    void *pCtx,                   /* Copy of sixth arg to _apply() */
-    int eConflict,                /* DATA, MISSING, CONFLICT, CONSTRAINT */
-    sqlite3_changeset_iter *p     /* Handle describing change and conflict */
-  ),
-  void *pCtx,                     /* First argument passed to xConflict */
-  void **ppRebase, int *pnRebase
-);
 SQLITE_API int sqlite3changeset_concat_strm(
   int (*xInputA)(void *pIn, void *pData, int *pnData),
   void *pInA,
@@ -10547,13 +10232,6 @@
     int (*xOutput)(void *pOut, const void *pData, int nData), 
     void *pOut
 );
-SQLITE_API int sqlite3rebaser_rebase_strm(
-  sqlite3_rebaser *pRebaser,
-  int (*xInput)(void *pIn, void *pData, int *pnData),
-  void *pIn,
-  int (*xOutput)(void *pOut, const void *pData, int nData),
-  void *pOut
-);
 
 
 /*
